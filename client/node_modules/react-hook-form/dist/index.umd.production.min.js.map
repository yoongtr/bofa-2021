{"version":3,"file":"index.umd.production.min.js","sources":["../src/utils/isUndefined.ts","../src/utils/isNullOrUndefined.ts","../src/utils/isObject.ts","../src/utils/compact.ts","../src/utils/get.ts","../src/utils/isKey.ts","../src/utils/stringToPath.ts","../src/utils/set.ts","../src/logic/focusFieldBy.ts","../src/utils/isPrimitive.ts","../src/utils/deepEqual.ts","../src/logic/setFieldArrayDirtyFields.ts","../src/utils/deepMerge.ts","../src/utils/isEmptyObject.ts","../src/constants.ts","../src/logic/shouldRenderFormState.ts","../src/logic/getFieldValueAs.ts","../src/logic/getFieldsValues.ts","../src/logic/getRadioValue.ts","../src/utils/isRadioInput.ts","../src/utils/isFileInput.ts","../src/utils/isCheckBoxInput.ts","../src/utils/isMultipleSelect.ts","../src/logic/getCheckboxValue.ts","../src/logic/getFieldValue.ts","../src/logic/getMultipleSelectValue.ts","../src/utils/isRegex.ts","../src/logic/getValueAndMessage.ts","../src/utils/isString.ts","../src/utils/isFunction.ts","../src/utils/isBoolean.ts","../src/utils/isMessage.ts","../src/logic/getValidateError.ts","../src/logic/appendErrors.ts","../src/logic/validateField.ts","../src/logic/getNodeParentName.ts","../src/logic/isNameInFieldArray.ts","../src/logic/getProxyFormState.ts","../src/utils/Subject.ts","../src/utils/isWeb.ts","../src/utils/isProxyEnabled.ts","../src/utils/getPath.ts","../src/utils/unset.ts","../src/utils/getValidationModes.ts","../src/utils/isHTMLElement.ts","../src/logic/getFields.ts","../src/useForm.ts","../src/useFormContext.tsx","../src/logic/generateId.ts","../src/logic/mapId.ts","../src/utils/remove.ts","../src/utils/move.ts","../src/utils/swap.ts","../src/utils/prepend.ts","../src/utils/insert.ts","../src/utils/fillEmptyArray.ts","../src/useFormState.ts","../src/utils/cloneObject.ts","../src/useController.ts","../src/logic/getControllerValue.ts","../src/controller.tsx","../src/logic/transformToNestObject.ts","../src/useFieldArray.ts","../src/logic/isErrorStateChanged.ts","../src/logic/skipValidation.ts","../src/utils/isRadioOrCheckbox.ts","../src/useWatch.ts"],"sourcesContent":["export default (val: unknown): val is undefined => val === undefined;\n","export default (value: unknown): value is null | undefined => value == null;\n","import isNullOrUndefined from './isNullOrUndefined';\n\nexport const isObjectType = (value: unknown) => typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) &&\n  !Array.isArray(value) &&\n  isObjectType(value) &&\n  !(value instanceof Date);\n","export default (value: any[]) => value.filter(Boolean);\n","import isUndefined from './isUndefined';\nimport isNullOrUndefined from './isNullOrUndefined';\nimport compact from './compact';\n\nexport default (obj: any = {}, path: string, defaultValue?: unknown) => {\n  const result = compact(path.split(/[,[\\].]+?/)).reduce(\n    (result, key) => (isNullOrUndefined(result) ? result : result[key]),\n    obj,\n  );\n\n  return isUndefined(result) || result === obj\n    ? isUndefined(obj[path])\n      ? defaultValue\n      : obj[path]\n    : result;\n};\n","export default (value: string) => /^\\w*$/.test(value);\n","import compact from './compact';\n\nexport default (input: string): string[] =>\n  compact(\n    input\n      .replace(/[\"|']/g, '')\n      .replace(/\\[/g, '.')\n      .replace(/\\]/g, '')\n      .split('.'),\n  );\n","import isObject from './isObject';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport { FieldValues } from '../types';\n\nexport default function set(\n  object: FieldValues,\n  path: string,\n  value?: unknown,\n) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue =\n        isObject(objValue) || Array.isArray(objValue)\n          ? objValue\n          : !isNaN(+tempPath[index + 1])\n          ? []\n          : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport { get } from '../utils';\nimport { FieldRefs, InternalFieldName } from '../types';\n\nconst focusFieldBy = (\n  fields: FieldRefs,\n  callback: (name: string) => boolean,\n  fieldsNames?: Set<InternalFieldName>,\n) => {\n  for (const key of fieldsNames || Object.keys(fields)) {\n    const field = get(fields, key);\n\n    if (field) {\n      const { _f, ...current } = field;\n\n      if (_f && callback(_f.name)) {\n        if (_f.ref.focus && isUndefined(_f.ref.focus())) {\n          break;\n        } else if (_f.refs) {\n          _f.refs[0].focus();\n          break;\n        }\n      } else if (isObject(current)) {\n        focusFieldBy(current, callback);\n      }\n    }\n  }\n};\n\nexport default focusFieldBy;\n","import isNullOrUndefined from './isNullOrUndefined';\nimport { isObjectType } from './isObject';\nimport { Primitive } from '../types';\n\nexport default (value: unknown): value is Primitive =>\n  isNullOrUndefined(value) || !isObjectType(value);\n","import * as React from 'react';\nimport isObject from '../utils/isObject';\nimport isPrimitive from './isPrimitive';\n\nexport default function deepEqual(\n  object1: any,\n  object2: any,\n  isErrorObject?: boolean,\n) {\n  if (\n    isPrimitive(object1) ||\n    isPrimitive(object2) ||\n    object1 instanceof Date ||\n    object2 instanceof Date\n  ) {\n    return object1 === object2;\n  }\n\n  if (!React.isValidElement(object1)) {\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const val1 = object1[key];\n\n      if (!(isErrorObject && key === 'ref')) {\n        const val2 = object2[key];\n\n        if (\n          (isObject(val1) || Array.isArray(val1)) &&\n          (isObject(val2) || Array.isArray(val2))\n            ? !deepEqual(val1, val2, isErrorObject)\n            : val1 !== val2\n        ) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n","import { get } from '../utils';\nimport set from '../utils/set';\nimport { deepMerge } from '../utils/deepMerge';\nimport deepEqual from '../utils/deepEqual';\n\nfunction setDirtyFields<\n  T extends Record<string, unknown>[],\n  U extends Record<string, unknown>[],\n  K extends Record<string, boolean | []>\n>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n  parentNode?: K,\n  parentName?: keyof K,\n) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(\n          values[index][key] as T,\n          get(defaultValues[index] || {}, key, []),\n          dirtyFields[index][key] as [],\n          dirtyFields[index],\n          key,\n        );\n      } else {\n        deepEqual(get(defaultValues[index] || {}, key), values[index][key])\n          ? set(dirtyFields[index] || {}, key)\n          : (dirtyFields[index] = {\n              ...dirtyFields[index],\n              [key]: true,\n            });\n      }\n    }\n\n    parentNode &&\n      !dirtyFields.length &&\n      delete parentNode[parentName as keyof K];\n  }\n\n  return dirtyFields;\n}\n\nexport default <T extends U, U extends Record<string, unknown>[]>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n) =>\n  deepMerge(\n    setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)),\n    setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)),\n  );\n","import isObject from './isObject';\nimport isPrimitive from './isPrimitive';\n\nexport function deepMerge<\n  T extends Record<keyof T, any>,\n  U extends Record<keyof U, any>\n>(target: T, source: U): T & U {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] =\n        (isObject(targetValue) && isObject(sourceValue)) ||\n        (Array.isArray(targetValue) && Array.isArray(sourceValue))\n          ? deepMerge(targetValue, sourceValue)\n          : sourceValue;\n    } catch {}\n  }\n\n  return target;\n}\n","import isObject from './isObject';\nimport { EmptyObject } from '../types';\n\nexport default (value: unknown): value is EmptyObject =>\n  isObject(value) && !Object.keys(value).length;\n","import { ValidationMode } from './types';\n\nexport const EVENTS = {\n  BLUR: 'blur',\n};\n\nexport const VALIDATION_MODE: ValidationMode = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all',\n};\n\nexport const SELECT = 'select';\n\nexport const UNDEFINED = 'undefined';\n\nexport const INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate',\n};\n","import isEmptyObject from '../utils/isEmptyObject';\nimport { ReadFormState } from '../types';\nimport { VALIDATION_MODE } from '../constants';\n\nexport default <T, K extends ReadFormState>(\n  formState: T,\n  readFormStateRef: K,\n  isRoot?: boolean,\n) =>\n  isEmptyObject(formState) ||\n  Object.keys(formState).length >= Object.keys(readFormStateRef).length ||\n  Object.keys(formState).find(\n    (key) =>\n      readFormStateRef[key as keyof ReadFormState] ===\n      (isRoot ? VALIDATION_MODE.all : true),\n  );\n","import { Field } from '../types';\n\nexport default (\n  value: any,\n  { valueAsNumber, valueAsDate, setValueAs }: Field['_f'],\n  shouldReturnAsValue?: boolean,\n) =>\n  shouldReturnAsValue\n    ? valueAsNumber\n      ? value === ''\n        ? NaN\n        : +value\n      : valueAsDate\n      ? new Date(value)\n      : setValueAs\n      ? setValueAs(value)\n      : value\n    : value;\n","import * as React from 'react';\nimport set from '../utils/set';\nimport getFieldValueAs from './getFieldValueAs';\nimport { FieldRefs, FieldValues } from '../types';\n\nconst getFieldsValues = (\n  fieldsRef: React.MutableRefObject<FieldRefs>,\n  defaultValuesRef: React.MutableRefObject<FieldValues>,\n  shouldReturnAsValue?: boolean,\n  output: Record<string, any> = {},\n): any => {\n  for (const name in fieldsRef.current) {\n    const field = fieldsRef.current[name];\n\n    if (field) {\n      const { _f, ...current } = field;\n      set(\n        output,\n        name,\n        _f && !_f.ref.disabled\n          ? getFieldValueAs(_f.value, _f, shouldReturnAsValue)\n          : Array.isArray(field)\n          ? []\n          : {},\n      );\n\n      if (current) {\n        getFieldsValues(\n          {\n            current,\n          },\n          defaultValuesRef,\n          shouldReturnAsValue,\n          output[name],\n        );\n      }\n    }\n  }\n\n  return {\n    ...defaultValuesRef.current,\n    ...output,\n  };\n};\n\nexport default getFieldsValues;\n","type RadioFieldResult = {\n  isValid: boolean;\n  value: number | string | null;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: null,\n};\n\nexport default (options?: HTMLInputElement[]): RadioFieldResult =>\n  Array.isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.checked\n            ? {\n                isValid: true,\n                value: option.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'radio';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-multiple`;\n","import isUndefined from '../utils/isUndefined';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: HTMLInputElement[]): CheckboxFieldResult => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.checked)\n        .map(({ value }) => value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    const { checked, value, attributes } = options[0];\n\n    return checked\n      ? // @ts-expect-error\n        attributes && !isUndefined(attributes.value)\n        ? isUndefined(value)\n          ? validResult\n          : { value: value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n","import getRadioValue from './getRadioValue';\nimport getMultipleSelectValue from './getMultipleSelectValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport isFileInput from '../utils/isFileInput';\nimport isCheckBox from '../utils/isCheckBoxInput';\nimport isMultipleSelect from '../utils/isMultipleSelect';\nimport getCheckboxValue from './getCheckboxValue';\nimport getFieldValueAs from './getFieldValueAs';\nimport { Field } from '../types';\n\nexport default function getFieldValue(\n  field?: Field,\n  shouldReturnAsValue?: boolean,\n) {\n  if (field && field._f) {\n    const { ref } = field._f;\n\n    if (ref.disabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field._f.refs).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBox(ref)) {\n      return getCheckboxValue(field._f.refs).value;\n    }\n\n    return getFieldValueAs(ref.value, field._f, shouldReturnAsValue);\n  }\n}\n","export default (\n  options: HTMLOptionElement[] | HTMLOptionsCollection,\n): string[] =>\n  [...options]\n    .filter(({ selected }): boolean => selected)\n    .map(({ value }): string => value);\n","export default (value: unknown): value is RegExp => value instanceof RegExp;\n","import isObject from '../utils/isObject';\nimport isRegex from '../utils/isRegex';\nimport { ValidationRule } from '../types';\n\nexport default (validationData?: ValidationRule) =>\n  isObject(validationData) && !isRegex(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n      };\n","export default (value: unknown): value is string => typeof value === 'string';\n","export default (value: unknown): value is Function =>\n  typeof value === 'function';\n","export default (value: unknown): value is boolean => typeof value === 'boolean';\n","import * as React from 'react';\nimport isString from '../utils/isString';\nimport { Message } from '../types';\n\nexport default (value: unknown): value is Message =>\n  isString(value) || React.isValidElement(value as JSX.Element);\n","import isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport { FieldError, ValidateResult, Ref } from '../types';\n\nexport default function getValidateError(\n  result: ValidateResult,\n  ref: Ref,\n  type = 'validate',\n): FieldError | void {\n  if (isMessage(result) || (isBoolean(result) && !result)) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref,\n    };\n  }\n}\n","import {\n  InternalFieldName,\n  ValidateResult,\n  InternalFieldErrors,\n} from '../types';\n\nexport default (\n  name: InternalFieldName,\n  validateAllFieldCriteria: boolean,\n  errors: InternalFieldErrors,\n  type: string,\n  message: ValidateResult,\n) =>\n  validateAllFieldCriteria\n    ? {\n        ...errors[name],\n        types: {\n          ...(errors[name] && errors[name]!.types ? errors[name]!.types : {}),\n          [type]: message || true,\n        },\n      }\n    : {};\n","import getRadioValue from './getRadioValue';\nimport getCheckboxValue from './getCheckboxValue';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isRadioInput from '../utils/isRadioInput';\nimport getValueAndMessage from './getValueAndMessage';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isString from '../utils/isString';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isObject from '../utils/isObject';\nimport isFunction from '../utils/isFunction';\nimport isRegex from '../utils/isRegex';\nimport isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport getValidateError from './getValidateError';\nimport appendErrors from './appendErrors';\nimport { INPUT_VALIDATION_RULES } from '../constants';\nimport { Field, Message, FieldError, InternalFieldErrors } from '../types';\n\nexport default async (\n  {\n    _f: {\n      ref,\n      refs,\n      required,\n      maxLength,\n      minLength,\n      min,\n      max,\n      pattern,\n      validate,\n      name,\n      value: inputValue,\n    },\n  }: Field,\n  validateAllFieldCriteria: boolean,\n): Promise<InternalFieldErrors> => {\n  const error: InternalFieldErrors = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty =\n    !inputValue || (Array.isArray(inputValue) && !inputValue.length);\n  const appendErrorsCurry = appendErrors.bind(\n    null,\n    name,\n    validateAllFieldCriteria,\n    error,\n  );\n  const getMinMaxMessage = (\n    exceedMax: boolean,\n    maxLengthMessage: Message,\n    minLengthMessage: Message,\n    maxType = INPUT_VALIDATION_RULES.maxLength,\n    minType = INPUT_VALIDATION_RULES.minLength,\n  ) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = {\n      type: exceedMax ? maxType : minType,\n      message,\n      ref,\n      ...(exceedMax\n        ? appendErrorsCurry(maxType, message)\n        : appendErrorsCurry(minType, message)),\n    };\n  };\n\n  if (\n    required &&\n    ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue))) ||\n      (isBoolean(inputValue) && !inputValue) ||\n      (isCheckBox && !getCheckboxValue(refs).isValid) ||\n      (isRadio && !getRadioValue(refs).isValid))\n  ) {\n    const { value, message } = isMessage(required)\n      ? { value: !!required, message: required }\n      : getValueAndMessage(required);\n\n    if (value) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.required,\n        message,\n        ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (\n    (!isNullOrUndefined(min) || !isNullOrUndefined(max)) &&\n    inputValue !== ''\n  ) {\n    let exceedMax;\n    let exceedMin;\n    const maxOutput = getValueAndMessage(max);\n    const minOutput = getValueAndMessage(min);\n\n    if (!isNaN(inputValue)) {\n      const valueNumber =\n        (ref as HTMLInputElement).valueAsNumber || parseFloat(inputValue);\n      if (!isNullOrUndefined(maxOutput.value)) {\n        exceedMax = valueNumber > maxOutput.value;\n      }\n      if (!isNullOrUndefined(minOutput.value)) {\n        exceedMin = valueNumber < minOutput.value;\n      }\n    } else {\n      const valueDate =\n        (ref as HTMLInputElement).valueAsDate || new Date(inputValue);\n      if (isString(maxOutput.value)) {\n        exceedMax = valueDate > new Date(maxOutput.value);\n      }\n      if (isString(minOutput.value)) {\n        exceedMin = valueDate < new Date(minOutput.value);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        !!exceedMax,\n        maxOutput.message,\n        minOutput.message,\n        INPUT_VALIDATION_RULES.max,\n        INPUT_VALIDATION_RULES.min,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\n    const maxLengthOutput = getValueAndMessage(maxLength);\n    const minLengthOutput = getValueAndMessage(minLength);\n    const exceedMax =\n      !isNullOrUndefined(maxLengthOutput.value) &&\n      inputValue.length > maxLengthOutput.value;\n    const exceedMin =\n      !isNullOrUndefined(minLengthOutput.value) &&\n      inputValue.length < minLengthOutput.value;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        exceedMax,\n        maxLengthOutput.message,\n        minLengthOutput.message,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(inputValue) && pattern && !isEmpty) {\n    const { value: patternValue, message } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(inputValue)) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.pattern,\n        message,\n        ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(inputValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = {\n          ...validateError,\n          ...appendErrorsCurry(\n            INPUT_VALIDATION_RULES.validate,\n            validateError.message,\n          ),\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {} as FieldError;\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(inputValue);\n        const validateError = getValidateError(\n          validateResult,\n          validateRef,\n          key,\n        );\n\n        if (validateError) {\n          validationResult = {\n            ...validateError,\n            ...appendErrorsCurry(key, validateError.message),\n          };\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = {\n          ref: validateRef,\n          ...validationResult,\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n","export default (name: string) => name.substring(0, name.search(/.\\d/)) || name;\n","import getNodeParentName from './getNodeParentName';\nimport { InternalFieldName } from '../types';\n\nexport default (names: Set<InternalFieldName>, name: InternalFieldName) =>\n  [...names].some((current) => getNodeParentName(name) === current);\n","import * as React from 'react';\nimport { FormState, FormStateProxy, ReadFormState } from '../types';\nimport { VALIDATION_MODE } from '../constants';\n\nexport default <TFieldValues>(\n  isProxyEnabled: boolean,\n  formState: FormState<TFieldValues>,\n  readFormStateRef: React.MutableRefObject<ReadFormState>,\n  localReadFormStateRef?: React.MutableRefObject<ReadFormState>,\n  isRoot = true,\n) =>\n  isProxyEnabled\n    ? new Proxy(formState, {\n        get: (obj, prop: keyof FormStateProxy) => {\n          if (prop in obj) {\n            if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\n              readFormStateRef.current[prop] = isRoot\n                ? VALIDATION_MODE.all\n                : true;\n            }\n            localReadFormStateRef &&\n              (localReadFormStateRef.current[prop] = true);\n            return obj[prop];\n          }\n\n          return undefined;\n        },\n      })\n    : formState;\n","export type Observer<T> = {\n  next: (value: T) => void;\n};\n\ntype TearDown = () => void;\n\nexport type SubjectType<T> = {\n  next: (value: T) => void;\n  subscribe: (\n    value: Observer<T>,\n  ) => {\n    unsubscribe: TearDown;\n  };\n};\n\nexport class Subscription {\n  private tearDowns: TearDown[] = [];\n\n  add(tearDown: TearDown) {\n    this.tearDowns.push(tearDown);\n  }\n\n  unsubscribe() {\n    for (const teardown of this.tearDowns) {\n      teardown();\n    }\n    this.tearDowns = [];\n  }\n}\n\nclass Subscriber<T> implements Observer<T> {\n  closed = false;\n\n  constructor(private observer: Observer<T>, subscription: Subscription) {\n    subscription.add(() => (this.closed = true));\n  }\n\n  next(value: T) {\n    if (!this.closed) {\n      this.observer.next(value);\n    }\n  }\n}\n\nexport default class Subject<T> {\n  observers: Observer<T>[];\n\n  constructor() {\n    this.observers = [];\n  }\n\n  next(value: T) {\n    for (const observer of this.observers) {\n      observer.next(value);\n    }\n  }\n\n  subscribe(observer: Observer<T>) {\n    const subscription = new Subscription();\n    const subscriber = new Subscriber(observer, subscription);\n    this.observers.push(subscriber);\n\n    return subscription;\n  }\n\n  unsubscribe() {\n    this.observers = [];\n  }\n}\n","import { UNDEFINED } from '../constants';\n\nexport default typeof window !== UNDEFINED && typeof document !== UNDEFINED;\n","import isWeb from './isWeb';\nimport { UNDEFINED } from '../constants';\n\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nexport default isProxyEnabled;\n","import isPrimitive from './isPrimitive';\nimport { FieldName } from '../types';\n\nexport const getPath = <TFieldValues>(\n  rootPath: FieldName<TFieldValues>,\n  values: any,\n  paths: FieldName<TFieldValues>[] = [],\n): FieldName<TFieldValues>[] => {\n  for (const property in values) {\n    isPrimitive(values[property])\n      ? paths.push(`${rootPath}.${property}` as FieldName<TFieldValues>)\n      : getPath(\n          `${rootPath}.${property}` as FieldName<TFieldValues>,\n          values[property],\n          paths,\n        );\n  }\n\n  return paths;\n};\n","import isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport isEmptyObject from './isEmptyObject';\nimport isObject from './isObject';\nimport isUndefined from './isUndefined';\nimport isBoolean from './isBoolean';\n\nfunction baseGet(object: any, updatePath: (string | number)[]) {\n  const length = updatePath.slice(0, -1).length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nexport default function unset(object: any, path: string) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject =\n    updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (\n        currentPathsLength === index &&\n        ((isObject(objectRef) && isEmptyObject(objectRef)) ||\n          (Array.isArray(objectRef) &&\n            !objectRef.filter(\n              (data) =>\n                (isObject(data) && !isEmptyObject(data)) || isBoolean(data),\n            ).length))\n      ) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n","import { VALIDATION_MODE } from '../constants';\nimport { Mode } from '../types';\n\nexport default (\n  mode?: Mode,\n): {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n  isOnTouch: boolean;\n} => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched,\n});\n","export default (value: any): value is HTMLElement =>\n  value instanceof HTMLElement;\n","import { Field, FieldRefs, InternalFieldName } from '../types';\nimport { get } from '../utils';\nimport isKey from '../utils/isKey';\nimport set from '../utils/set';\n\nexport default function getFields(\n  fieldsNames: Set<InternalFieldName> | InternalFieldName[],\n  fieldsRefs: FieldRefs,\n) {\n  const currentFields: Record<InternalFieldName, Field['_f']> = {};\n\n  for (const name of fieldsNames) {\n    const field = get(fieldsRefs, name) as Field | undefined;\n\n    if (field) {\n      !isKey(name)\n        ? set(currentFields, name, field._f)\n        : (currentFields[name] = field._f);\n    }\n  }\n\n  return currentFields;\n}\n","import * as React from 'react';\nimport focusFieldBy from './logic/focusFieldBy';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport shouldRenderFormState from './logic/shouldRenderFormState';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldValue from './logic/getFieldValue';\nimport isErrorStateChanged from './logic/isErrorStateChanged';\nimport validateField from './logic/validateField';\nimport skipValidation from './logic/skipValidation';\nimport getNodeParentName from './logic/getNodeParentName';\nimport deepEqual from './utils/deepEqual';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport getProxyFormState from './logic/getProxyFormState';\nimport Subject, { Subscription } from './utils/Subject';\nimport isProxyEnabled from './utils/isProxyEnabled';\nimport isCheckBoxInput from './utils/isCheckBoxInput';\nimport isEmptyObject from './utils/isEmptyObject';\nimport isRadioInput from './utils/isRadioInput';\nimport isFileInput from './utils/isFileInput';\nimport { getPath } from './utils/getPath';\nimport isFunction from './utils/isFunction';\nimport isString from './utils/isString';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport unset from './utils/unset';\nimport getValidationModes from './utils/getValidationModes';\nimport isMultipleSelect from './utils/isMultipleSelect';\nimport compact from './utils/compact';\nimport isNullOrUndefined from './utils/isNullOrUndefined';\nimport isRadioOrCheckboxFunction from './utils/isRadioOrCheckbox';\nimport isWeb from './utils/isWeb';\nimport isHTMLElement from './utils/isHTMLElement';\nimport getFields from './logic/getFields';\nimport { EVENTS, UNDEFINED, VALIDATION_MODE } from './constants';\nimport {\n  UseFormMethods,\n  FieldValues,\n  UnpackNestedValue,\n  FieldName,\n  InternalFieldName,\n  Field,\n  FieldRefs,\n  UseFormProps,\n  RegisterOptions,\n  ReadFormState,\n  Ref,\n  SetValueConfig,\n  FormState,\n  FieldNamesMarkedBoolean,\n  DeepPartial,\n  InternalNameSet,\n  DefaultValues,\n  FieldError,\n  SetFieldValue,\n  FieldArrayDefaultValues,\n  RegisterCallback,\n  FieldPath,\n  WatchObserver,\n  FieldPathValue,\n  FieldPathValues,\n  KeepStateOptions,\n  EventType,\n  UseFormTrigger,\n  UseFormSetValue,\n  UseFormUnregister,\n  UseFormClearErrors,\n  UseFormSetError,\n  UseFormRegister,\n  UseFormHandleSubmit,\n  UseFormReset,\n  WatchInternal,\n  GetFormIsDirty,\n  HandleChange,\n} from './types';\n\nconst isWindowUndefined = typeof window === UNDEFINED;\n\nexport function useForm<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext extends object = object\n>({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {} as DefaultValues<TFieldValues>,\n  shouldFocusError = true,\n  criteriaMode,\n}: UseFormProps<TFieldValues, TContext> = {}): UseFormMethods<TFieldValues> {\n  const fieldsRef = React.useRef<FieldRefs>({});\n  const fieldsNamesRef = React.useRef<Set<InternalFieldName>>(new Set());\n  const formStateSubjectRef = React.useRef(\n    new Subject<Partial<FormState<TFieldValues>>>(),\n  );\n  const watchSubjectRef = React.useRef(\n    new Subject<{\n      name?: InternalFieldName;\n      type?: EventType;\n      value?: unknown;\n    }>(),\n  );\n  const controllerSubjectRef = React.useRef(\n    new Subject<DefaultValues<TFieldValues>>(),\n  );\n  const fieldArraySubjectRef = React.useRef(\n    new Subject<{\n      name?: InternalFieldName;\n      fields: any;\n      isReset?: boolean;\n    }>(),\n  );\n  const fieldArrayUpdatedValuesRef = React.useRef<{\n    name?: InternalFieldName;\n    fields?: DeepPartial<TFieldValues>;\n  }>({});\n  const fieldArrayDefaultValuesRef = React.useRef<FieldArrayDefaultValues>({});\n  const watchFieldsRef = React.useRef<InternalNameSet>(new Set());\n  const isMountedRef = React.useRef(false);\n  const fieldsWithValidationRef = React.useRef<\n    FieldNamesMarkedBoolean<TFieldValues>\n  >({});\n  const validFieldsRef = React.useRef<FieldNamesMarkedBoolean<TFieldValues>>(\n    {},\n  );\n  const defaultValuesRef = React.useRef<DefaultValues<TFieldValues>>(\n    defaultValues,\n  );\n  const isWatchAllRef = React.useRef(false);\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef<InternalNameSet>(new Set());\n  const validationMode = getValidationModes(mode);\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = React.useState<FormState<TFieldValues>>({\n    isDirty: false,\n    isValidating: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touchedFields: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !validationMode.isOnSubmit,\n    errors: {},\n  });\n  const readFormStateRef = React.useRef<ReadFormState>({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touchedFields: !isProxyEnabled || validationMode.isOnTouch,\n    isValidating: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n    errors: !isProxyEnabled,\n  });\n  const formStateRef = React.useRef(formState);\n\n  contextRef.current = context;\n  resolverRef.current = resolver;\n\n  const getIsValid = () =>\n    (formStateRef.current.isValid =\n      deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\n      isEmptyObject(formStateRef.current.errors));\n\n  const shouldRenderBaseOnError = React.useCallback(\n    (\n      name: InternalFieldName,\n      error?: FieldError,\n      shouldRender: boolean | null = false,\n      state: {\n        dirty?: FieldNamesMarkedBoolean<TFieldValues>;\n        isDirty?: boolean;\n        touched?: FieldNamesMarkedBoolean<TFieldValues>;\n      } = {},\n      isValid?: boolean,\n    ): boolean | void => {\n      let shouldReRender =\n        shouldRender ||\n        isErrorStateChanged<TFieldValues>({\n          errors: formStateRef.current.errors,\n          error,\n          name,\n          validFields: validFieldsRef.current,\n          fieldsWithValidation: fieldsWithValidationRef.current,\n        });\n      const previousError = get(formStateRef.current.errors, name);\n\n      if (error) {\n        unset(validFieldsRef.current, name);\n        shouldReRender =\n          shouldReRender ||\n          !previousError ||\n          !deepEqual(previousError, error, true);\n        set(formStateRef.current.errors, name, error);\n      } else {\n        if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n          set(validFieldsRef.current, name, true);\n          shouldReRender = shouldReRender || previousError;\n        }\n\n        unset(formStateRef.current.errors, name);\n      }\n\n      if (\n        (shouldReRender && !isNullOrUndefined(shouldRender)) ||\n        !isEmptyObject(state)\n      ) {\n        formStateSubjectRef.current.next({\n          ...state,\n          isValid: resolverRef.current ? isValid : getIsValid(),\n          errors: formStateRef.current.errors,\n        });\n      }\n\n      formStateSubjectRef.current.next({\n        isValidating: false,\n      });\n    },\n    [],\n  );\n\n  const setFieldValue = React.useCallback(\n    (name: InternalFieldName, rawValue: SetFieldValue<TFieldValues>) => {\n      const { _f } = get(fieldsRef.current, name) as Field;\n\n      if (_f) {\n        const { ref, refs } = _f;\n        const value =\n          isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\n            ? ''\n            : rawValue;\n        _f.value = rawValue;\n\n        if (isRadioInput(ref)) {\n          (refs || []).forEach(\n            (radioRef: HTMLInputElement) =>\n              (radioRef.checked = radioRef.value === value),\n          );\n        } else if (isFileInput(ref) && !isString(value)) {\n          ref.files = value as FileList;\n        } else if (isMultipleSelect(ref)) {\n          [...ref.options].forEach(\n            (selectRef) =>\n              (selectRef.selected = (value as string[]).includes(\n                selectRef.value,\n              )),\n          );\n        } else if (isCheckBoxInput(ref) && refs) {\n          refs.length > 1\n            ? refs.forEach(\n                (checkboxRef) =>\n                  (checkboxRef.checked = Array.isArray(value)\n                    ? !!(value as []).find(\n                        (data: string) => data === checkboxRef.value,\n                      )\n                    : value === checkboxRef.value),\n              )\n            : (refs[0].checked = !!value);\n        } else {\n          ref.value = value;\n        }\n      }\n    },\n    [],\n  );\n\n  const getFormIsDirty: GetFormIsDirty = React.useCallback((name, data) => {\n    if (readFormStateRef.current.isDirty) {\n      const formValues = getValues();\n\n      name && data && set(formValues, name, data);\n\n      return !deepEqual(formValues, defaultValuesRef.current);\n    }\n\n    return false;\n  }, []);\n\n  const updateAndGetDirtyState = React.useCallback(\n    (\n      name: InternalFieldName,\n      shouldRender = true,\n    ): Partial<\n      Pick<FormState<TFieldValues>, 'dirtyFields' | 'isDirty' | 'touchedFields'>\n    > => {\n      if (\n        readFormStateRef.current.isDirty ||\n        readFormStateRef.current.dirtyFields\n      ) {\n        const isFieldDirty = !deepEqual(\n          get(defaultValuesRef.current, name),\n          getFieldValue(get(fieldsRef.current, name) as Field, true),\n        );\n        const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n        const previousIsDirty = formStateRef.current.isDirty;\n\n        isFieldDirty\n          ? set(formStateRef.current.dirtyFields, name, true)\n          : unset(formStateRef.current.dirtyFields, name);\n\n        const state = {\n          isDirty: getFormIsDirty(),\n          dirtyFields: formStateRef.current.dirtyFields,\n        };\n\n        const isChanged =\n          (readFormStateRef.current.isDirty &&\n            previousIsDirty !== state.isDirty) ||\n          (readFormStateRef.current.dirtyFields &&\n            isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\n\n        isChanged && shouldRender && formStateSubjectRef.current.next(state);\n\n        return isChanged ? state : {};\n      }\n\n      return {};\n    },\n    [],\n  );\n\n  const executeValidation = React.useCallback(\n    async (\n      name: InternalFieldName,\n      skipReRender?: boolean | null,\n    ): Promise<boolean> => {\n      const error = (\n        await validateField(\n          get(fieldsRef.current, name) as Field,\n          isValidateAllFieldCriteria,\n        )\n      )[name];\n\n      shouldRenderBaseOnError(name, error, skipReRender);\n\n      return isUndefined(error);\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const executeSchemaOrResolverValidation = React.useCallback(\n    async (\n      names: InternalFieldName[],\n      currentNames: FieldName<TFieldValues>[] = [],\n    ) => {\n      const { errors } = await resolverRef.current!(\n        getFieldsValues(fieldsRef, defaultValuesRef, true),\n        contextRef.current,\n        {\n          criteriaMode,\n          names: currentNames,\n          fields: getFields(fieldsNamesRef.current, fieldsRef.current),\n        },\n      );\n\n      for (const name of names) {\n        const error = get(errors, name);\n        error\n          ? set(formStateRef.current.errors, name, error)\n          : unset(formStateRef.current.errors, name);\n      }\n\n      return errors;\n    },\n    [shouldRenderBaseOnError, criteriaMode],\n  );\n\n  const validateForm = async (fieldsRef: FieldRefs) => {\n    for (const name in fieldsRef) {\n      const field = fieldsRef[name];\n\n      if (field) {\n        const { _f, ...current } = field;\n\n        if (_f) {\n          const fieldError = await validateField(\n            field,\n            isValidateAllFieldCriteria,\n          );\n\n          if (fieldError[field._f.name]) {\n            set(\n              formStateRef.current.errors,\n              field._f.name,\n              fieldError[field._f.name],\n            );\n            unset(validFieldsRef.current, field._f.name);\n          } else if (get(fieldsWithValidationRef.current, field._f.name)) {\n            set(validFieldsRef.current, field._f.name, true);\n            unset(formStateRef.current.errors, field._f.name);\n          }\n        }\n\n        current && (await validateForm(current));\n      }\n    }\n  };\n\n  const trigger: UseFormTrigger<TFieldValues> = React.useCallback(\n    async (name) => {\n      const fields = isUndefined(name)\n        ? Object.keys(fieldsRef.current)\n        : Array.isArray(name)\n        ? name\n        : [name];\n      let isValid;\n\n      formStateSubjectRef.current.next({\n        isValidating: true,\n      });\n\n      if (resolver) {\n        isValid = isEmptyObject(\n          await executeSchemaOrResolverValidation(\n            fields,\n            isUndefined(name)\n              ? undefined\n              : (fields as FieldName<TFieldValues>[]),\n          ),\n        );\n      } else {\n        isUndefined(name)\n          ? await validateForm(fieldsRef.current)\n          : await Promise.all(\n              fields.map(async (data) => await executeValidation(data, null)),\n            );\n      }\n\n      formStateSubjectRef.current.next({\n        errors: formStateRef.current.errors,\n        isValidating: false,\n        isValid: resolver ? isValid : getIsValid(),\n      });\n    },\n    [executeSchemaOrResolverValidation, executeValidation],\n  );\n\n  const setInternalValues = React.useCallback(\n    (\n      name: FieldName<TFieldValues>,\n      value: SetFieldValue<TFieldValues>,\n      { shouldDirty, shouldValidate }: SetValueConfig,\n    ) => {\n      const data = {};\n      set(data, name, value);\n\n      for (const fieldName of getPath(name, value)) {\n        if (get(fieldsRef.current, fieldName)) {\n          setFieldValue(fieldName, get(data, fieldName));\n          shouldDirty && updateAndGetDirtyState(fieldName);\n          shouldValidate && trigger(fieldName as FieldName<TFieldValues>);\n        }\n      }\n    },\n    [trigger, setFieldValue, updateAndGetDirtyState],\n  );\n\n  const setInternalValue = React.useCallback(\n    (\n      name: FieldName<TFieldValues>,\n      value: SetFieldValue<TFieldValues>,\n      options: SetValueConfig,\n    ) => {\n      const field = get(fieldsRef.current, name);\n\n      if (field && field._f) {\n        setFieldValue(name, value);\n        options.shouldDirty && updateAndGetDirtyState(name);\n        options.shouldValidate && trigger(name as FieldName<TFieldValues>);\n      } else {\n        setInternalValues(name, value, options);\n\n        if (fieldArrayNamesRef.current.has(name)) {\n          fieldArraySubjectRef.current.next({\n            fields: value,\n            name,\n            isReset: true,\n          });\n\n          if (\n            (readFormStateRef.current.isDirty ||\n              readFormStateRef.current.dirtyFields) &&\n            options.shouldDirty\n          ) {\n            set(\n              formStateRef.current.dirtyFields,\n              name,\n              setFieldArrayDirtyFields(\n                value,\n                get(defaultValuesRef.current, name, []),\n                get(formStateRef.current.dirtyFields, name, []),\n              ),\n            );\n\n            formStateSubjectRef.current.next({\n              dirtyFields: formStateRef.current.dirtyFields,\n              isDirty: getFormIsDirty(name, value),\n            });\n          }\n        }\n      }\n    },\n    [updateAndGetDirtyState, setFieldValue, setInternalValues],\n  );\n\n  const isFieldWatched = <T extends FieldName<TFieldValues>>(name: T) =>\n    isWatchAllRef.current ||\n    watchFieldsRef.current.has(name) ||\n    watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const updateValueAndGetDefault = (name: InternalFieldName) => {\n    let defaultValue;\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const field = get(fieldsRef.current, name) as Field;\n\n    if (\n      field &&\n      (!isEmptyObject(defaultValuesRef.current) || !isUndefined(field._f.value))\n    ) {\n      defaultValue = isUndefined(field._f.value)\n        ? get(defaultValuesRef.current, name)\n        : field._f.value;\n\n      if (!isUndefined(defaultValue) && !isFieldArray) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    return defaultValue;\n  };\n\n  const setValue: UseFormSetValue<TFieldValues> = (name, value, options) => {\n    setInternalValue(name, value, options || {});\n    isFieldWatched(name) && formStateSubjectRef.current.next({});\n    watchSubjectRef.current.next({ name, value });\n  };\n\n  const handleChange: HandleChange = React.useCallback(\n    async ({ type, target, target: { value, type: inputType } }) => {\n      let name = (target as Ref)!.name;\n      let error;\n      let isValid;\n      const field = get(fieldsRef.current, name) as Field;\n\n      if (field) {\n        const inputValue = inputType ? getFieldValue(field) : value;\n        const isBlurEvent = type === EVENTS.BLUR;\n        const {\n          isOnBlur: isReValidateOnBlur,\n          isOnChange: isReValidateOnChange,\n        } = getValidationModes(reValidateMode);\n        const shouldSkipValidation = skipValidation({\n          isBlurEvent,\n          isTouched: !!get(formStateRef.current.touchedFields, name),\n          isSubmitted: formStateRef.current.isSubmitted,\n          isReValidateOnBlur,\n          isReValidateOnChange,\n          ...validationMode,\n        });\n        const isWatched =\n          !isBlurEvent && isFieldWatched(name as FieldName<TFieldValues>);\n\n        if (!isUndefined(inputValue)) {\n          field._f.value = inputValue;\n        }\n\n        const state = updateAndGetDirtyState(name, false);\n\n        if (\n          isBlurEvent &&\n          readFormStateRef.current.touchedFields &&\n          !get(formStateRef.current.touchedFields, name)\n        ) {\n          set(formStateRef.current.touchedFields, name, true);\n          state.touchedFields = formStateRef.current.touchedFields;\n        }\n\n        let shouldRender = !isEmptyObject(state) || isWatched;\n\n        if (shouldSkipValidation) {\n          !isBlurEvent &&\n            watchSubjectRef.current.next({\n              name,\n              type,\n              value: inputValue,\n            });\n          return (\n            shouldRender &&\n            formStateSubjectRef.current.next(isWatched ? {} : state)\n          );\n        }\n\n        formStateSubjectRef.current.next({\n          isValidating: true,\n        });\n\n        if (resolverRef.current) {\n          const { errors } = await resolverRef.current(\n            getFieldsValues(fieldsRef, defaultValuesRef, true),\n            contextRef.current,\n            {\n              criteriaMode,\n              fields: getFields([name], fieldsRef.current),\n              names: [name as FieldName<TFieldValues>],\n            },\n          );\n          const previousFormIsValid = formStateRef.current.isValid;\n          error = get(errors, name);\n\n          if (isCheckBoxInput(target as Ref) && !error) {\n            const parentNodeName = getNodeParentName(name);\n            const currentError = get(errors, parentNodeName, {});\n            currentError.type && currentError.message && (error = currentError);\n\n            if (\n              currentError ||\n              get(formStateRef.current.errors, parentNodeName)\n            ) {\n              name = parentNodeName;\n            }\n          }\n\n          isValid = isEmptyObject(errors);\n\n          previousFormIsValid !== isValid && (shouldRender = true);\n        } else {\n          error = (await validateField(field, isValidateAllFieldCriteria))[\n            name\n          ];\n        }\n\n        !isBlurEvent &&\n          watchSubjectRef.current.next({\n            name,\n            type,\n            value: inputValue,\n          });\n        shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n      }\n    },\n    [],\n  );\n\n  function getValues(): UnpackNestedValue<TFieldValues>;\n  function getValues<TName extends FieldPath<TFieldValues>>(\n    fieldName: TName,\n  ): FieldPathValue<TFieldValues, TName>;\n  function getValues<TName extends FieldPath<TFieldValues>[]>(\n    fieldNames: TName,\n  ): FieldPathValues<TFieldValues, TName>;\n  function getValues(\n    fieldNames?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[],\n  ) {\n    const values = isMountedRef.current\n      ? getFieldsValues(fieldsRef, defaultValuesRef)\n      : defaultValues;\n\n    if (isUndefined(fieldNames)) {\n      return values;\n    }\n\n    if (isString(fieldNames)) {\n      return get(values, fieldNames as InternalFieldName);\n    }\n\n    return fieldNames.map((name) => get(values, name as InternalFieldName));\n  }\n\n  const updateIsValid = React.useCallback(\n    async (values = {}) => {\n      if (resolver) {\n        const { errors } = await resolverRef.current!(\n          {\n            ...getFieldsValues(fieldsRef, defaultValuesRef, true),\n            ...values,\n          },\n          contextRef.current,\n          {\n            criteriaMode,\n            fields: getFields(fieldsNamesRef.current, fieldsRef.current),\n          },\n        );\n        const isValid = isEmptyObject(errors);\n\n        formStateRef.current.isValid !== isValid &&\n          formStateSubjectRef.current.next({\n            isValid,\n          });\n      } else {\n        getIsValid();\n      }\n    },\n    [criteriaMode],\n  );\n\n  const clearErrors: UseFormClearErrors<TFieldValues> = (name) => {\n    name &&\n      (Array.isArray(name) ? name : [name]).forEach((inputName) =>\n        unset(formStateRef.current.errors, inputName),\n      );\n\n    formStateSubjectRef.current.next({\n      errors: name ? formStateRef.current.errors : {},\n    });\n  };\n\n  const setError: UseFormSetError<TFieldValues> = (name, error, options) => {\n    const ref = ((get(fieldsRef.current, name) as Field) || { _f: {} })._f.ref;\n\n    set(formStateRef.current.errors, name, {\n      ...error,\n      ref,\n    });\n\n    formStateSubjectRef.current.next({\n      errors: formStateRef.current.errors,\n      isValid: false,\n    });\n\n    options && options.shouldFocus && ref && ref.focus && ref.focus();\n  };\n\n  const watchInternal: WatchInternal = React.useCallback(\n    (fieldNames, defaultValue, isGlobal) => {\n      const { fields, name } = fieldArrayUpdatedValuesRef.current;\n      const isArrayNames = Array.isArray(fieldNames);\n      let fieldValues = isMountedRef.current\n        ? getValues()\n        : isUndefined(defaultValue)\n        ? defaultValuesRef.current\n        : isArrayNames\n        ? defaultValue || {}\n        : { [fieldNames as string]: defaultValue };\n\n      if (fields) {\n        name ? set(fieldValues, name, fields) : (fieldValues = fields);\n\n        fieldArrayUpdatedValuesRef.current = {\n          fields: undefined,\n          name: undefined,\n        };\n      }\n\n      if (isUndefined(fieldNames)) {\n        isWatchAllRef.current = true;\n        return fieldValues;\n      }\n\n      const result = [];\n\n      for (const fieldName of isArrayNames ? fieldNames : [fieldNames]) {\n        isGlobal && watchFieldsRef.current.add(fieldName as string);\n        result.push(get(fieldValues, fieldName as string));\n      }\n\n      return isArrayNames ? result : result[0];\n    },\n    [],\n  );\n\n  function watch(): UnpackNestedValue<TFieldValues>;\n  function watch<TName extends FieldPath<TFieldValues>>(\n    fieldName: TName,\n    defaultValue?: FieldPathValue<TFieldValues, TName>,\n  ): FieldPathValue<TFieldValues, TName>;\n  function watch<TName extends FieldPath<TFieldValues>[]>(\n    fieldName: TName,\n    defaultValue?: FieldPathValues<TFieldValues, TName>,\n  ): FieldPathValues<TFieldValues, TName>;\n  function watch(\n    callback: WatchObserver,\n    defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ): Subscription;\n  function watch(\n    fieldName?:\n      | FieldPath<TFieldValues>\n      | FieldPath<TFieldValues>[]\n      | WatchObserver,\n    defaultValue?: unknown,\n  ) {\n    if (isFunction(fieldName)) {\n      return watchSubjectRef.current.subscribe({\n        next: (info) => fieldName(watchInternal(undefined, defaultValue), info),\n      });\n    }\n\n    return watchInternal(fieldName as string | string[], defaultValue, true);\n  }\n\n  const unregister: UseFormUnregister<TFieldValues> = (name, options = {}) => {\n    for (const inputName of name\n      ? Array.isArray(name)\n        ? name\n        : [name]\n      : Object.keys(fieldsNamesRef.current)) {\n      fieldsNamesRef.current.delete(inputName);\n\n      if (get(fieldsRef.current, inputName) as Field) {\n        if (!options.keepIsValid) {\n          unset(fieldsWithValidationRef.current, inputName);\n          unset(validFieldsRef.current, inputName);\n        }\n        !options.keepValues && unset(formStateRef.current.errors, inputName);\n        !options.keepErrors && unset(fieldsRef.current, inputName);\n        !options.keepDirty &&\n          unset(formStateRef.current.dirtyFields, inputName);\n        !options.keepTouched &&\n          unset(formStateRef.current.touchedFields, inputName);\n        !options.keepDefaultValues &&\n          unset(defaultValuesRef.current, inputName);\n\n        watchSubjectRef.current.next({\n          name: inputName,\n        });\n      }\n    }\n\n    formStateSubjectRef.current.next({\n      ...formStateRef.current,\n      ...(!options.keepDirty ? {} : { isDirty: getFormIsDirty() }),\n      ...(resolver ? {} : { isValid: getIsValid() }),\n    });\n\n    if (!options.keepIsValid) {\n      updateIsValid();\n    }\n  };\n\n  const registerFieldRef = (\n    name: InternalFieldName,\n    ref: HTMLInputElement,\n    options?: RegisterOptions,\n  ): ((name: InternalFieldName) => void) | void => {\n    let field = get(fieldsRef.current, name) as Field;\n\n    if (field) {\n      const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n\n      if (\n        (isRadioOrCheckbox\n          ? Array.isArray(field._f.refs) &&\n            compact(field._f.refs).find(\n              (option) => ref.value === option.value && option === ref,\n            )\n          : ref === field._f.ref) ||\n        !field\n      ) {\n        return;\n      }\n\n      field = {\n        _f: isRadioOrCheckbox\n          ? {\n              ...field._f,\n              refs: [\n                ...compact(field._f.refs || []).filter(\n                  (ref) => isHTMLElement(ref) && document.contains(ref),\n                ),\n                ref,\n              ],\n              ref: { type: ref.type, name },\n            }\n          : {\n              ...field._f,\n              ref,\n            },\n      };\n\n      set(fieldsRef.current, name, field);\n\n      const defaultValue = updateValueAndGetDefault(name);\n\n      if (\n        isRadioOrCheckbox && Array.isArray(defaultValue)\n          ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue)\n          : true\n      ) {\n        get(fieldsRef.current, name)._f.value = getFieldValue(\n          get(fieldsRef.current, name),\n        );\n      }\n\n      if (options) {\n        if (\n          !validationMode.isOnSubmit &&\n          field &&\n          readFormStateRef.current.isValid\n        ) {\n          validateField(field, isValidateAllFieldCriteria).then((error) => {\n            isEmptyObject(error)\n              ? set(validFieldsRef.current, name, true)\n              : unset(validFieldsRef.current, name);\n\n            formStateRef.current.isValid &&\n              !isEmptyObject(error) &&\n              setFormState({ ...formStateRef.current, isValid: getIsValid() });\n          });\n        }\n      }\n    }\n  };\n\n  const register: UseFormRegister<TFieldValues> = React.useCallback(\n    (name, options) => {\n      set(fieldsRef.current, name, {\n        _f: {\n          ...(get(fieldsRef.current, name)\n            ? {\n                ref: get(fieldsRef.current, name)._f.ref,\n                ...get(fieldsRef.current, name)._f,\n              }\n            : { ref: { name } }),\n          name,\n          ...options,\n        },\n      });\n      options && set(fieldsWithValidationRef.current, name, true);\n      fieldsNamesRef.current.add(name);\n\n      updateValueAndGetDefault(name);\n\n      return isWindowUndefined\n        ? ({} as RegisterCallback)\n        : {\n            name,\n            onChange: handleChange,\n            onBlur: handleChange,\n            ref: (ref: HTMLInputElement | null) =>\n              ref && registerFieldRef(name, ref, options),\n          };\n    },\n    [defaultValuesRef.current],\n  );\n\n  const handleSubmit: UseFormHandleSubmit<TFieldValues> = React.useCallback(\n    (onValid, onInvalid) => async (e) => {\n      if (e && e.preventDefault) {\n        e.preventDefault();\n        e.persist();\n      }\n      let fieldValues = getFieldsValues(fieldsRef, defaultValuesRef, true);\n\n      formStateSubjectRef.current.next({\n        isSubmitting: true,\n      });\n\n      try {\n        if (resolverRef.current) {\n          const { errors, values } = await resolverRef.current(\n            fieldValues,\n            contextRef.current,\n            {\n              criteriaMode,\n              fields: getFields(fieldsNamesRef.current, fieldsRef.current),\n            },\n          );\n          formStateRef.current.errors = errors;\n          fieldValues = values;\n        } else {\n          await validateForm(fieldsRef.current);\n        }\n\n        if (\n          isEmptyObject(formStateRef.current.errors) &&\n          Object.keys(formStateRef.current.errors).every((name) =>\n            get(fieldValues, name),\n          )\n        ) {\n          formStateSubjectRef.current.next({\n            errors: {},\n            isSubmitting: true,\n          });\n          await onValid(fieldValues, e);\n        } else {\n          onInvalid && (await onInvalid(formStateRef.current.errors, e));\n          shouldFocusError &&\n            focusFieldBy(\n              fieldsRef.current,\n              (key: string) => get(formStateRef.current.errors, key),\n              fieldsNamesRef.current,\n            );\n        }\n      } finally {\n        formStateRef.current.isSubmitting = false;\n        formStateSubjectRef.current.next({\n          isSubmitted: true,\n          isSubmitting: false,\n          isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n          submitCount: formStateRef.current.submitCount + 1,\n          errors: formStateRef.current.errors,\n        });\n      }\n    },\n    [shouldFocusError, isValidateAllFieldCriteria, criteriaMode],\n  );\n\n  const resetFromState = ({\n    keepErrors,\n    keepDirty,\n    keepIsSubmitted,\n    keepTouched,\n    keepIsValid,\n    keepSubmitCount,\n  }: KeepStateOptions) => {\n    if (!keepIsValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n\n    formStateSubjectRef.current.next({\n      submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\n      isDirty: keepDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: keepIsValid\n        ? formStateRef.current.isValid\n        : !validationMode.isOnSubmit,\n      dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\n      touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\n      errors: keepErrors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false,\n    });\n  };\n\n  const reset: UseFormReset<TFieldValues> = (values, keepStateOptions = {}) => {\n    const updatedValues = values || defaultValuesRef.current;\n\n    if (isWeb && !keepStateOptions.keepValues) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field && field._f) {\n          const { ref, refs } = field._f;\n          const inputRef = Array.isArray(refs) ? refs[0] : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form')!.reset();\n              break;\n            } catch {}\n          }\n        }\n      }\n    }\n\n    !keepStateOptions.keepDefaultValues &&\n      (defaultValuesRef.current = { ...updatedValues });\n\n    if (!keepStateOptions.keepValues) {\n      fieldsRef.current = {};\n\n      controllerSubjectRef.current.next({ ...updatedValues });\n\n      watchSubjectRef.current.next({\n        value: { ...updatedValues },\n      });\n\n      fieldArraySubjectRef.current.next({\n        fields: { ...updatedValues },\n        isReset: true,\n      });\n    }\n\n    resetFromState(keepStateOptions);\n  };\n\n  React.useEffect(() => {\n    resolver && readFormStateRef.current.isValid && updateIsValid();\n  }, [defaultValuesRef.current]);\n\n  React.useEffect(() => {\n    isMountedRef.current = true;\n    const formStateSubscription = formStateSubjectRef.current.subscribe({\n      next(formState: Partial<FormState<TFieldValues>> = {}) {\n        if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\n          formStateRef.current = {\n            ...formStateRef.current,\n            ...formState,\n          };\n          setFormState(formStateRef.current);\n        }\n      },\n    });\n\n    const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next(state) {\n        if (state.fields && state.name) {\n          fieldArrayUpdatedValuesRef.current = state;\n\n          if (readFormStateRef.current.isValid) {\n            const values = getValues();\n            set(values, state.name, state.fields);\n            updateIsValid(values);\n          }\n        }\n      },\n    });\n\n    return () => {\n      watchSubjectRef.current.unsubscribe();\n      formStateSubscription.unsubscribe();\n      useFieldArraySubscription.unsubscribe();\n    };\n  }, []);\n\n  return {\n    control: React.useMemo(\n      () => ({\n        register,\n        isWatchAllRef,\n        watchFieldsRef,\n        getFormIsDirty,\n        formStateSubjectRef,\n        fieldArraySubjectRef,\n        controllerSubjectRef,\n        watchSubjectRef,\n        watchInternal,\n        fieldsRef,\n        validFieldsRef,\n        fieldsWithValidationRef,\n        fieldArrayNamesRef,\n        readFormStateRef,\n        formStateRef,\n        defaultValuesRef,\n        fieldArrayDefaultValuesRef,\n      }),\n      [],\n    ),\n    formState: getProxyFormState<TFieldValues>(\n      isProxyEnabled,\n      formState,\n      readFormStateRef,\n    ),\n    trigger,\n    register,\n    handleSubmit,\n    watch: React.useCallback(watch, []),\n    setValue: React.useCallback(setValue, [setInternalValue, trigger]),\n    getValues: React.useCallback(getValues, []),\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    unregister: React.useCallback(unregister, []),\n    setError: React.useCallback(setError, []),\n  };\n}\n","import * as React from 'react';\nimport { UseFormMethods, FieldValues, FormProviderProps } from './types';\n\nconst FormContext = React.createContext<UseFormMethods | null>(null);\n\nFormContext.displayName = 'RHFContext';\n\nexport const useFormContext = <\n  TFieldValues extends FieldValues\n>(): UseFormMethods<TFieldValues> =>\n  (React.useContext(FormContext) as unknown) as UseFormMethods<TFieldValues>;\n\nexport const FormProvider = <TFieldValues extends FieldValues>({\n  children,\n  ...props\n}: FormProviderProps<TFieldValues>) => (\n  <FormContext.Provider value={(props as unknown) as UseFormMethods}>\n    {children}\n  </FormContext.Provider>\n);\n","import { UNDEFINED } from '../constants';\n\nexport default () => {\n  const d =\n    typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n","import { FieldValues } from '../types';\nimport generateId from './generateId';\n\nexport default <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id'\n>(\n  values: Partial<TFieldArrayValues>[] = [],\n  keyName: TKeyName,\n): any =>\n  values.map((value: Partial<TFieldArrayValues>) => ({\n    [keyName]: (value && value[keyName]) || generateId(),\n    ...value,\n  }));\n","import isUndefined from './isUndefined';\nimport compact from './compact';\n\nfunction removeAtIndexes<T>(data: T[], indexes: number[]): T[] {\n  let i = 0;\n  const temp = [...data];\n\n  for (const index of indexes) {\n    temp.splice(index - i, 1);\n    i++;\n  }\n\n  return compact(temp).length ? temp : [];\n}\n\nexport default <T>(data: T[], index?: number | number[]): T[] =>\n  isUndefined(index)\n    ? []\n    : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort());\n","import isUndefined from './isUndefined';\n\nexport default <T>(\n  data: (T | undefined)[],\n  from: number,\n  to: number,\n): (T | undefined)[] => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n","export default <T>(data: T[], indexA: number, indexB: number): void => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n","export default function prepend<T>(data: T[]): (T | undefined)[];\nexport default function prepend<T>(data: T[], value: T | T[]): T[];\nexport default function prepend<T>(\n  data: T[],\n  value?: T | T[],\n): (T | undefined)[] {\n  return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\n}\n","export default function insert<T>(data: T[], index: number): (T | undefined)[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value: T | T[],\n): T[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value?: T | T[],\n): (T | undefined)[] {\n  return [\n    ...data.slice(0, index),\n    ...(Array.isArray(value) ? value : [value]),\n    ...data.slice(index),\n  ];\n}\n","export default <T>(value: T | T[]): undefined[] | undefined =>\n  Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport getProxyFormState from './logic/getProxyFormState';\nimport shouldRenderFormState from './logic/shouldRenderFormState';\nimport isProxyEnabled from './utils/isProxyEnabled';\nimport cloneObject from './utils/cloneObject';\nimport {\n  FieldValues,\n  FormState,\n  UseFormStateMethods,\n  UseFormStateProps,\n} from './types';\n\nfunction useFormState<TFieldValues extends FieldValues = FieldValues>({\n  control,\n}: UseFormStateProps<TFieldValues> = {}): UseFormStateMethods<TFieldValues> {\n  const methods = useFormContext();\n  const { formStateRef, formStateSubjectRef, readFormStateRef } =\n    control || methods.control;\n\n  const [formState, updateFormState] = React.useState(formStateRef.current);\n  const readFormState = React.useRef(cloneObject(readFormStateRef.current));\n\n  React.useEffect(() => {\n    const formStateSubscription = formStateSubjectRef.current.subscribe({\n      next: (formState) => {\n        shouldRenderFormState(formState, readFormState.current) &&\n          updateFormState({\n            ...formStateRef.current,\n            ...formState,\n          });\n      },\n    });\n\n    return () => formStateSubscription.unsubscribe();\n  }, []);\n\n  return getProxyFormState<TFieldValues>(\n    isProxyEnabled,\n    formState as FormState<TFieldValues>,\n    readFormStateRef,\n    readFormState,\n    false,\n  );\n}\n\nexport { useFormState };\n","import isPrimitive from './isPrimitive';\nimport isHTMLElement from './isHTMLElement';\nimport isWeb from './isWeb';\n\nexport default function cloneObject<T extends unknown>(data: T): T {\n  let copy: any;\n\n  if (\n    isPrimitive(data) ||\n    (isWeb && (data instanceof File || isHTMLElement(data)))\n  ) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n    for (const item of data) {\n      copy.add(item);\n    }\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n    for (const key of data.keys()) {\n      copy.set(key, cloneObject(data.get(key)));\n    }\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (const key in data) {\n    copy[key] = cloneObject(data[key]);\n  }\n\n  return copy;\n}\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport { useFormState } from './useFormState';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport getControllerValue from './logic/getControllerValue';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport { EVENTS } from './constants';\nimport {\n  FieldValues,\n  UseControllerProps,\n  UseControllerMethods,\n  InternalFieldName,\n} from './types';\n\nexport function useController<TFieldValues extends FieldValues = FieldValues>({\n  name,\n  rules,\n  defaultValue,\n  control,\n}: UseControllerProps<TFieldValues>): UseControllerMethods<TFieldValues> {\n  const methods = useFormContext<TFieldValues>();\n  const {\n    defaultValuesRef,\n    register,\n    fieldsRef,\n    fieldArrayNamesRef,\n    controllerSubjectRef,\n  } = control || methods.control;\n\n  const { onChange, onBlur, ref } = register(name, rules);\n  const getInitialValue = () =>\n    (get(fieldsRef.current, name) &&\n      isUndefined(get(fieldsRef.current, name)._f.value)) ||\n    isNameInFieldArray(fieldArrayNamesRef.current, name)\n      ? isUndefined(defaultValue)\n        ? get(defaultValuesRef.current, name)\n        : defaultValue\n      : get(fieldsRef.current, name)._f.value;\n\n  const [value, setInputStateValue] = React.useState(getInitialValue());\n  const { errors, dirtyFields, touchedFields, isValidating } = useFormState({\n    control: control || methods.control,\n  });\n\n  React.useEffect(() => {\n    if (get(fieldsRef.current, name)) {\n      get(fieldsRef.current, name)._f.value = getInitialValue();\n    }\n\n    const controllerSubscription = controllerSubjectRef.current.subscribe({\n      next: (values) => setInputStateValue(get(values, name)),\n    });\n\n    return () => controllerSubscription.unsubscribe();\n  }, []);\n\n  return {\n    field: {\n      onChange: (event: any) => {\n        const value = getControllerValue(event);\n        setInputStateValue(value);\n\n        onChange({\n          target: {\n            value,\n            name: name as InternalFieldName,\n          },\n        });\n      },\n      onBlur: () => {\n        onBlur({\n          target: {\n            name: name as InternalFieldName,\n          },\n          type: EVENTS.BLUR,\n        });\n      },\n      name,\n      value,\n      ref,\n    },\n    meta: {\n      invalid: !!get(errors, name),\n      isDirty: !!get(dirtyFields, name),\n      isTouched: !!get(touchedFields, name),\n      error: get(errors, name),\n      isValidating,\n    },\n  };\n}\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isPrimitive from '../utils/isPrimitive';\n\nexport default (event: any) =>\n  isPrimitive(event) ||\n  !isObject(event.target) ||\n  (isObject(event.target) && !event.type)\n    ? event\n    : isUndefined(event.target.value)\n    ? event.target.checked\n    : event.target.value;\n","import { useController } from './useController';\nimport { ControllerProps, FieldValues } from './types';\n\nconst Controller = <TFieldValues extends FieldValues = FieldValues>(\n  props: ControllerProps<TFieldValues>,\n) => props.render(useController(props));\n\nexport { Controller };\n","// Todo: to be removed\nimport set from '../utils/set';\nimport isKey from '../utils/isKey';\nimport { FieldValues } from '../types';\n\nexport default (data: FieldValues, value: Record<string, any> = {}): any => {\n  for (const key in data) {\n    !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\n  }\n  return value;\n};\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport mapIds from './logic/mapId';\nimport getFieldArrayParentName from './logic/getNodeParentName';\nimport get from './utils/get';\nimport set from './utils/set';\nimport removeArrayAt from './utils/remove';\nimport unset from './utils/unset';\nimport moveArrayAt from './utils/move';\nimport swapArrayAt from './utils/swap';\nimport prependAt from './utils/prepend';\nimport insertAt from './utils/insert';\nimport fillEmptyArray from './utils/fillEmptyArray';\nimport compact from './utils/compact';\nimport isUndefined from './utils/isUndefined';\nimport focusFieldBy from './logic/focusFieldBy';\nimport getFieldsValues from './logic/getFieldsValues';\nimport {\n  FieldValues,\n  UseFieldArrayProps,\n  FieldPath,\n  FieldArrayWithId,\n  UseFieldArrayMethods,\n  FieldArray,\n  FieldArrayMethodsOption,\n  FieldErrors,\n  FieldNamesMarkedBoolean,\n} from './types';\n\nexport const useFieldArray = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TKeyName extends string = 'id'\n>({\n  control,\n  name,\n  keyName = 'id' as TKeyName,\n}: UseFieldArrayProps<TFieldValues, TName, TKeyName>): UseFieldArrayMethods<\n  TFieldValues,\n  TName,\n  TKeyName\n> => {\n  const methods = useFormContext();\n  const focusNameRef = React.useRef('');\n  const {\n    isWatchAllRef,\n    watchFieldsRef,\n    getFormIsDirty,\n    watchSubjectRef,\n    fieldArraySubjectRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    formStateRef,\n    formStateSubjectRef,\n    readFormStateRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n  } = control || methods.control;\n\n  const [fields, setFields] = React.useState<\n    Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[]\n  >(\n    mapIds(\n      get(fieldArrayDefaultValuesRef.current, getFieldArrayParentName(name))\n        ? get(fieldArrayDefaultValuesRef.current, name, [])\n        : get(defaultValuesRef.current, name, []),\n      keyName,\n    ),\n  );\n\n  set(fieldArrayDefaultValuesRef.current, name, [...fields]);\n  fieldArrayNamesRef.current.add(name);\n\n  const omitKey = <\n    T extends Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[]\n  >(\n    fields: T,\n  ) => fields.map(({ [keyName]: omitted, ...rest } = {}) => rest);\n\n  const getCurrentFieldsValues = () => {\n    const values = get(getFieldsValues(fieldsRef, defaultValuesRef), name, []);\n\n    return mapIds<TFieldValues, TKeyName>(\n      get(fieldArrayDefaultValuesRef.current, name, []).map(\n        (item: Partial<TFieldValues>, index: number) => ({\n          ...item,\n          ...values[index],\n        }),\n      ),\n      keyName,\n    );\n  };\n\n  const getFocusDetail = (\n    index: number,\n    options?: FieldArrayMethodsOption,\n  ): string => {\n    if (options) {\n      if (!isUndefined(options.focusIndex)) {\n        return `${name}.${options.focusIndex}`;\n      }\n      if (options.focusName) {\n        return options.focusName;\n      }\n      if (!options.shouldFocus) {\n        return '';\n      }\n    }\n    return `${name}.${index}`;\n  };\n\n  const resetFields = <T>(index?: T) =>\n    (Array.isArray(index) ? index : [index]).forEach((currentIndex) =>\n      set(\n        fieldsRef.current,\n        `${name}${currentIndex ? `.${currentIndex}` : ''}`,\n        [],\n      ),\n    );\n\n  const setFieldsAndNotify = (\n    fieldsValues: Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[],\n  ) => {\n    setFields(mapIds(fieldsValues, keyName));\n    fieldArraySubjectRef.current.next({\n      name,\n      fields: omitKey([...fieldsValues]),\n    });\n  };\n\n  const cleanup = <T>(ref: T) =>\n    !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const updateDirtyFieldsWithDefaultValues = <\n    T extends Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[]\n  >(\n    updatedFieldArrayValues?: T,\n  ) =>\n    updatedFieldArrayValues &&\n    set(\n      formStateRef.current.dirtyFields,\n      name,\n      setFieldArrayDirtyFields(\n        omitKey(updatedFieldArrayValues),\n        get(defaultValuesRef.current, name, []),\n        get(formStateRef.current.dirtyFields, name, []),\n      ),\n    );\n\n  const batchStateUpdate = <\n    T extends Function,\n    K extends Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[]\n  >(\n    method: T,\n    args: {\n      argA?: unknown;\n      argB?: unknown;\n    },\n    updatedFieldValues?: K,\n    updatedFormValues: Partial<\n      FieldArrayWithId<TFieldValues, TName, TKeyName>\n    >[] = [],\n    shouldSet = true,\n    shouldUpdateValid = false,\n  ) => {\n    if (get(fieldsRef.current, name)) {\n      const output = method(get(fieldsRef.current, name), args.argA, args.argB);\n      shouldSet && set(fieldsRef.current, name, output);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(\n        get(formStateRef.current.errors, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (\n      readFormStateRef.current.touchedFields &&\n      get(formStateRef.current.touchedFields, name)\n    ) {\n      const output = method(\n        get(formStateRef.current.touchedFields, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.touchedFields, name, output);\n      cleanup(formStateRef.current.touchedFields);\n    }\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      set(\n        formStateRef.current.dirtyFields,\n        name,\n        setFieldArrayDirtyFields(\n          omitKey(updatedFormValues),\n          get(defaultValuesRef.current, name, []),\n          get(formStateRef.current.dirtyFields, name, []),\n        ),\n      );\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (shouldUpdateValid && readFormStateRef.current.isValid) {\n      set(\n        validFieldsRef.current,\n        name,\n        method(get(validFieldsRef.current, name, []), args.argA),\n      );\n      cleanup(validFieldsRef.current);\n\n      set(\n        fieldsWithValidationRef.current,\n        name,\n        method(get(fieldsWithValidationRef.current, name, []), args.argA),\n      );\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    formStateSubjectRef.current.next({\n      isDirty: getFormIsDirty(name, omitKey(updatedFormValues)),\n      errors: formStateRef.current.errors as FieldErrors<TFieldValues>,\n      isValid: formStateRef.current.isValid,\n    });\n  };\n\n  const append = (\n    value:\n      | Partial<FieldArray<TFieldValues, TName>>\n      | Partial<FieldArray<TFieldValues, TName>>[],\n    options?: FieldArrayMethodsOption,\n  ) => {\n    const appendValue = Array.isArray(value) ? value : [value];\n    const updatedFieldValues = [...getCurrentFieldsValues(), ...appendValue];\n    setFieldsAndNotify(updatedFieldValues);\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n\n      formStateSubjectRef.current.next({\n        isDirty: true,\n        dirtyFields: formStateRef.current\n          .dirtyFields as FieldNamesMarkedBoolean<TFieldValues>,\n      });\n    }\n\n    focusNameRef.current = getFocusDetail(\n      updatedFieldValues.length - 1,\n      options,\n    );\n  };\n\n  const prepend = (\n    value:\n      | Partial<FieldArray<TFieldValues, TName>>\n      | Partial<FieldArray<TFieldValues, TName>>[],\n    options?: FieldArrayMethodsOption,\n  ) => {\n    const updatedFieldArrayValues = prependAt(\n      getCurrentFieldsValues(),\n      Array.isArray(value) ? value : [value],\n    );\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(\n      prependAt,\n      {\n        argA: fillEmptyArray(value),\n      },\n      updatedFieldArrayValues,\n    );\n\n    focusNameRef.current = getFocusDetail(0, options);\n  };\n\n  const remove = (index?: number | number[]) => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldValues: Partial<\n      FieldArrayWithId<TFieldValues, TName, TKeyName>\n    >[] = removeArrayAt(fieldValues, index);\n    resetFields(index);\n    batchStateUpdate(\n      removeArrayAt,\n      {\n        argA: index,\n      },\n      updatedFieldValues,\n      removeArrayAt(fieldValues, index),\n      true,\n      true,\n    );\n    setFieldsAndNotify(updatedFieldValues);\n  };\n\n  const insert = (\n    index: number,\n    value:\n      | Partial<FieldArray<TFieldValues, TName>>\n      | Partial<FieldArray<TFieldValues, TName>>[],\n    options?: FieldArrayMethodsOption,\n  ) => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldArrayValues = insertAt(\n      fieldValues,\n      index,\n      Array.isArray(value) ? value : [value],\n    );\n\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(\n      insertAt,\n      {\n        argA: index,\n        argB: fillEmptyArray(value),\n      },\n      updatedFieldArrayValues,\n      fieldValues && insertAt(fieldValues, index),\n    );\n\n    focusNameRef.current = getFocusDetail(index, options);\n  };\n\n  const swap = (indexA: number, indexB: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    batchStateUpdate(\n      swapArrayAt,\n      {\n        argA: indexA,\n        argB: indexB,\n      },\n      undefined,\n      fieldValues,\n      false,\n    );\n    setFieldsAndNotify(fieldValues);\n  };\n\n  const move = (from: number, to: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    setFieldsAndNotify(fieldValues);\n    batchStateUpdate(\n      moveArrayAt,\n      {\n        argA: from,\n        argB: to,\n      },\n      undefined,\n      fieldValues,\n      false,\n    );\n  };\n\n  React.useEffect(() => {\n    if (isWatchAllRef.current) {\n      formStateSubjectRef.current.next({});\n    } else {\n      for (const watchField of watchFieldsRef.current) {\n        if (name.startsWith(watchField)) {\n          formStateSubjectRef.current.next({});\n          break;\n        }\n      }\n    }\n\n    watchSubjectRef.current.next({ name });\n\n    focusNameRef.current &&\n      focusFieldBy(fieldsRef.current, (key: string) =>\n        key.startsWith(focusNameRef.current),\n      );\n\n    focusNameRef.current = '';\n  }, [fields, name]);\n\n  React.useEffect(() => {\n    const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next({ name: inputName, fields, isReset }) {\n        if (isReset) {\n          if (inputName) {\n            const value = getFieldsValues(fieldsRef, defaultValuesRef);\n            set(value, inputName, fields);\n            set(fieldArrayDefaultValuesRef.current, name, fields);\n            setFieldsAndNotify(get(value, name));\n          } else {\n            fieldArrayDefaultValuesRef.current = fields;\n            setFieldsAndNotify(get(fields, name));\n          }\n        }\n      },\n    });\n\n    return () => {\n      fieldArraySubscription.unsubscribe();\n      unset(fieldArrayDefaultValuesRef.current, name);\n      fieldArrayNamesRef.current.delete(name);\n    };\n  }, []);\n\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend, [name]),\n    append: React.useCallback(append, [name]),\n    remove: React.useCallback(remove, [name]),\n    insert: React.useCallback(insert, [name]),\n    fields: fields as FieldArrayWithId<TFieldValues, TName, TKeyName>,\n  };\n};\n","import get from '../utils/get';\nimport isUndefined from '../utils/isUndefined';\nimport deepEqual from '../utils/deepEqual';\nimport {\n  FieldValues,\n  InternalFieldName,\n  FieldErrors,\n  FieldNamesMarkedBoolean,\n  FieldError,\n} from '../types';\n\nexport default <TFieldValues extends FieldValues>({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation,\n}: {\n  errors: FieldErrors<TFieldValues>;\n  error: FieldError | undefined;\n  name: InternalFieldName;\n  validFields: FieldNamesMarkedBoolean<TFieldValues>;\n  fieldsWithValidation: FieldNamesMarkedBoolean<TFieldValues>;\n}): boolean => {\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n\n  return (\n    (isValid && !!previousError) ||\n    (!isValid && !deepEqual(previousError, error, true)) ||\n    (isValid && get(fieldsWithValidation, name) && !get(validFields, name))\n  );\n};\n","export default ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll,\n}: {\n  isOnAll?: boolean;\n  isOnBlur?: boolean;\n  isOnChange?: boolean;\n  isReValidateOnBlur?: boolean;\n  isReValidateOnChange?: boolean;\n  isBlurEvent?: boolean;\n  isSubmitted?: boolean;\n  isOnTouch?: boolean;\n  isTouched?: boolean;\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n  return true;\n};\n","import isRadioInput from './isRadioInput';\nimport isCheckBoxInput from './isCheckBoxInput';\nimport { FieldElement } from '../types';\n\nexport default (ref: FieldElement): ref is HTMLInputElement =>\n  isRadioInput(ref) || isCheckBoxInput(ref);\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport isUndefined from './utils/isUndefined';\nimport isString from './utils/isString';\nimport get from './utils/get';\nimport isObject from './utils/isObject';\nimport {\n  DeepPartial,\n  UseWatchProps,\n  FieldValues,\n  UnpackNestedValue,\n  Control,\n  FieldPath,\n  InternalFieldName,\n  FieldPathValue,\n  FieldPathValues,\n} from './types';\n\nexport function useWatch<\n  TFieldValues extends FieldValues = FieldValues\n>(props: {\n  defaultValue?: UnpackNestedValue<DeepPartial<TFieldValues>>;\n  control?: Control<TFieldValues>;\n}): UnpackNestedValue<DeepPartial<TFieldValues>>;\nexport function useWatch<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>(props: {\n  name: TName;\n  defaultValue?: FieldPathValue<TFieldValues, TName>;\n  control?: Control<TFieldValues>;\n}): FieldPathValue<TFieldValues, TName>;\nexport function useWatch<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues>[] = FieldPath<TFieldValues>[]\n>(props: {\n  name: TName;\n  defaultValue?: UnpackNestedValue<DeepPartial<TFieldValues>>;\n  control?: Control<TFieldValues>;\n}): FieldPathValues<TFieldValues, TName>;\nexport function useWatch<TFieldValues>({\n  control,\n  name,\n  defaultValue,\n}: UseWatchProps<TFieldValues>) {\n  const methods = useFormContext();\n\n  const { watchInternal, defaultValuesRef, watchSubjectRef } =\n    control || methods.control;\n  const [value, updateValue] = React.useState<unknown>(\n    isUndefined(defaultValue)\n      ? Array.isArray(name)\n        ? name.reduce(\n            (previous, inputName) => ({\n              ...previous,\n              [inputName]: get(defaultValuesRef.current, inputName as string),\n            }),\n            {},\n          )\n        : isString(name)\n        ? get(defaultValuesRef.current, name)\n        : defaultValuesRef.current\n      : defaultValue,\n  );\n\n  React.useEffect(() => {\n    const watchSubscription = watchSubjectRef.current.subscribe({\n      next: ({ name: inputName, value }) => {\n        updateValue(\n          isString(inputName) && name === inputName && !isUndefined(value)\n            ? value\n            : name && isObject(value)\n            ? get(value, name as InternalFieldName, defaultValue)\n            : watchInternal(name as string, defaultValue),\n        );\n      },\n    });\n\n    return () => watchSubscription.unsubscribe();\n  }, [name]);\n\n  return value;\n}\n"],"names":["val","undefined","value","isObjectType","isNullOrUndefined","Array","isArray","Date","filter","Boolean","obj","path","defaultValue","result","compact","split","reduce","key","isUndefined","test","input","replace","set","object","index","tempPath","isKey","stringToPath","length","lastIndex","newValue","objValue","isObject","isNaN","focusFieldBy","fields","callback","fieldsNames","Object","keys","field","get","_f","current","name","ref","focus","refs","deepEqual","object1","object2","isErrorObject","isPrimitive","React.isValidElement","keys1","keys2","val1","val2","setDirtyFields","values","defaultValues","dirtyFields","parentNode","parentName","[object Object]","deepMerge","target","source","targetValue","sourceValue","slice","EVENTS","VALIDATION_MODE","UNDEFINED","INPUT_VALIDATION_RULES","formState","readFormStateRef","isRoot","isEmptyObject","find","valueAsNumber","valueAsDate","setValueAs","shouldReturnAsValue","NaN","getFieldsValues","fieldsRef","defaultValuesRef","output","disabled","getFieldValueAs","defaultReturn","isValid","options","previous","option","checked","element","type","defaultResult","validResult","map","attributes","getFieldValue","isFileInput","files","isRadioInput","getRadioValue","isMultipleSelect","selected","isCheckBox","getCheckboxValue","RegExp","validationData","isRegex","message","isString","getValidateError","isMessage","isBoolean","validateAllFieldCriteria","errors","types","async","required","maxLength","minLength","min","max","pattern","validate","inputValue","error","isRadio","isCheckBoxInput","isRadioOrCheckbox","isEmpty","appendErrorsCurry","appendErrors","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","getValueAndMessage","exceedMin","maxOutput","minOutput","valueDate","valueNumber","parseFloat","maxLengthOutput","minLengthOutput","patternValue","validateRef","isFunction","validateError","validationResult","validateFunction","entries","substring","search","names","some","getNodeParentName","isProxyEnabled","localReadFormStateRef","Proxy","prop","Subscription","this","tearDown","tearDowns","push","teardown","Subscriber","observer","subscription","add","closed","next","Subject","observers","subscriber","window","document","isWeb","getPath","rootPath","paths","property","unset","updatePath","childObject","baseGet","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","data","mode","isOnSubmit","isOnBlur","isOnChange","isOnAll","isOnTouch","HTMLElement","getFields","fieldsRefs","currentFields","isWindowUndefined","FormContext","React.createContext","displayName","useFormContext","React.useContext","d","performance","now","c","r","Math","random","toString","keyName","generateId","indexes","i","temp","splice","removeAtIndexes","sort","from","to","indexA","indexB","prepend","insert","fill","useFormState","control","methods","formStateRef","formStateSubjectRef","updateFormState","React.useState","readFormState","React.useRef","cloneObject","copy","File","isHTMLElement","getTime","Set","Map","React.useEffect","formStateSubscription","subscribe","shouldRenderFormState","unsubscribe","getProxyFormState","useController","rules","register","fieldArrayNamesRef","controllerSubjectRef","onChange","onBlur","getInitialValue","isNameInFieldArray","setInputStateValue","touchedFields","isValidating","controllerSubscription","event","getControllerValue","meta","invalid","isDirty","isTouched","props","render","_a","children","React.createElement","Provider","focusNameRef","isWatchAllRef","watchFieldsRef","getFormIsDirty","watchSubjectRef","fieldArraySubjectRef","validFieldsRef","fieldsWithValidationRef","fieldArrayDefaultValuesRef","setFields","mapIds","getFieldArrayParentName","omitKey","_b","getCurrentFieldsValues","getFocusDetail","focusIndex","focusName","shouldFocus","setFieldsAndNotify","fieldsValues","cleanup","updateDirtyFieldsWithDefaultValues","updatedFieldArrayValues","setFieldArrayDirtyFields","batchStateUpdate","method","args","updatedFieldValues","updatedFormValues","shouldSet","shouldUpdateValid","argA","argB","watchField","startsWith","fieldArraySubscription","inputName","isReset","delete","swap","React.useCallback","fieldValues","swapArrayAt","move","moveArrayAt","prependAt","fillEmptyArray","append","appendValue","remove","removeArrayAt","forEach","currentIndex","resetFields","insertAt","reValidateMode","resolver","context","shouldFocusError","criteriaMode","fieldsNamesRef","fieldArrayUpdatedValuesRef","isMountedRef","contextRef","resolverRef","validationMode","getValidationModes","isValidateAllFieldCriteria","setFormState","isSubmitted","submitCount","isSubmitting","isSubmitSuccessful","getIsValid","shouldRenderBaseOnError","shouldRender","state","shouldReRender","validFields","fieldsWithValidation","previousError","isErrorStateChanged","setFieldValue","rawValue","radioRef","selectRef","includes","checkboxRef","formValues","getValues","updateAndGetDirtyState","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","validateField","executeSchemaOrResolverValidation","currentNames","validateForm","fieldError","trigger","Promise","all","setInternalValues","shouldDirty","shouldValidate","fieldName","setInternalValue","has","isFieldWatched","match","updateValueAndGetDefault","isFieldArray","handleChange","inputType","isBlurEvent","isReValidateOnBlur","isReValidateOnChange","shouldSkipValidation","skipValidation","isWatched","previousFormIsValid","parentNodeName","currentError","fieldNames","updateIsValid","watchInternal","isGlobal","isArrayNames","registerFieldRef","isRadioOrCheckboxFunction","contains","then","handleSubmit","onValid","onInvalid","e","preventDefault","persist","every","useFieldArraySubscription","React.useMemo","watch","info","setValue","reset","keepStateOptions","updatedValues","keepValues","inputRef","closest","keepDefaultValues","keepErrors","keepDirty","keepIsSubmitted","keepTouched","keepIsValid","keepSubmitCount","resetFromState","clearErrors","unregister","setError","updateValue","watchSubscription"],"mappings":"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"}