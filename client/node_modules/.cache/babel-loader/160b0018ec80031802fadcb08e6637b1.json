{"ast":null,"code":"import _classCallCheck from \"/Users/yoong.thuydung/playground/lqyk7/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/yoong.thuydung/playground/lqyk7/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _regeneratorRuntime from \"/Users/yoong.thuydung/playground/lqyk7/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/yoong.thuydung/playground/lqyk7/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/Users/yoong.thuydung/playground/lqyk7/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"/Users/yoong.thuydung/playground/lqyk7/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"/Users/yoong.thuydung/playground/lqyk7/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _createForOfIteratorHelper from \"/Users/yoong.thuydung/playground/lqyk7/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { isValidElement, useRef, useState, useCallback, useEffect, useMemo, createContext, useContext, createElement } from 'react';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nvar isUndefined = function isUndefined(val) {\n  return val === undefined;\n};\n\nvar isNullOrUndefined = function isNullOrUndefined(value) {\n  return value == null;\n};\n\nvar isObjectType = function isObjectType(value) {\n  return typeof value === 'object';\n};\n\nvar isObject = function isObject(value) {\n  return !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !(value instanceof Date);\n};\n\nvar compact = function compact(value) {\n  return value.filter(Boolean);\n};\n\nvar get = function get() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var path = arguments.length > 1 ? arguments[1] : undefined;\n  var defaultValue = arguments.length > 2 ? arguments[2] : undefined;\n  var result = compact(path.split(/[,[\\].]+?/)).reduce(function (result, key) {\n    return isNullOrUndefined(result) ? result : result[key];\n  }, obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\n\nvar isKey = function isKey(value) {\n  return /^\\w*$/.test(value);\n};\n\nvar stringToPath = function stringToPath(input) {\n  return compact(input.replace(/[\"|']/g, '').replace(/\\[/g, '.').replace(/\\]/g, '').split('.'));\n};\n\nfunction set(object, path, value) {\n  var index = -1;\n  var tempPath = isKey(path) ? [path] : stringToPath(path);\n  var length = tempPath.length;\n  var lastIndex = length - 1;\n\n  while (++index < length) {\n    var key = tempPath[index];\n    var newValue = value;\n\n    if (index !== lastIndex) {\n      var objValue = object[key];\n      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar focusFieldBy = function focusFieldBy(fields, callback, fieldsNames) {\n  var _iterator = _createForOfIteratorHelper(fieldsNames || Object.keys(fields)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      var field = get(fields, key);\n\n      if (field) {\n        var _f = field._f,\n            current = __rest(field, [\"_f\"]);\n\n        if (_f && callback(_f.name)) {\n          if (_f.ref.focus && isUndefined(_f.ref.focus())) {\n            break;\n          } else if (_f.refs) {\n            _f.refs[0].focus();\n\n            break;\n          }\n        } else if (isObject(current)) {\n          focusFieldBy(current, callback);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\n\nvar isPrimitive = function isPrimitive(value) {\n  return isNullOrUndefined(value) || !isObjectType(value);\n};\n\nfunction deepMerge(target, source) {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (var key in source) {\n    var targetValue = target[key];\n    var sourceValue = source[key];\n\n    try {\n      target[key] = isObject(targetValue) && isObject(sourceValue) || Array.isArray(targetValue) && Array.isArray(sourceValue) ? deepMerge(targetValue, sourceValue) : sourceValue;\n    } catch (_a) {}\n  }\n\n  return target;\n}\n\nfunction deepEqual(object1, object2, isErrorObject) {\n  if (isPrimitive(object1) || isPrimitive(object2) || object1 instanceof Date || object2 instanceof Date) {\n    return object1 === object2;\n  }\n\n  if (!isValidElement(object1)) {\n    var keys1 = Object.keys(object1);\n    var keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (var _i = 0, _keys = keys1; _i < _keys.length; _i++) {\n      var key = _keys[_i];\n      var val1 = object1[key];\n\n      if (!(isErrorObject && key === 'ref')) {\n        var val2 = object2[key];\n\n        if ((isObject(val1) || Array.isArray(val1)) && (isObject(val2) || Array.isArray(val2)) ? !deepEqual(val1, val2, isErrorObject) : val1 !== val2) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\n  var index = -1;\n\n  while (++index < values.length) {\n    for (var key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\n      } else {\n        deepEqual(get(defaultValues[index] || {}, key), values[index][key]) ? set(dirtyFields[index] || {}, key) : dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), _defineProperty({}, key, true));\n      }\n    }\n\n    parentNode && !dirtyFields.length && delete parentNode[parentName];\n  }\n\n  return dirtyFields;\n}\n\nvar setFieldArrayDirtyFields = function setFieldArrayDirtyFields(values, defaultValues, dirtyFields) {\n  return deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n};\n\nvar isEmptyObject = function isEmptyObject(value) {\n  return isObject(value) && !Object.keys(value).length;\n};\n\nvar EVENTS = {\n  BLUR: 'blur'\n};\nvar VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all'\n};\nvar SELECT = 'select';\nvar UNDEFINED = 'undefined';\nvar INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nvar shouldRenderFormState = function shouldRenderFormState(formState, readFormStateRef, isRoot) {\n  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(readFormStateRef).length || Object.keys(formState).find(function (key) {\n    return readFormStateRef[key] === (isRoot ? VALIDATION_MODE.all : true);\n  });\n};\n\nvar getFieldValueAs = function getFieldValueAs(value, _ref, shouldReturnAsValue) {\n  var valueAsNumber = _ref.valueAsNumber,\n      valueAsDate = _ref.valueAsDate,\n      setValueAs = _ref.setValueAs;\n  return shouldReturnAsValue ? valueAsNumber ? value === '' ? NaN : +value : valueAsDate ? new Date(value) : setValueAs ? setValueAs(value) : value : value;\n};\n\nvar getFieldsValues = function getFieldsValues(fieldsRef, defaultValuesRef, shouldReturnAsValue) {\n  var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  for (var name in fieldsRef.current) {\n    var field = fieldsRef.current[name];\n\n    if (field) {\n      var _f = field._f,\n          current = __rest(field, [\"_f\"]);\n\n      set(output, name, _f && !_f.ref.disabled ? getFieldValueAs(_f.value, _f, shouldReturnAsValue) : Array.isArray(field) ? [] : {});\n\n      if (current) {\n        getFieldsValues({\n          current: current\n        }, defaultValuesRef, shouldReturnAsValue, output[name]);\n      }\n    }\n  }\n\n  return Object.assign(Object.assign({}, defaultValuesRef.current), output);\n};\n\nvar defaultReturn = {\n  isValid: false,\n  value: null\n};\n\nvar getRadioValue = function getRadioValue(options) {\n  return Array.isArray(options) ? options.reduce(function (previous, option) {\n    return option && option.checked ? {\n      isValid: true,\n      value: option.value\n    } : previous;\n  }, defaultReturn) : defaultReturn;\n};\n\nvar getMultipleSelectValue = function getMultipleSelectValue(options) {\n  return _toConsumableArray(options).filter(function (_ref2) {\n    var selected = _ref2.selected;\n    return selected;\n  }).map(function (_ref3) {\n    var value = _ref3.value;\n    return value;\n  });\n};\n\nvar isRadioInput = function isRadioInput(element) {\n  return element.type === 'radio';\n};\n\nvar isFileInput = function isFileInput(element) {\n  return element.type === 'file';\n};\n\nvar isCheckBoxInput = function isCheckBoxInput(element) {\n  return element.type === 'checkbox';\n};\n\nvar isMultipleSelect = function isMultipleSelect(element) {\n  return element.type === \"\".concat(SELECT, \"-multiple\");\n};\n\nvar defaultResult = {\n  value: false,\n  isValid: false\n};\nvar validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = function getCheckboxValue(options) {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      var values = options.filter(function (option) {\n        return option && option.checked;\n      }).map(function (_ref4) {\n        var value = _ref4.value;\n        return value;\n      });\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    var _options$ = options[0],\n        checked = _options$.checked,\n        value = _options$.value,\n        attributes = _options$.attributes;\n    return checked ? // @ts-expect-error\n    attributes && !isUndefined(attributes.value) ? isUndefined(value) ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(field, shouldReturnAsValue) {\n  if (field && field._f) {\n    var ref = field._f.ref;\n\n    if (ref.disabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field._f.refs).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return getCheckboxValue(field._f.refs).value;\n    }\n\n    return getFieldValueAs(ref.value, field._f, shouldReturnAsValue);\n  }\n}\n\nvar isErrorStateChanged = function isErrorStateChanged(_ref5) {\n  var errors = _ref5.errors,\n      name = _ref5.name,\n      error = _ref5.error,\n      validFields = _ref5.validFields,\n      fieldsWithValidation = _ref5.fieldsWithValidation;\n  var isValid = isUndefined(error);\n  var previousError = get(errors, name);\n  return isValid && !!previousError || !isValid && !deepEqual(previousError, error, true) || isValid && get(fieldsWithValidation, name) && !get(validFields, name);\n};\n\nvar isRegex = function isRegex(value) {\n  return value instanceof RegExp;\n};\n\nvar getValueAndMessage = function getValueAndMessage(validationData) {\n  return isObject(validationData) && !isRegex(validationData) ? validationData : {\n    value: validationData,\n    message: ''\n  };\n};\n\nvar isString = function isString(value) {\n  return typeof value === 'string';\n};\n\nvar isFunction = function isFunction(value) {\n  return typeof value === 'function';\n};\n\nvar isBoolean = function isBoolean(value) {\n  return typeof value === 'boolean';\n};\n\nvar isMessage = function isMessage(value) {\n  return isString(value) || isValidElement(value);\n};\n\nfunction getValidateError(result, ref) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'validate';\n\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type: type,\n      message: isMessage(result) ? result : '',\n      ref: ref\n    };\n  }\n}\n\nvar appendErrors = function appendErrors(name, validateAllFieldCriteria, errors, type, message) {\n  return validateAllFieldCriteria ? Object.assign(Object.assign({}, errors[name]), {\n    types: Object.assign(Object.assign({}, errors[name] && errors[name].types ? errors[name].types : {}), _defineProperty({}, type, message || true))\n  }) : {};\n};\n\nvar validateField = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref6, validateAllFieldCriteria) {\n    var _ref6$_f, ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, inputValue, error, isRadio, isCheckBox, isRadioOrCheckbox, isEmpty, appendErrorsCurry, getMinMaxMessage, _ref8, value, message, exceedMax, exceedMin, maxOutput, minOutput, valueNumber, valueDate, maxLengthOutput, minLengthOutput, _exceedMax, _exceedMin, _getValueAndMessage, patternValue, _message, validateRef, result, validateError, validationResult, _i2, _Object$entries, _Object$entries$_i, key, validateFunction, validateResult, _validateError;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref6$_f = _ref6._f, ref = _ref6$_f.ref, refs = _ref6$_f.refs, required = _ref6$_f.required, maxLength = _ref6$_f.maxLength, minLength = _ref6$_f.minLength, min = _ref6$_f.min, max = _ref6$_f.max, pattern = _ref6$_f.pattern, validate = _ref6$_f.validate, name = _ref6$_f.name, inputValue = _ref6$_f.value;\n            error = {};\n            isRadio = isRadioInput(ref);\n            isCheckBox = isCheckBoxInput(ref);\n            isRadioOrCheckbox = isRadio || isCheckBox;\n            isEmpty = !inputValue || Array.isArray(inputValue) && !inputValue.length;\n            appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n            getMinMaxMessage = function getMinMaxMessage(exceedMax, maxLengthMessage, minLengthMessage) {\n              var maxType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INPUT_VALIDATION_RULES.maxLength;\n              var minType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : INPUT_VALIDATION_RULES.minLength;\n              var message = exceedMax ? maxLengthMessage : minLengthMessage;\n              error[name] = Object.assign({\n                type: exceedMax ? maxType : minType,\n                message: message,\n                ref: ref\n              }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n            };\n\n            if (!(required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid))) {\n              _context.next = 14;\n              break;\n            }\n\n            _ref8 = isMessage(required) ? {\n              value: !!required,\n              message: required\n            } : getValueAndMessage(required), value = _ref8.value, message = _ref8.message;\n\n            if (!value) {\n              _context.next = 14;\n              break;\n            }\n\n            error[name] = Object.assign({\n              type: INPUT_VALIDATION_RULES.required,\n              message: message,\n              ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref\n            }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\n\n            if (validateAllFieldCriteria) {\n              _context.next = 14;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 14:\n            if (!((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && inputValue !== '')) {\n              _context.next = 22;\n              break;\n            }\n\n            maxOutput = getValueAndMessage(max);\n            minOutput = getValueAndMessage(min);\n\n            if (!isNaN(inputValue)) {\n              valueNumber = ref.valueAsNumber || parseFloat(inputValue);\n\n              if (!isNullOrUndefined(maxOutput.value)) {\n                exceedMax = valueNumber > maxOutput.value;\n              }\n\n              if (!isNullOrUndefined(minOutput.value)) {\n                exceedMin = valueNumber < minOutput.value;\n              }\n            } else {\n              valueDate = ref.valueAsDate || new Date(inputValue);\n\n              if (isString(maxOutput.value)) {\n                exceedMax = valueDate > new Date(maxOutput.value);\n              }\n\n              if (isString(minOutput.value)) {\n                exceedMin = valueDate < new Date(minOutput.value);\n              }\n            }\n\n            if (!(exceedMax || exceedMin)) {\n              _context.next = 22;\n              break;\n            }\n\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n            if (validateAllFieldCriteria) {\n              _context.next = 22;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 22:\n            if (!(isString(inputValue) && !isEmpty && (maxLength || minLength))) {\n              _context.next = 31;\n              break;\n            }\n\n            maxLengthOutput = getValueAndMessage(maxLength);\n            minLengthOutput = getValueAndMessage(minLength);\n            _exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > maxLengthOutput.value;\n            _exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < minLengthOutput.value;\n\n            if (!(_exceedMax || _exceedMin)) {\n              _context.next = 31;\n              break;\n            }\n\n            getMinMaxMessage(_exceedMax, maxLengthOutput.message, minLengthOutput.message);\n\n            if (validateAllFieldCriteria) {\n              _context.next = 31;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 31:\n            if (!(isString(inputValue) && pattern && !isEmpty)) {\n              _context.next = 37;\n              break;\n            }\n\n            _getValueAndMessage = getValueAndMessage(pattern), patternValue = _getValueAndMessage.value, _message = _getValueAndMessage.message;\n\n            if (!(isRegex(patternValue) && !patternValue.test(inputValue))) {\n              _context.next = 37;\n              break;\n            }\n\n            error[name] = Object.assign({\n              type: INPUT_VALIDATION_RULES.pattern,\n              message: _message,\n              ref: ref\n            }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, _message));\n\n            if (validateAllFieldCriteria) {\n              _context.next = 37;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 37:\n            if (!validate) {\n              _context.next = 69;\n              break;\n            }\n\n            validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\n\n            if (!isFunction(validate)) {\n              _context.next = 50;\n              break;\n            }\n\n            _context.next = 42;\n            return validate(inputValue);\n\n          case 42:\n            result = _context.sent;\n            validateError = getValidateError(result, validateRef);\n\n            if (!validateError) {\n              _context.next = 48;\n              break;\n            }\n\n            error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n            if (validateAllFieldCriteria) {\n              _context.next = 48;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 48:\n            _context.next = 69;\n            break;\n\n          case 50:\n            if (!isObject(validate)) {\n              _context.next = 69;\n              break;\n            }\n\n            validationResult = {};\n            _i2 = 0, _Object$entries = Object.entries(validate);\n\n          case 53:\n            if (!(_i2 < _Object$entries.length)) {\n              _context.next = 65;\n              break;\n            }\n\n            _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), key = _Object$entries$_i[0], validateFunction = _Object$entries$_i[1];\n\n            if (!(!isEmptyObject(validationResult) && !validateAllFieldCriteria)) {\n              _context.next = 57;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 65);\n\n          case 57:\n            _context.next = 59;\n            return validateFunction(inputValue);\n\n          case 59:\n            validateResult = _context.sent;\n            _validateError = getValidateError(validateResult, validateRef, key);\n\n            if (_validateError) {\n              validationResult = Object.assign(Object.assign({}, _validateError), appendErrorsCurry(key, _validateError.message));\n\n              if (validateAllFieldCriteria) {\n                error[name] = validationResult;\n              }\n            }\n\n          case 62:\n            _i2++;\n            _context.next = 53;\n            break;\n\n          case 65:\n            if (isEmptyObject(validationResult)) {\n              _context.next = 69;\n              break;\n            }\n\n            error[name] = Object.assign({\n              ref: validateRef\n            }, validationResult);\n\n            if (validateAllFieldCriteria) {\n              _context.next = 69;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 69:\n            return _context.abrupt(\"return\", error);\n\n          case 70:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function validateField(_x, _x2) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nvar skipValidation = function skipValidation(_ref9) {\n  var isOnBlur = _ref9.isOnBlur,\n      isOnChange = _ref9.isOnChange,\n      isOnTouch = _ref9.isOnTouch,\n      isTouched = _ref9.isTouched,\n      isReValidateOnBlur = _ref9.isReValidateOnBlur,\n      isReValidateOnChange = _ref9.isReValidateOnChange,\n      isBlurEvent = _ref9.isBlurEvent,\n      isSubmitted = _ref9.isSubmitted,\n      isOnAll = _ref9.isOnAll;\n\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n\n  return true;\n};\n\nvar getFieldArrayParentName = function getFieldArrayParentName(name) {\n  return name.substring(0, name.search(/.\\d/)) || name;\n};\n\nvar isNameInFieldArray = function isNameInFieldArray(names, name) {\n  return _toConsumableArray(names).some(function (current) {\n    return getFieldArrayParentName(name) === current;\n  });\n};\n\nvar getProxyFormState = function getProxyFormState(isProxyEnabled, formState, readFormStateRef, localReadFormStateRef) {\n  var isRoot = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  return isProxyEnabled ? new Proxy(formState, {\n    get: function get(obj, prop) {\n      if (prop in obj) {\n        if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\n          readFormStateRef.current[prop] = isRoot ? VALIDATION_MODE.all : true;\n        }\n\n        localReadFormStateRef && (localReadFormStateRef.current[prop] = true);\n        return obj[prop];\n      }\n\n      return undefined;\n    }\n  }) : formState;\n};\n\nvar Subscription = /*#__PURE__*/function () {\n  function Subscription() {\n    _classCallCheck(this, Subscription);\n\n    this.tearDowns = [];\n  }\n\n  _createClass(Subscription, [{\n    key: \"add\",\n    value: function add(tearDown) {\n      this.tearDowns.push(tearDown);\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _iterator2 = _createForOfIteratorHelper(this.tearDowns),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var teardown = _step2.value;\n          teardown();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this.tearDowns = [];\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar Subscriber = /*#__PURE__*/function () {\n  function Subscriber(observer, subscription) {\n    var _this = this;\n\n    _classCallCheck(this, Subscriber);\n\n    this.observer = observer;\n    this.closed = false;\n    subscription.add(function () {\n      return _this.closed = true;\n    });\n  }\n\n  _createClass(Subscriber, [{\n    key: \"next\",\n    value: function next(value) {\n      if (!this.closed) {\n        this.observer.next(value);\n      }\n    }\n  }]);\n\n  return Subscriber;\n}();\n\nvar Subject = /*#__PURE__*/function () {\n  function Subject() {\n    _classCallCheck(this, Subject);\n\n    this.observers = [];\n  }\n\n  _createClass(Subject, [{\n    key: \"next\",\n    value: function next(value) {\n      var _iterator3 = _createForOfIteratorHelper(this.observers),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var observer = _step3.value;\n          observer.next(value);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(observer) {\n      var subscription = new Subscription();\n      var subscriber = new Subscriber(observer, subscription);\n      this.observers.push(subscriber);\n      return subscription;\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      this.observers = [];\n    }\n  }]);\n\n  return Subject;\n}();\n\nvar isWeb = typeof window !== UNDEFINED && typeof document !== UNDEFINED;\nvar isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nvar getPath = function getPath(rootPath, values) {\n  var paths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  for (var property in values) {\n    isPrimitive(values[property]) ? paths.push(\"\".concat(rootPath, \".\").concat(property)) : getPath(\"\".concat(rootPath, \".\").concat(property), values[property], paths);\n  }\n\n  return paths;\n};\n\nfunction baseGet(object, updatePath) {\n  var length = updatePath.slice(0, -1).length;\n  var index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nfunction unset(object, path) {\n  var updatePath = isKey(path) ? [path] : stringToPath(path);\n  var childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  var key = updatePath[updatePath.length - 1];\n  var previousObjRef;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (var k = 0; k < updatePath.slice(0, -1).length; k++) {\n    var index = -1;\n    var objectRef = void 0;\n    var currentPaths = updatePath.slice(0, -(k + 1));\n    var currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      var item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && !objectRef.filter(function (data) {\n        return isObject(data) && !isEmptyObject(data) || isBoolean(data);\n      }).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nvar getValidationModes = function getValidationModes(mode) {\n  return {\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\n    isOnChange: mode === VALIDATION_MODE.onChange,\n    isOnAll: mode === VALIDATION_MODE.all,\n    isOnTouch: mode === VALIDATION_MODE.onTouched\n  };\n};\n\nvar isRadioOrCheckboxFunction = function isRadioOrCheckboxFunction(ref) {\n  return isRadioInput(ref) || isCheckBoxInput(ref);\n};\n\nvar isHTMLElement = function isHTMLElement(value) {\n  return value instanceof HTMLElement;\n};\n\nfunction getFields(fieldsNames, fieldsRefs) {\n  var currentFields = {};\n\n  var _iterator4 = _createForOfIteratorHelper(fieldsNames),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _name = _step4.value;\n      var field = get(fieldsRefs, _name);\n\n      if (field) {\n        !isKey(_name) ? set(currentFields, _name, field._f) : currentFields[_name] = field._f;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return currentFields;\n}\n\nvar isWindowUndefined = typeof window === UNDEFINED;\n\nfunction useForm() {\n  var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref10$mode = _ref10.mode,\n      mode = _ref10$mode === void 0 ? VALIDATION_MODE.onSubmit : _ref10$mode,\n      _ref10$reValidateMode = _ref10.reValidateMode,\n      reValidateMode = _ref10$reValidateMode === void 0 ? VALIDATION_MODE.onChange : _ref10$reValidateMode,\n      resolver = _ref10.resolver,\n      context = _ref10.context,\n      _ref10$defaultValues = _ref10.defaultValues,\n      defaultValues = _ref10$defaultValues === void 0 ? {} : _ref10$defaultValues,\n      _ref10$shouldFocusErr = _ref10.shouldFocusError,\n      shouldFocusError = _ref10$shouldFocusErr === void 0 ? true : _ref10$shouldFocusErr,\n      criteriaMode = _ref10.criteriaMode;\n\n  var fieldsRef = useRef({});\n  var fieldsNamesRef = useRef(new Set());\n  var formStateSubjectRef = useRef(new Subject());\n  var watchSubjectRef = useRef(new Subject());\n  var controllerSubjectRef = useRef(new Subject());\n  var fieldArraySubjectRef = useRef(new Subject());\n  var fieldArrayUpdatedValuesRef = useRef({});\n  var fieldArrayDefaultValuesRef = useRef({});\n  var watchFieldsRef = useRef(new Set());\n  var isMountedRef = useRef(false);\n  var fieldsWithValidationRef = useRef({});\n  var validFieldsRef = useRef({});\n  var defaultValuesRef = useRef(defaultValues);\n  var isWatchAllRef = useRef(false);\n  var contextRef = useRef(context);\n  var resolverRef = useRef(resolver);\n  var fieldArrayNamesRef = useRef(new Set());\n  var validationMode = getValidationModes(mode);\n  var isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n\n  var _useState = useState({\n    isDirty: false,\n    isValidating: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touchedFields: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !validationMode.isOnSubmit,\n    errors: {}\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      formState = _useState2[0],\n      setFormState = _useState2[1];\n\n  var readFormStateRef = useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touchedFields: !isProxyEnabled || validationMode.isOnTouch,\n    isValidating: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n    errors: !isProxyEnabled\n  });\n  var formStateRef = useRef(formState);\n  contextRef.current = context;\n  resolverRef.current = resolver;\n\n  var getIsValid = function getIsValid() {\n    return formStateRef.current.isValid = deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) && isEmptyObject(formStateRef.current.errors);\n  };\n\n  var shouldRenderBaseOnError = useCallback(function (name, error) {\n    var shouldRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var isValid = arguments.length > 4 ? arguments[4] : undefined;\n    var shouldReRender = shouldRender || isErrorStateChanged({\n      errors: formStateRef.current.errors,\n      error: error,\n      name: name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    var previousError = get(formStateRef.current.errors, name);\n\n    if (error) {\n      unset(validFieldsRef.current, name);\n      shouldReRender = shouldReRender || !previousError || !deepEqual(previousError, error, true);\n      set(formStateRef.current.errors, name, error);\n    } else {\n      if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n        set(validFieldsRef.current, name, true);\n        shouldReRender = shouldReRender || previousError;\n      }\n\n      unset(formStateRef.current.errors, name);\n    }\n\n    if (shouldReRender && !isNullOrUndefined(shouldRender) || !isEmptyObject(state)) {\n      formStateSubjectRef.current.next(Object.assign(Object.assign({}, state), {\n        isValid: resolverRef.current ? isValid : getIsValid(),\n        errors: formStateRef.current.errors\n      }));\n    }\n\n    formStateSubjectRef.current.next({\n      isValidating: false\n    });\n  }, []);\n  var setFieldValue = useCallback(function (name, rawValue) {\n    var _get = get(fieldsRef.current, name),\n        _f = _get._f;\n\n    if (_f) {\n      var _ref11 = _f.ref,\n          refs = _f.refs;\n      var value = isWeb && isHTMLElement(_ref11) && isNullOrUndefined(rawValue) ? '' : rawValue;\n      _f.value = rawValue;\n\n      if (isRadioInput(_ref11)) {\n        (refs || []).forEach(function (radioRef) {\n          return radioRef.checked = radioRef.value === value;\n        });\n      } else if (isFileInput(_ref11) && !isString(value)) {\n        _ref11.files = value;\n      } else if (isMultipleSelect(_ref11)) {\n        _toConsumableArray(_ref11.options).forEach(function (selectRef) {\n          return selectRef.selected = value.includes(selectRef.value);\n        });\n      } else if (isCheckBoxInput(_ref11) && refs) {\n        refs.length > 1 ? refs.forEach(function (checkboxRef) {\n          return checkboxRef.checked = Array.isArray(value) ? !!value.find(function (data) {\n            return data === checkboxRef.value;\n          }) : value === checkboxRef.value;\n        }) : refs[0].checked = !!value;\n      } else {\n        _ref11.value = value;\n      }\n    }\n  }, []);\n  var getFormIsDirty = useCallback(function (name, data) {\n    if (readFormStateRef.current.isDirty) {\n      var formValues = getValues();\n      name && data && set(formValues, name, data);\n      return !deepEqual(formValues, defaultValuesRef.current);\n    }\n\n    return false;\n  }, []);\n  var updateAndGetDirtyState = useCallback(function (name) {\n    var shouldRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) {\n      var isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), getFieldValue(get(fieldsRef.current, name), true));\n      var isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n      var previousIsDirty = formStateRef.current.isDirty;\n      isFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);\n      var state = {\n        isDirty: getFormIsDirty(),\n        dirtyFields: formStateRef.current.dirtyFields\n      };\n      var isChanged = readFormStateRef.current.isDirty && previousIsDirty !== state.isDirty || readFormStateRef.current.dirtyFields && isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name);\n      isChanged && shouldRender && formStateSubjectRef.current.next(state);\n      return isChanged ? state : {};\n    }\n\n    return {};\n  }, []);\n  var executeValidation = useCallback( /*#__PURE__*/function () {\n    var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, skipReRender) {\n      var error;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria);\n\n            case 2:\n              _context2.t0 = name;\n              error = _context2.sent[_context2.t0];\n              shouldRenderBaseOnError(name, error, skipReRender);\n              return _context2.abrupt(\"return\", isUndefined(error));\n\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x3, _x4) {\n      return _ref12.apply(this, arguments);\n    };\n  }(), [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  var executeSchemaOrResolverValidation = useCallback( /*#__PURE__*/function () {\n    var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(names) {\n      var currentNames,\n          _yield$resolverRef$cu,\n          errors,\n          _iterator5,\n          _step5,\n          _name2,\n          _error,\n          _args3 = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              currentNames = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : [];\n              _context3.next = 3;\n              return resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef, true), contextRef.current, {\n                criteriaMode: criteriaMode,\n                names: currentNames,\n                fields: getFields(fieldsNamesRef.current, fieldsRef.current)\n              });\n\n            case 3:\n              _yield$resolverRef$cu = _context3.sent;\n              errors = _yield$resolverRef$cu.errors;\n              _iterator5 = _createForOfIteratorHelper(names);\n\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  _name2 = _step5.value;\n                  _error = get(errors, _name2);\n                  _error ? set(formStateRef.current.errors, _name2, _error) : unset(formStateRef.current.errors, _name2);\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n\n              return _context3.abrupt(\"return\", errors);\n\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x5) {\n      return _ref13.apply(this, arguments);\n    };\n  }(), [shouldRenderBaseOnError, criteriaMode]);\n\n  var validateForm = /*#__PURE__*/function () {\n    var _ref14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(fieldsRef) {\n      var _name3, field, _f, current, fieldError;\n\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.t0 = _regeneratorRuntime.keys(fieldsRef);\n\n            case 1:\n              if ((_context4.t1 = _context4.t0()).done) {\n                _context4.next = 17;\n                break;\n              }\n\n              _name3 = _context4.t1.value;\n              field = fieldsRef[_name3];\n\n              if (!field) {\n                _context4.next = 15;\n                break;\n              }\n\n              _f = field._f, current = __rest(field, [\"_f\"]);\n\n              if (!_f) {\n                _context4.next = 11;\n                break;\n              }\n\n              _context4.next = 9;\n              return validateField(field, isValidateAllFieldCriteria);\n\n            case 9:\n              fieldError = _context4.sent;\n\n              if (fieldError[field._f.name]) {\n                set(formStateRef.current.errors, field._f.name, fieldError[field._f.name]);\n                unset(validFieldsRef.current, field._f.name);\n              } else if (get(fieldsWithValidationRef.current, field._f.name)) {\n                set(validFieldsRef.current, field._f.name, true);\n                unset(formStateRef.current.errors, field._f.name);\n              }\n\n            case 11:\n              _context4.t2 = current;\n\n              if (!_context4.t2) {\n                _context4.next = 15;\n                break;\n              }\n\n              _context4.next = 15;\n              return validateForm(current);\n\n            case 15:\n              _context4.next = 1;\n              break;\n\n            case 17:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function validateForm(_x6) {\n      return _ref14.apply(this, arguments);\n    };\n  }();\n\n  var trigger = useCallback( /*#__PURE__*/function () {\n    var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(name) {\n      var fields, isValid;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              fields = isUndefined(name) ? Object.keys(fieldsRef.current) : Array.isArray(name) ? name : [name];\n              formStateSubjectRef.current.next({\n                isValidating: true\n              });\n\n              if (!resolver) {\n                _context6.next = 10;\n                break;\n              }\n\n              _context6.t0 = isEmptyObject;\n              _context6.next = 6;\n              return executeSchemaOrResolverValidation(fields, isUndefined(name) ? undefined : fields);\n\n            case 6:\n              _context6.t1 = _context6.sent;\n              isValid = (0, _context6.t0)(_context6.t1);\n              _context6.next = 17;\n              break;\n\n            case 10:\n              if (!isUndefined(name)) {\n                _context6.next = 15;\n                break;\n              }\n\n              _context6.next = 13;\n              return validateForm(fieldsRef.current);\n\n            case 13:\n              _context6.next = 17;\n              break;\n\n            case 15:\n              _context6.next = 17;\n              return Promise.all(fields.map( /*#__PURE__*/function () {\n                var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(data) {\n                  return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                    while (1) {\n                      switch (_context5.prev = _context5.next) {\n                        case 0:\n                          _context5.next = 2;\n                          return executeValidation(data, null);\n\n                        case 2:\n                          return _context5.abrupt(\"return\", _context5.sent);\n\n                        case 3:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                  }, _callee5);\n                }));\n\n                return function (_x8) {\n                  return _ref16.apply(this, arguments);\n                };\n              }()));\n\n            case 17:\n              formStateSubjectRef.current.next({\n                errors: formStateRef.current.errors,\n                isValidating: false,\n                isValid: resolver ? isValid : getIsValid()\n              });\n\n            case 18:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n\n    return function (_x7) {\n      return _ref15.apply(this, arguments);\n    };\n  }(), [executeSchemaOrResolverValidation, executeValidation]);\n  var setInternalValues = useCallback(function (name, value, _ref17) {\n    var shouldDirty = _ref17.shouldDirty,\n        shouldValidate = _ref17.shouldValidate;\n    var data = {};\n    set(data, name, value);\n\n    var _iterator6 = _createForOfIteratorHelper(getPath(name, value)),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var fieldName = _step6.value;\n\n        if (get(fieldsRef.current, fieldName)) {\n          setFieldValue(fieldName, get(data, fieldName));\n          shouldDirty && updateAndGetDirtyState(fieldName);\n          shouldValidate && trigger(fieldName);\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  }, [trigger, setFieldValue, updateAndGetDirtyState]);\n  var setInternalValue = useCallback(function (name, value, options) {\n    var field = get(fieldsRef.current, name);\n\n    if (field && field._f) {\n      setFieldValue(name, value);\n      options.shouldDirty && updateAndGetDirtyState(name);\n      options.shouldValidate && trigger(name);\n    } else {\n      setInternalValues(name, value, options);\n\n      if (fieldArrayNamesRef.current.has(name)) {\n        fieldArraySubjectRef.current.next({\n          fields: value,\n          name: name,\n          isReset: true\n        });\n\n        if ((readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && options.shouldDirty) {\n          set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n          formStateSubjectRef.current.next({\n            dirtyFields: formStateRef.current.dirtyFields,\n            isDirty: getFormIsDirty(name, value)\n          });\n        }\n      }\n    }\n  }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\n\n  var isFieldWatched = function isFieldWatched(name) {\n    return isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n  };\n\n  var updateValueAndGetDefault = function updateValueAndGetDefault(name) {\n    var defaultValue;\n    var isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    var field = get(fieldsRef.current, name);\n\n    if (field && (!isEmptyObject(defaultValuesRef.current) || !isUndefined(field._f.value))) {\n      defaultValue = isUndefined(field._f.value) ? get(defaultValuesRef.current, name) : field._f.value;\n\n      if (!isUndefined(defaultValue) && !isFieldArray) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    return defaultValue;\n  };\n\n  var setValue = function setValue(name, value, options) {\n    setInternalValue(name, value, options || {});\n    isFieldWatched(name) && formStateSubjectRef.current.next({});\n    watchSubjectRef.current.next({\n      name: name,\n      value: value\n    });\n  };\n\n  var handleChange = useCallback( /*#__PURE__*/function () {\n    var _ref19 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(_ref18) {\n      var type, target, _ref18$target, value, inputType, name, error, isValid, field, inputValue, isBlurEvent, _getValidationModes, isReValidateOnBlur, isReValidateOnChange, shouldSkipValidation, isWatched, state, shouldRender, _yield$resolverRef$cu2, errors, previousFormIsValid, parentNodeName, currentError;\n\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              type = _ref18.type, target = _ref18.target, _ref18$target = _ref18.target, value = _ref18$target.value, inputType = _ref18$target.type;\n              name = target.name;\n              field = get(fieldsRef.current, name);\n\n              if (!field) {\n                _context7.next = 35;\n                break;\n              }\n\n              inputValue = inputType ? getFieldValue(field) : value;\n              isBlurEvent = type === EVENTS.BLUR;\n              _getValidationModes = getValidationModes(reValidateMode), isReValidateOnBlur = _getValidationModes.isOnBlur, isReValidateOnChange = _getValidationModes.isOnChange;\n              shouldSkipValidation = skipValidation(Object.assign({\n                isBlurEvent: isBlurEvent,\n                isTouched: !!get(formStateRef.current.touchedFields, name),\n                isSubmitted: formStateRef.current.isSubmitted,\n                isReValidateOnBlur: isReValidateOnBlur,\n                isReValidateOnChange: isReValidateOnChange\n              }, validationMode));\n              isWatched = !isBlurEvent && isFieldWatched(name);\n\n              if (!isUndefined(inputValue)) {\n                field._f.value = inputValue;\n              }\n\n              state = updateAndGetDirtyState(name, false);\n\n              if (isBlurEvent && readFormStateRef.current.touchedFields && !get(formStateRef.current.touchedFields, name)) {\n                set(formStateRef.current.touchedFields, name, true);\n                state.touchedFields = formStateRef.current.touchedFields;\n              }\n\n              shouldRender = !isEmptyObject(state) || isWatched;\n\n              if (!shouldSkipValidation) {\n                _context7.next = 16;\n                break;\n              }\n\n              !isBlurEvent && watchSubjectRef.current.next({\n                name: name,\n                type: type,\n                value: inputValue\n              });\n              return _context7.abrupt(\"return\", shouldRender && formStateSubjectRef.current.next(isWatched ? {} : state));\n\n            case 16:\n              formStateSubjectRef.current.next({\n                isValidating: true\n              });\n\n              if (!resolverRef.current) {\n                _context7.next = 29;\n                break;\n              }\n\n              _context7.next = 20;\n              return resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef, true), contextRef.current, {\n                criteriaMode: criteriaMode,\n                fields: getFields([name], fieldsRef.current),\n                names: [name]\n              });\n\n            case 20:\n              _yield$resolverRef$cu2 = _context7.sent;\n              errors = _yield$resolverRef$cu2.errors;\n              previousFormIsValid = formStateRef.current.isValid;\n              error = get(errors, name);\n\n              if (isCheckBoxInput(target) && !error) {\n                parentNodeName = getFieldArrayParentName(name);\n                currentError = get(errors, parentNodeName, {});\n                currentError.type && currentError.message && (error = currentError);\n\n                if (currentError || get(formStateRef.current.errors, parentNodeName)) {\n                  name = parentNodeName;\n                }\n              }\n\n              isValid = isEmptyObject(errors);\n              previousFormIsValid !== isValid && (shouldRender = true);\n              _context7.next = 33;\n              break;\n\n            case 29:\n              _context7.next = 31;\n              return validateField(field, isValidateAllFieldCriteria);\n\n            case 31:\n              _context7.t0 = name;\n              error = _context7.sent[_context7.t0];\n\n            case 33:\n              !isBlurEvent && watchSubjectRef.current.next({\n                name: name,\n                type: type,\n                value: inputValue\n              });\n              shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n\n            case 35:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7);\n    }));\n\n    return function (_x9) {\n      return _ref19.apply(this, arguments);\n    };\n  }(), []);\n\n  function getValues(fieldNames) {\n    var values = isMountedRef.current ? getFieldsValues(fieldsRef, defaultValuesRef) : defaultValues;\n\n    if (isUndefined(fieldNames)) {\n      return values;\n    }\n\n    if (isString(fieldNames)) {\n      return get(values, fieldNames);\n    }\n\n    return fieldNames.map(function (name) {\n      return get(values, name);\n    });\n  }\n\n  var updateIsValid = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n    var values,\n        _yield$resolverRef$cu3,\n        errors,\n        isValid,\n        _args8 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            values = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};\n\n            if (!resolver) {\n              _context8.next = 10;\n              break;\n            }\n\n            _context8.next = 4;\n            return resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef, defaultValuesRef, true)), values), contextRef.current, {\n              criteriaMode: criteriaMode,\n              fields: getFields(fieldsNamesRef.current, fieldsRef.current)\n            });\n\n          case 4:\n            _yield$resolverRef$cu3 = _context8.sent;\n            errors = _yield$resolverRef$cu3.errors;\n            isValid = isEmptyObject(errors);\n            formStateRef.current.isValid !== isValid && formStateSubjectRef.current.next({\n              isValid: isValid\n            });\n            _context8.next = 11;\n            break;\n\n          case 10:\n            getIsValid();\n\n          case 11:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  })), [criteriaMode]);\n\n  var clearErrors = function clearErrors(name) {\n    name && (Array.isArray(name) ? name : [name]).forEach(function (inputName) {\n      return unset(formStateRef.current.errors, inputName);\n    });\n    formStateSubjectRef.current.next({\n      errors: name ? formStateRef.current.errors : {}\n    });\n  };\n\n  var setError = function setError(name, error, options) {\n    var ref = (get(fieldsRef.current, name) || {\n      _f: {}\n    })._f.ref;\n\n    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), {\n      ref: ref\n    }));\n    formStateSubjectRef.current.next({\n      errors: formStateRef.current.errors,\n      isValid: false\n    });\n    options && options.shouldFocus && ref && ref.focus && ref.focus();\n  };\n\n  var watchInternal = useCallback(function (fieldNames, defaultValue, isGlobal) {\n    var _fieldArrayUpdatedVal = fieldArrayUpdatedValuesRef.current,\n        fields = _fieldArrayUpdatedVal.fields,\n        name = _fieldArrayUpdatedVal.name;\n    var isArrayNames = Array.isArray(fieldNames);\n    var fieldValues = isMountedRef.current ? getValues() : isUndefined(defaultValue) ? defaultValuesRef.current : isArrayNames ? defaultValue || {} : _defineProperty({}, fieldNames, defaultValue);\n\n    if (fields) {\n      name ? set(fieldValues, name, fields) : fieldValues = fields;\n      fieldArrayUpdatedValuesRef.current = {\n        fields: undefined,\n        name: undefined\n      };\n    }\n\n    if (isUndefined(fieldNames)) {\n      isWatchAllRef.current = true;\n      return fieldValues;\n    }\n\n    var result = [];\n\n    var _iterator7 = _createForOfIteratorHelper(isArrayNames ? fieldNames : [fieldNames]),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var fieldName = _step7.value;\n        isGlobal && watchFieldsRef.current.add(fieldName);\n        result.push(get(fieldValues, fieldName));\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    return isArrayNames ? result : result[0];\n  }, []);\n\n  function watch(fieldName, defaultValue) {\n    if (isFunction(fieldName)) {\n      return watchSubjectRef.current.subscribe({\n        next: function next(info) {\n          return fieldName(watchInternal(undefined, defaultValue), info);\n        }\n      });\n    }\n\n    return watchInternal(fieldName, defaultValue, true);\n  }\n\n  var unregister = function unregister(name) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _iterator8 = _createForOfIteratorHelper(name ? Array.isArray(name) ? name : [name] : Object.keys(fieldsNamesRef.current)),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var inputName = _step8.value;\n        fieldsNamesRef.current.delete(inputName);\n\n        if (get(fieldsRef.current, inputName)) {\n          if (!options.keepIsValid) {\n            unset(fieldsWithValidationRef.current, inputName);\n            unset(validFieldsRef.current, inputName);\n          }\n\n          !options.keepValues && unset(formStateRef.current.errors, inputName);\n          !options.keepErrors && unset(fieldsRef.current, inputName);\n          !options.keepDirty && unset(formStateRef.current.dirtyFields, inputName);\n          !options.keepTouched && unset(formStateRef.current.touchedFields, inputName);\n          !options.keepDefaultValues && unset(defaultValuesRef.current, inputName);\n          watchSubjectRef.current.next({\n            name: inputName\n          });\n        }\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n\n    formStateSubjectRef.current.next(Object.assign(Object.assign(Object.assign({}, formStateRef.current), !options.keepDirty ? {} : {\n      isDirty: getFormIsDirty()\n    }), resolver ? {} : {\n      isValid: getIsValid()\n    }));\n\n    if (!options.keepIsValid) {\n      updateIsValid();\n    }\n  };\n\n  var registerFieldRef = function registerFieldRef(name, ref, options) {\n    var field = get(fieldsRef.current, name);\n\n    if (field) {\n      var isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n\n      if ((isRadioOrCheckbox ? Array.isArray(field._f.refs) && compact(field._f.refs).find(function (option) {\n        return ref.value === option.value && option === ref;\n      }) : ref === field._f.ref) || !field) {\n        return;\n      }\n\n      field = {\n        _f: isRadioOrCheckbox ? Object.assign(Object.assign({}, field._f), {\n          refs: [].concat(_toConsumableArray(compact(field._f.refs || []).filter(function (ref) {\n            return isHTMLElement(ref) && document.contains(ref);\n          })), [ref]),\n          ref: {\n            type: ref.type,\n            name: name\n          }\n        }) : Object.assign(Object.assign({}, field._f), {\n          ref: ref\n        })\n      };\n      set(fieldsRef.current, name, field);\n      var defaultValue = updateValueAndGetDefault(name);\n\n      if (isRadioOrCheckbox && Array.isArray(defaultValue) ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue) : true) {\n        get(fieldsRef.current, name)._f.value = getFieldValue(get(fieldsRef.current, name));\n      }\n\n      if (options) {\n        if (!validationMode.isOnSubmit && field && readFormStateRef.current.isValid) {\n          validateField(field, isValidateAllFieldCriteria).then(function (error) {\n            isEmptyObject(error) ? set(validFieldsRef.current, name, true) : unset(validFieldsRef.current, name);\n            formStateRef.current.isValid && !isEmptyObject(error) && setFormState(Object.assign(Object.assign({}, formStateRef.current), {\n              isValid: getIsValid()\n            }));\n          });\n        }\n      }\n    }\n  };\n\n  var register = useCallback(function (name, options) {\n    set(fieldsRef.current, name, {\n      _f: Object.assign(Object.assign(Object.assign({}, get(fieldsRef.current, name) ? Object.assign({\n        ref: get(fieldsRef.current, name)._f.ref\n      }, get(fieldsRef.current, name)._f) : {\n        ref: {\n          name: name\n        }\n      }), {\n        name: name\n      }), options)\n    });\n    options && set(fieldsWithValidationRef.current, name, true);\n    fieldsNamesRef.current.add(name);\n    updateValueAndGetDefault(name);\n    return isWindowUndefined ? {} : {\n      name: name,\n      onChange: handleChange,\n      onBlur: handleChange,\n      ref: function (_ref22) {\n        function ref(_x10) {\n          return _ref22.apply(this, arguments);\n        }\n\n        ref.toString = function () {\n          return _ref22.toString();\n        };\n\n        return ref;\n      }(function (ref) {\n        return ref && registerFieldRef(name, ref, options);\n      })\n    };\n  }, [defaultValuesRef.current]);\n  var handleSubmit = useCallback(function (onValid, onInvalid) {\n    return /*#__PURE__*/function () {\n      var _ref23 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(e) {\n        var fieldValues, _yield$resolverRef$cu4, errors, values;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (e && e.preventDefault) {\n                  e.preventDefault();\n                  e.persist();\n                }\n\n                fieldValues = getFieldsValues(fieldsRef, defaultValuesRef, true);\n                formStateSubjectRef.current.next({\n                  isSubmitting: true\n                });\n                _context9.prev = 3;\n\n                if (!resolverRef.current) {\n                  _context9.next = 14;\n                  break;\n                }\n\n                _context9.next = 7;\n                return resolverRef.current(fieldValues, contextRef.current, {\n                  criteriaMode: criteriaMode,\n                  fields: getFields(fieldsNamesRef.current, fieldsRef.current)\n                });\n\n              case 7:\n                _yield$resolverRef$cu4 = _context9.sent;\n                errors = _yield$resolverRef$cu4.errors;\n                values = _yield$resolverRef$cu4.values;\n                formStateRef.current.errors = errors;\n                fieldValues = values;\n                _context9.next = 16;\n                break;\n\n              case 14:\n                _context9.next = 16;\n                return validateForm(fieldsRef.current);\n\n              case 16:\n                if (!(isEmptyObject(formStateRef.current.errors) && Object.keys(formStateRef.current.errors).every(function (name) {\n                  return get(fieldValues, name);\n                }))) {\n                  _context9.next = 22;\n                  break;\n                }\n\n                formStateSubjectRef.current.next({\n                  errors: {},\n                  isSubmitting: true\n                });\n                _context9.next = 20;\n                return onValid(fieldValues, e);\n\n              case 20:\n                _context9.next = 27;\n                break;\n\n              case 22:\n                _context9.t0 = onInvalid;\n\n                if (!_context9.t0) {\n                  _context9.next = 26;\n                  break;\n                }\n\n                _context9.next = 26;\n                return onInvalid(formStateRef.current.errors, e);\n\n              case 26:\n                shouldFocusError && focusFieldBy(fieldsRef.current, function (key) {\n                  return get(formStateRef.current.errors, key);\n                }, fieldsNamesRef.current);\n\n              case 27:\n                _context9.prev = 27;\n                formStateRef.current.isSubmitting = false;\n                formStateSubjectRef.current.next({\n                  isSubmitted: true,\n                  isSubmitting: false,\n                  isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n                  submitCount: formStateRef.current.submitCount + 1,\n                  errors: formStateRef.current.errors\n                });\n                return _context9.finish(27);\n\n              case 31:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, null, [[3,, 27, 31]]);\n      }));\n\n      return function (_x11) {\n        return _ref23.apply(this, arguments);\n      };\n    }();\n  }, [shouldFocusError, isValidateAllFieldCriteria, criteriaMode]);\n\n  var resetFromState = function resetFromState(_ref24) {\n    var keepErrors = _ref24.keepErrors,\n        keepDirty = _ref24.keepDirty,\n        keepIsSubmitted = _ref24.keepIsSubmitted,\n        keepTouched = _ref24.keepTouched,\n        keepIsValid = _ref24.keepIsValid,\n        keepSubmitCount = _ref24.keepSubmitCount;\n\n    if (!keepIsValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n    formStateSubjectRef.current.next({\n      submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\n      isDirty: keepDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: keepIsValid ? formStateRef.current.isValid : !validationMode.isOnSubmit,\n      dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\n      touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\n      errors: keepErrors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false\n    });\n  };\n\n  var reset = function reset(values) {\n    var keepStateOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var updatedValues = values || defaultValuesRef.current;\n\n    if (isWeb && !keepStateOptions.keepValues) {\n      for (var _i3 = 0, _Object$values = Object.values(fieldsRef.current); _i3 < _Object$values.length; _i3++) {\n        var field = _Object$values[_i3];\n\n        if (field && field._f) {\n          var _field$_f = field._f,\n              _ref25 = _field$_f.ref,\n              refs = _field$_f.refs;\n          var inputRef = Array.isArray(refs) ? refs[0] : _ref25;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n\n    !keepStateOptions.keepDefaultValues && (defaultValuesRef.current = Object.assign({}, updatedValues));\n\n    if (!keepStateOptions.keepValues) {\n      fieldsRef.current = {};\n      controllerSubjectRef.current.next(Object.assign({}, updatedValues));\n      watchSubjectRef.current.next({\n        value: Object.assign({}, updatedValues)\n      });\n      fieldArraySubjectRef.current.next({\n        fields: Object.assign({}, updatedValues),\n        isReset: true\n      });\n    }\n\n    resetFromState(keepStateOptions);\n  };\n\n  useEffect(function () {\n    resolver && readFormStateRef.current.isValid && updateIsValid();\n  }, [defaultValuesRef.current]);\n  useEffect(function () {\n    isMountedRef.current = true;\n    var formStateSubscription = formStateSubjectRef.current.subscribe({\n      next: function next() {\n        var formState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\n          formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState);\n          setFormState(formStateRef.current);\n        }\n      }\n    });\n    var useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next: function next(state) {\n        if (state.fields && state.name) {\n          fieldArrayUpdatedValuesRef.current = state;\n\n          if (readFormStateRef.current.isValid) {\n            var values = getValues();\n            set(values, state.name, state.fields);\n            updateIsValid(values);\n          }\n        }\n      }\n    });\n    return function () {\n      watchSubjectRef.current.unsubscribe();\n      formStateSubscription.unsubscribe();\n      useFieldArraySubscription.unsubscribe();\n    };\n  }, []);\n  return {\n    control: useMemo(function () {\n      return {\n        register: register,\n        isWatchAllRef: isWatchAllRef,\n        watchFieldsRef: watchFieldsRef,\n        getFormIsDirty: getFormIsDirty,\n        formStateSubjectRef: formStateSubjectRef,\n        fieldArraySubjectRef: fieldArraySubjectRef,\n        controllerSubjectRef: controllerSubjectRef,\n        watchSubjectRef: watchSubjectRef,\n        watchInternal: watchInternal,\n        fieldsRef: fieldsRef,\n        validFieldsRef: validFieldsRef,\n        fieldsWithValidationRef: fieldsWithValidationRef,\n        fieldArrayNamesRef: fieldArrayNamesRef,\n        readFormStateRef: readFormStateRef,\n        formStateRef: formStateRef,\n        defaultValuesRef: defaultValuesRef,\n        fieldArrayDefaultValuesRef: fieldArrayDefaultValuesRef\n      };\n    }, []),\n    formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),\n    trigger: trigger,\n    register: register,\n    handleSubmit: handleSubmit,\n    watch: useCallback(watch, []),\n    setValue: useCallback(setValue, [setInternalValue, trigger]),\n    getValues: useCallback(getValues, []),\n    reset: useCallback(reset, []),\n    clearErrors: useCallback(clearErrors, []),\n    unregister: useCallback(unregister, []),\n    setError: useCallback(setError, [])\n  };\n}\n\nvar FormContext = createContext(null);\nFormContext.displayName = 'RHFContext';\n\nvar useFormContext = function useFormContext() {\n  return useContext(FormContext);\n};\n\nvar FormProvider = function FormProvider(_a) {\n  var children = _a.children,\n      props = __rest(_a, [\"children\"]);\n\n  return createElement(FormContext.Provider, {\n    value: props\n  }, children);\n};\n\nvar generateId = function generateId() {\n  var d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nvar mapIds = function mapIds() {\n  var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var keyName = arguments.length > 1 ? arguments[1] : undefined;\n  return values.map(function (value) {\n    return Object.assign(_defineProperty({}, keyName, value && value[keyName] || generateId()), value);\n  });\n};\n\nfunction removeAtIndexes(data, indexes) {\n  var i = 0;\n\n  var temp = _toConsumableArray(data);\n\n  var _iterator9 = _createForOfIteratorHelper(indexes),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var index = _step9.value;\n      temp.splice(index - i, 1);\n      i++;\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  return compact(temp).length ? temp : [];\n}\n\nvar removeArrayAt = function removeArrayAt(data, index) {\n  return isUndefined(index) ? [] : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort());\n};\n\nvar moveArrayAt = function moveArrayAt(data, from, to) {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n\nvar swapArrayAt = function swapArrayAt(data, indexA, indexB) {\n  var temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n\nfunction prepend(data, value) {\n  return [].concat(_toConsumableArray(Array.isArray(value) ? value : [value || undefined]), _toConsumableArray(data));\n}\n\nfunction insert(data, index, value) {\n  return [].concat(_toConsumableArray(data.slice(0, index)), _toConsumableArray(Array.isArray(value) ? value : [value]), _toConsumableArray(data.slice(index)));\n}\n\nvar fillEmptyArray = function fillEmptyArray(value) {\n  return Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n};\n\nvar useFieldArray = function useFieldArray(_ref26) {\n  var control = _ref26.control,\n      name = _ref26.name,\n      _ref26$keyName = _ref26.keyName,\n      keyName = _ref26$keyName === void 0 ? 'id' : _ref26$keyName;\n  var methods = useFormContext();\n  var focusNameRef = useRef('');\n\n  var _ref27 = control || methods.control,\n      isWatchAllRef = _ref27.isWatchAllRef,\n      watchFieldsRef = _ref27.watchFieldsRef,\n      getFormIsDirty = _ref27.getFormIsDirty,\n      watchSubjectRef = _ref27.watchSubjectRef,\n      fieldArraySubjectRef = _ref27.fieldArraySubjectRef,\n      fieldArrayNamesRef = _ref27.fieldArrayNamesRef,\n      fieldsRef = _ref27.fieldsRef,\n      defaultValuesRef = _ref27.defaultValuesRef,\n      formStateRef = _ref27.formStateRef,\n      formStateSubjectRef = _ref27.formStateSubjectRef,\n      readFormStateRef = _ref27.readFormStateRef,\n      validFieldsRef = _ref27.validFieldsRef,\n      fieldsWithValidationRef = _ref27.fieldsWithValidationRef,\n      fieldArrayDefaultValuesRef = _ref27.fieldArrayDefaultValuesRef;\n\n  var _useState3 = useState(mapIds(get(fieldArrayDefaultValuesRef.current, getFieldArrayParentName(name)) ? get(fieldArrayDefaultValuesRef.current, name, []) : get(defaultValuesRef.current, name, []), keyName)),\n      _useState4 = _slicedToArray(_useState3, 2),\n      fields = _useState4[0],\n      setFields = _useState4[1];\n\n  set(fieldArrayDefaultValuesRef.current, name, _toConsumableArray(fields));\n  fieldArrayNamesRef.current.add(name);\n\n  var omitKey = function omitKey(fields) {\n    return fields.map(function () {\n      var _a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _b = keyName,\n          omitted = _a[_b],\n          rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n      return rest;\n    });\n  };\n\n  var getCurrentFieldsValues = function getCurrentFieldsValues() {\n    var values = get(getFieldsValues(fieldsRef, defaultValuesRef), name, []);\n    return mapIds(get(fieldArrayDefaultValuesRef.current, name, []).map(function (item, index) {\n      return Object.assign(Object.assign({}, item), values[index]);\n    }), keyName);\n  };\n\n  var getFocusDetail = function getFocusDetail(index, options) {\n    if (options) {\n      if (!isUndefined(options.focusIndex)) {\n        return \"\".concat(name, \".\").concat(options.focusIndex);\n      }\n\n      if (options.focusName) {\n        return options.focusName;\n      }\n\n      if (!options.shouldFocus) {\n        return '';\n      }\n    }\n\n    return \"\".concat(name, \".\").concat(index);\n  };\n\n  var resetFields = function resetFields(index) {\n    return (Array.isArray(index) ? index : [index]).forEach(function (currentIndex) {\n      return set(fieldsRef.current, \"\".concat(name).concat(currentIndex ? \".\".concat(currentIndex) : ''), []);\n    });\n  };\n\n  var setFieldsAndNotify = function setFieldsAndNotify(fieldsValues) {\n    setFields(mapIds(fieldsValues, keyName));\n    fieldArraySubjectRef.current.next({\n      name: name,\n      fields: omitKey(_toConsumableArray(fieldsValues))\n    });\n  };\n\n  var cleanup = function cleanup(ref) {\n    return !compact(get(ref, name, [])).length && unset(ref, name);\n  };\n\n  var updateDirtyFieldsWithDefaultValues = function updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues) {\n    return updatedFieldArrayValues && set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n  };\n\n  var batchStateUpdate = function batchStateUpdate(method, args, updatedFieldValues) {\n    var updatedFormValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    var shouldSet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldUpdateValid = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    if (get(fieldsRef.current, name)) {\n      var output = method(get(fieldsRef.current, name), args.argA, args.argB);\n      shouldSet && set(fieldsRef.current, name, output);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      var _output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\n\n      shouldSet && set(formStateRef.current.errors, name, _output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (readFormStateRef.current.touchedFields && get(formStateRef.current.touchedFields, name)) {\n      var _output2 = method(get(formStateRef.current.touchedFields, name), args.argA, args.argB);\n\n      shouldSet && set(formStateRef.current.touchedFields, name, _output2);\n      cleanup(formStateRef.current.touchedFields);\n    }\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFormValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (shouldUpdateValid && readFormStateRef.current.isValid) {\n      set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\n      cleanup(validFieldsRef.current);\n      set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    formStateSubjectRef.current.next({\n      isDirty: getFormIsDirty(name, omitKey(updatedFormValues)),\n      errors: formStateRef.current.errors,\n      isValid: formStateRef.current.isValid\n    });\n  };\n\n  var append = function append(value, options) {\n    var appendValue = Array.isArray(value) ? value : [value];\n    var updatedFieldValues = [].concat(_toConsumableArray(getCurrentFieldsValues()), _toConsumableArray(appendValue));\n    setFieldsAndNotify(updatedFieldValues);\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      formStateSubjectRef.current.next({\n        isDirty: true,\n        dirtyFields: formStateRef.current.dirtyFields\n      });\n    }\n\n    focusNameRef.current = getFocusDetail(updatedFieldValues.length - 1, options);\n  };\n\n  var prepend$1 = function prepend$1(value, options) {\n    var updatedFieldArrayValues = prepend(getCurrentFieldsValues(), Array.isArray(value) ? value : [value]);\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(prepend, {\n      argA: fillEmptyArray(value)\n    }, updatedFieldArrayValues);\n    focusNameRef.current = getFocusDetail(0, options);\n  };\n\n  var remove = function remove(index) {\n    var fieldValues = getCurrentFieldsValues();\n    var updatedFieldValues = removeArrayAt(fieldValues, index);\n    resetFields(index);\n    batchStateUpdate(removeArrayAt, {\n      argA: index\n    }, updatedFieldValues, removeArrayAt(fieldValues, index), true, true);\n    setFieldsAndNotify(updatedFieldValues);\n  };\n\n  var insert$1 = function insert$1(index, value, options) {\n    var fieldValues = getCurrentFieldsValues();\n    var updatedFieldArrayValues = insert(fieldValues, index, Array.isArray(value) ? value : [value]);\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(insert, {\n      argA: index,\n      argB: fillEmptyArray(value)\n    }, updatedFieldArrayValues, fieldValues && insert(fieldValues, index));\n    focusNameRef.current = getFocusDetail(index, options);\n  };\n\n  var swap = function swap(indexA, indexB) {\n    var fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    batchStateUpdate(swapArrayAt, {\n      argA: indexA,\n      argB: indexB\n    }, undefined, fieldValues, false);\n    setFieldsAndNotify(fieldValues);\n  };\n\n  var move = function move(from, to) {\n    var fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    setFieldsAndNotify(fieldValues);\n    batchStateUpdate(moveArrayAt, {\n      argA: from,\n      argB: to\n    }, undefined, fieldValues, false);\n  };\n\n  useEffect(function () {\n    if (isWatchAllRef.current) {\n      formStateSubjectRef.current.next({});\n    } else {\n      var _iterator10 = _createForOfIteratorHelper(watchFieldsRef.current),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var watchField = _step10.value;\n\n          if (name.startsWith(watchField)) {\n            formStateSubjectRef.current.next({});\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n\n    watchSubjectRef.current.next({\n      name: name\n    });\n    focusNameRef.current && focusFieldBy(fieldsRef.current, function (key) {\n      return key.startsWith(focusNameRef.current);\n    });\n    focusNameRef.current = '';\n  }, [fields, name]);\n  useEffect(function () {\n    var fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next: function next(_ref28) {\n        var inputName = _ref28.name,\n            fields = _ref28.fields,\n            isReset = _ref28.isReset;\n\n        if (isReset) {\n          if (inputName) {\n            var value = getFieldsValues(fieldsRef, defaultValuesRef);\n            set(value, inputName, fields);\n            set(fieldArrayDefaultValuesRef.current, name, fields);\n            setFieldsAndNotify(get(value, name));\n          } else {\n            fieldArrayDefaultValuesRef.current = fields;\n            setFieldsAndNotify(get(fields, name));\n          }\n        }\n      }\n    });\n    return function () {\n      fieldArraySubscription.unsubscribe();\n      unset(fieldArrayDefaultValuesRef.current, name);\n      fieldArrayNamesRef.current.delete(name);\n    };\n  }, []);\n  return {\n    swap: useCallback(swap, [name]),\n    move: useCallback(move, [name]),\n    prepend: useCallback(prepend$1, [name]),\n    append: useCallback(append, [name]),\n    remove: useCallback(remove, [name]),\n    insert: useCallback(insert$1, [name]),\n    fields: fields\n  };\n};\n\nfunction cloneObject(data) {\n  var copy;\n\n  if (isPrimitive(data) || isWeb && (data instanceof File || isHTMLElement(data))) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n\n    var _iterator11 = _createForOfIteratorHelper(data),\n        _step11;\n\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var item = _step11.value;\n        copy.add(item);\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n\n    var _iterator12 = _createForOfIteratorHelper(data.keys()),\n        _step12;\n\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var key = _step12.value;\n        copy.set(key, cloneObject(data.get(key)));\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (var _key in data) {\n    copy[_key] = cloneObject(data[_key]);\n  }\n\n  return copy;\n}\n\nfunction useFormState() {\n  var _ref29 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      control = _ref29.control;\n\n  var methods = useFormContext();\n\n  var _ref30 = control || methods.control,\n      formStateRef = _ref30.formStateRef,\n      formStateSubjectRef = _ref30.formStateSubjectRef,\n      readFormStateRef = _ref30.readFormStateRef;\n\n  var _useState5 = useState(formStateRef.current),\n      _useState6 = _slicedToArray(_useState5, 2),\n      formState = _useState6[0],\n      updateFormState = _useState6[1];\n\n  var readFormState = useRef(cloneObject(readFormStateRef.current));\n  useEffect(function () {\n    var formStateSubscription = formStateSubjectRef.current.subscribe({\n      next: function next(formState) {\n        shouldRenderFormState(formState, readFormState.current) && updateFormState(Object.assign(Object.assign({}, formStateRef.current), formState));\n      }\n    });\n    return function () {\n      return formStateSubscription.unsubscribe();\n    };\n  }, []);\n  return getProxyFormState(isProxyEnabled, formState, readFormStateRef, readFormState, false);\n}\n\nvar getControllerValue = function getControllerValue(event) {\n  return isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isUndefined(event.target.value) ? event.target.checked : event.target.value;\n};\n\nfunction useController(_ref31) {\n  var name = _ref31.name,\n      rules = _ref31.rules,\n      defaultValue = _ref31.defaultValue,\n      control = _ref31.control;\n  var methods = useFormContext();\n\n  var _ref32 = control || methods.control,\n      defaultValuesRef = _ref32.defaultValuesRef,\n      register = _ref32.register,\n      fieldsRef = _ref32.fieldsRef,\n      fieldArrayNamesRef = _ref32.fieldArrayNamesRef,\n      controllerSubjectRef = _ref32.controllerSubjectRef;\n\n  var _register = register(name, rules),\n      _onChange = _register.onChange,\n      _onBlur = _register.onBlur,\n      ref = _register.ref;\n\n  var getInitialValue = function getInitialValue() {\n    return get(fieldsRef.current, name) && isUndefined(get(fieldsRef.current, name)._f.value) || isNameInFieldArray(fieldArrayNamesRef.current, name) ? isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue : get(fieldsRef.current, name)._f.value;\n  };\n\n  var _useState7 = useState(getInitialValue()),\n      _useState8 = _slicedToArray(_useState7, 2),\n      value = _useState8[0],\n      setInputStateValue = _useState8[1];\n\n  var _useFormState = useFormState({\n    control: control || methods.control\n  }),\n      errors = _useFormState.errors,\n      dirtyFields = _useFormState.dirtyFields,\n      touchedFields = _useFormState.touchedFields,\n      isValidating = _useFormState.isValidating;\n\n  useEffect(function () {\n    if (get(fieldsRef.current, name)) {\n      get(fieldsRef.current, name)._f.value = getInitialValue();\n    }\n\n    var controllerSubscription = controllerSubjectRef.current.subscribe({\n      next: function next(values) {\n        return setInputStateValue(get(values, name));\n      }\n    });\n    return function () {\n      return controllerSubscription.unsubscribe();\n    };\n  }, []);\n  return {\n    field: {\n      onChange: function onChange(event) {\n        var value = getControllerValue(event);\n        setInputStateValue(value);\n\n        _onChange({\n          target: {\n            value: value,\n            name: name\n          }\n        });\n      },\n      onBlur: function onBlur() {\n        _onBlur({\n          target: {\n            name: name\n          },\n          type: EVENTS.BLUR\n        });\n      },\n      name: name,\n      value: value,\n      ref: ref\n    },\n    meta: {\n      invalid: !!get(errors, name),\n      isDirty: !!get(dirtyFields, name),\n      isTouched: !!get(touchedFields, name),\n      error: get(errors, name),\n      isValidating: isValidating\n    }\n  };\n}\n\nfunction useWatch(_ref33) {\n  var control = _ref33.control,\n      name = _ref33.name,\n      defaultValue = _ref33.defaultValue;\n  var methods = useFormContext();\n\n  var _ref34 = control || methods.control,\n      watchInternal = _ref34.watchInternal,\n      defaultValuesRef = _ref34.defaultValuesRef,\n      watchSubjectRef = _ref34.watchSubjectRef;\n\n  var _useState9 = useState(isUndefined(defaultValue) ? Array.isArray(name) ? name.reduce(function (previous, inputName) {\n    return Object.assign(Object.assign({}, previous), _defineProperty({}, inputName, get(defaultValuesRef.current, inputName)));\n  }, {}) : isString(name) ? get(defaultValuesRef.current, name) : defaultValuesRef.current : defaultValue),\n      _useState10 = _slicedToArray(_useState9, 2),\n      value = _useState10[0],\n      updateValue = _useState10[1];\n\n  useEffect(function () {\n    var watchSubscription = watchSubjectRef.current.subscribe({\n      next: function next(_ref35) {\n        var inputName = _ref35.name,\n            value = _ref35.value;\n        updateValue(isString(inputName) && name === inputName && !isUndefined(value) ? value : name && isObject(value) ? get(value, name, defaultValue) : watchInternal(name, defaultValue));\n      }\n    });\n    return function () {\n      return watchSubscription.unsubscribe();\n    };\n  }, [name]);\n  return value;\n}\n\nvar Controller = function Controller(props) {\n  return props.render(useController(props));\n}; // Todo: to be removed\n\n\nvar transformToNestObject = function transformToNestObject(data) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  for (var key in data) {\n    !isKey(key) ? set(value, key, data[key]) : value[key] = data[key];\n  }\n\n  return value;\n};\n\nexport { Controller, FormProvider, appendErrors, get, set, transformToNestObject, useController, useFieldArray, useForm, useFormContext, useFormState, useWatch };","map":{"version":3,"sources":["../src/utils/isUndefined.ts","../src/utils/isNullOrUndefined.ts","../src/utils/isObject.ts","../src/utils/compact.ts","../src/utils/get.ts","../src/utils/isKey.ts","../src/utils/stringToPath.ts","../src/utils/set.ts","../src/logic/focusFieldBy.ts","../src/utils/isPrimitive.ts","../src/utils/deepMerge.ts","../src/utils/deepEqual.ts","../src/logic/setFieldArrayDirtyFields.ts","../src/utils/isEmptyObject.ts","../src/constants.ts","../src/logic/shouldRenderFormState.ts","../src/logic/getFieldValueAs.ts","../src/logic/getFieldsValues.ts","../src/logic/getRadioValue.ts","../src/logic/getMultipleSelectValue.ts","../src/utils/isRadioInput.ts","../src/utils/isFileInput.ts","../src/utils/isCheckBoxInput.ts","../src/utils/isMultipleSelect.ts","../src/logic/getCheckboxValue.ts","../src/logic/getFieldValue.ts","../src/logic/isErrorStateChanged.ts","../src/utils/isRegex.ts","../src/logic/getValueAndMessage.ts","../src/utils/isString.ts","../src/utils/isFunction.ts","../src/utils/isBoolean.ts","../src/utils/isMessage.ts","../src/logic/getValidateError.ts","../src/logic/appendErrors.ts","../src/logic/validateField.ts","../src/logic/skipValidation.ts","../src/logic/getNodeParentName.ts","../src/logic/isNameInFieldArray.ts","../src/logic/getProxyFormState.ts","../src/utils/Subject.ts","../src/utils/isWeb.ts","../src/utils/isProxyEnabled.ts","../src/utils/getPath.ts","../src/utils/unset.ts","../src/utils/getValidationModes.ts","../src/utils/isRadioOrCheckbox.ts","../src/utils/isHTMLElement.ts","../src/logic/getFields.ts","../src/useForm.ts","../src/useFormContext.tsx","../src/logic/generateId.ts","../src/logic/mapId.ts","../src/utils/remove.ts","../src/utils/move.ts","../src/utils/swap.ts","../src/utils/prepend.ts","../src/utils/insert.ts","../src/utils/fillEmptyArray.ts","../src/useFieldArray.ts","../src/utils/cloneObject.ts","../src/useFormState.ts","../src/logic/getControllerValue.ts","../src/useController.ts","../src/useWatch.ts","../src/controller.tsx","../src/logic/transformToNestObject.ts"],"names":["React.isValidElement","isCheckBox","getNodeParentName","React.useRef","React.useState","React.useCallback","React.useEffect","React.useMemo","React.createContext","React.useContext","React.createElement","prepend","prependAt","insert","insertAt"],"mappings":"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","sourcesContent":["export default (val: unknown): val is undefined => val === undefined;\n","export default (value: unknown): value is null | undefined => value == null;\n","import isNullOrUndefined from './isNullOrUndefined';\n\nexport const isObjectType = (value: unknown) => typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) &&\n  !Array.isArray(value) &&\n  isObjectType(value) &&\n  !(value instanceof Date);\n","export default (value: any[]) => value.filter(Boolean);\n","import isUndefined from './isUndefined';\nimport isNullOrUndefined from './isNullOrUndefined';\nimport compact from './compact';\n\nexport default (obj: any = {}, path: string, defaultValue?: unknown) => {\n  const result = compact(path.split(/[,[\\].]+?/)).reduce(\n    (result, key) => (isNullOrUndefined(result) ? result : result[key]),\n    obj,\n  );\n\n  return isUndefined(result) || result === obj\n    ? isUndefined(obj[path])\n      ? defaultValue\n      : obj[path]\n    : result;\n};\n","export default (value: string) => /^\\w*$/.test(value);\n","import compact from './compact';\n\nexport default (input: string): string[] =>\n  compact(\n    input\n      .replace(/[\"|']/g, '')\n      .replace(/\\[/g, '.')\n      .replace(/\\]/g, '')\n      .split('.'),\n  );\n","import isObject from './isObject';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport { FieldValues } from '../types';\n\nexport default function set(\n  object: FieldValues,\n  path: string,\n  value?: unknown,\n) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue =\n        isObject(objValue) || Array.isArray(objValue)\n          ? objValue\n          : !isNaN(+tempPath[index + 1])\n          ? []\n          : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport { get } from '../utils';\nimport { FieldRefs, InternalFieldName } from '../types';\n\nconst focusFieldBy = (\n  fields: FieldRefs,\n  callback: (name: string) => boolean,\n  fieldsNames?: Set<InternalFieldName>,\n) => {\n  for (const key of fieldsNames || Object.keys(fields)) {\n    const field = get(fields, key);\n\n    if (field) {\n      const { _f, ...current } = field;\n\n      if (_f && callback(_f.name)) {\n        if (_f.ref.focus && isUndefined(_f.ref.focus())) {\n          break;\n        } else if (_f.refs) {\n          _f.refs[0].focus();\n          break;\n        }\n      } else if (isObject(current)) {\n        focusFieldBy(current, callback);\n      }\n    }\n  }\n};\n\nexport default focusFieldBy;\n","import isNullOrUndefined from './isNullOrUndefined';\nimport { isObjectType } from './isObject';\nimport { Primitive } from '../types';\n\nexport default (value: unknown): value is Primitive =>\n  isNullOrUndefined(value) || !isObjectType(value);\n","import isObject from './isObject';\nimport isPrimitive from './isPrimitive';\n\nexport function deepMerge<\n  T extends Record<keyof T, any>,\n  U extends Record<keyof U, any>\n>(target: T, source: U): T & U {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] =\n        (isObject(targetValue) && isObject(sourceValue)) ||\n        (Array.isArray(targetValue) && Array.isArray(sourceValue))\n          ? deepMerge(targetValue, sourceValue)\n          : sourceValue;\n    } catch {}\n  }\n\n  return target;\n}\n","import * as React from 'react';\nimport isObject from '../utils/isObject';\nimport isPrimitive from './isPrimitive';\n\nexport default function deepEqual(\n  object1: any,\n  object2: any,\n  isErrorObject?: boolean,\n) {\n  if (\n    isPrimitive(object1) ||\n    isPrimitive(object2) ||\n    object1 instanceof Date ||\n    object2 instanceof Date\n  ) {\n    return object1 === object2;\n  }\n\n  if (!React.isValidElement(object1)) {\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const val1 = object1[key];\n\n      if (!(isErrorObject && key === 'ref')) {\n        const val2 = object2[key];\n\n        if (\n          (isObject(val1) || Array.isArray(val1)) &&\n          (isObject(val2) || Array.isArray(val2))\n            ? !deepEqual(val1, val2, isErrorObject)\n            : val1 !== val2\n        ) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n","import { get } from '../utils';\nimport set from '../utils/set';\nimport { deepMerge } from '../utils/deepMerge';\nimport deepEqual from '../utils/deepEqual';\n\nfunction setDirtyFields<\n  T extends Record<string, unknown>[],\n  U extends Record<string, unknown>[],\n  K extends Record<string, boolean | []>\n>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n  parentNode?: K,\n  parentName?: keyof K,\n) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(\n          values[index][key] as T,\n          get(defaultValues[index] || {}, key, []),\n          dirtyFields[index][key] as [],\n          dirtyFields[index],\n          key,\n        );\n      } else {\n        deepEqual(get(defaultValues[index] || {}, key), values[index][key])\n          ? set(dirtyFields[index] || {}, key)\n          : (dirtyFields[index] = {\n              ...dirtyFields[index],\n              [key]: true,\n            });\n      }\n    }\n\n    parentNode &&\n      !dirtyFields.length &&\n      delete parentNode[parentName as keyof K];\n  }\n\n  return dirtyFields;\n}\n\nexport default <T extends U, U extends Record<string, unknown>[]>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n) =>\n  deepMerge(\n    setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)),\n    setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)),\n  );\n","import isObject from './isObject';\nimport { EmptyObject } from '../types';\n\nexport default (value: unknown): value is EmptyObject =>\n  isObject(value) && !Object.keys(value).length;\n","import { ValidationMode } from './types';\n\nexport const EVENTS = {\n  BLUR: 'blur',\n};\n\nexport const VALIDATION_MODE: ValidationMode = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all',\n};\n\nexport const SELECT = 'select';\n\nexport const UNDEFINED = 'undefined';\n\nexport const INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate',\n};\n","import isEmptyObject from '../utils/isEmptyObject';\nimport { ReadFormState } from '../types';\nimport { VALIDATION_MODE } from '../constants';\n\nexport default <T, K extends ReadFormState>(\n  formState: T,\n  readFormStateRef: K,\n  isRoot?: boolean,\n) =>\n  isEmptyObject(formState) ||\n  Object.keys(formState).length >= Object.keys(readFormStateRef).length ||\n  Object.keys(formState).find(\n    (key) =>\n      readFormStateRef[key as keyof ReadFormState] ===\n      (isRoot ? VALIDATION_MODE.all : true),\n  );\n","import { Field } from '../types';\n\nexport default (\n  value: any,\n  { valueAsNumber, valueAsDate, setValueAs }: Field['_f'],\n  shouldReturnAsValue?: boolean,\n) =>\n  shouldReturnAsValue\n    ? valueAsNumber\n      ? value === ''\n        ? NaN\n        : +value\n      : valueAsDate\n      ? new Date(value)\n      : setValueAs\n      ? setValueAs(value)\n      : value\n    : value;\n","import * as React from 'react';\nimport set from '../utils/set';\nimport getFieldValueAs from './getFieldValueAs';\nimport { FieldRefs, FieldValues } from '../types';\n\nconst getFieldsValues = (\n  fieldsRef: React.MutableRefObject<FieldRefs>,\n  defaultValuesRef: React.MutableRefObject<FieldValues>,\n  shouldReturnAsValue?: boolean,\n  output: Record<string, any> = {},\n): any => {\n  for (const name in fieldsRef.current) {\n    const field = fieldsRef.current[name];\n\n    if (field) {\n      const { _f, ...current } = field;\n      set(\n        output,\n        name,\n        _f && !_f.ref.disabled\n          ? getFieldValueAs(_f.value, _f, shouldReturnAsValue)\n          : Array.isArray(field)\n          ? []\n          : {},\n      );\n\n      if (current) {\n        getFieldsValues(\n          {\n            current,\n          },\n          defaultValuesRef,\n          shouldReturnAsValue,\n          output[name],\n        );\n      }\n    }\n  }\n\n  return {\n    ...defaultValuesRef.current,\n    ...output,\n  };\n};\n\nexport default getFieldsValues;\n","type RadioFieldResult = {\n  isValid: boolean;\n  value: number | string | null;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: null,\n};\n\nexport default (options?: HTMLInputElement[]): RadioFieldResult =>\n  Array.isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.checked\n            ? {\n                isValid: true,\n                value: option.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n","export default (\n  options: HTMLOptionElement[] | HTMLOptionsCollection,\n): string[] =>\n  [...options]\n    .filter(({ selected }): boolean => selected)\n    .map(({ value }): string => value);\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'radio';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-multiple`;\n","import isUndefined from '../utils/isUndefined';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: HTMLInputElement[]): CheckboxFieldResult => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.checked)\n        .map(({ value }) => value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    const { checked, value, attributes } = options[0];\n\n    return checked\n      ? // @ts-expect-error\n        attributes && !isUndefined(attributes.value)\n        ? isUndefined(value)\n          ? validResult\n          : { value: value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n","import getRadioValue from './getRadioValue';\nimport getMultipleSelectValue from './getMultipleSelectValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport isFileInput from '../utils/isFileInput';\nimport isCheckBox from '../utils/isCheckBoxInput';\nimport isMultipleSelect from '../utils/isMultipleSelect';\nimport getCheckboxValue from './getCheckboxValue';\nimport getFieldValueAs from './getFieldValueAs';\nimport { Field } from '../types';\n\nexport default function getFieldValue(\n  field?: Field,\n  shouldReturnAsValue?: boolean,\n) {\n  if (field && field._f) {\n    const { ref } = field._f;\n\n    if (ref.disabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field._f.refs).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBox(ref)) {\n      return getCheckboxValue(field._f.refs).value;\n    }\n\n    return getFieldValueAs(ref.value, field._f, shouldReturnAsValue);\n  }\n}\n","import get from '../utils/get';\nimport isUndefined from '../utils/isUndefined';\nimport deepEqual from '../utils/deepEqual';\nimport {\n  FieldValues,\n  InternalFieldName,\n  FieldErrors,\n  FieldNamesMarkedBoolean,\n  FieldError,\n} from '../types';\n\nexport default <TFieldValues extends FieldValues>({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation,\n}: {\n  errors: FieldErrors<TFieldValues>;\n  error: FieldError | undefined;\n  name: InternalFieldName;\n  validFields: FieldNamesMarkedBoolean<TFieldValues>;\n  fieldsWithValidation: FieldNamesMarkedBoolean<TFieldValues>;\n}): boolean => {\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n\n  return (\n    (isValid && !!previousError) ||\n    (!isValid && !deepEqual(previousError, error, true)) ||\n    (isValid && get(fieldsWithValidation, name) && !get(validFields, name))\n  );\n};\n","export default (value: unknown): value is RegExp => value instanceof RegExp;\n","import isObject from '../utils/isObject';\nimport isRegex from '../utils/isRegex';\nimport { ValidationRule } from '../types';\n\nexport default (validationData?: ValidationRule) =>\n  isObject(validationData) && !isRegex(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n      };\n","export default (value: unknown): value is string => typeof value === 'string';\n","export default (value: unknown): value is Function =>\n  typeof value === 'function';\n","export default (value: unknown): value is boolean => typeof value === 'boolean';\n","import * as React from 'react';\nimport isString from '../utils/isString';\nimport { Message } from '../types';\n\nexport default (value: unknown): value is Message =>\n  isString(value) || React.isValidElement(value as JSX.Element);\n","import isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport { FieldError, ValidateResult, Ref } from '../types';\n\nexport default function getValidateError(\n  result: ValidateResult,\n  ref: Ref,\n  type = 'validate',\n): FieldError | void {\n  if (isMessage(result) || (isBoolean(result) && !result)) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref,\n    };\n  }\n}\n","import {\n  InternalFieldName,\n  ValidateResult,\n  InternalFieldErrors,\n} from '../types';\n\nexport default (\n  name: InternalFieldName,\n  validateAllFieldCriteria: boolean,\n  errors: InternalFieldErrors,\n  type: string,\n  message: ValidateResult,\n) =>\n  validateAllFieldCriteria\n    ? {\n        ...errors[name],\n        types: {\n          ...(errors[name] && errors[name]!.types ? errors[name]!.types : {}),\n          [type]: message || true,\n        },\n      }\n    : {};\n","import getRadioValue from './getRadioValue';\nimport getCheckboxValue from './getCheckboxValue';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isRadioInput from '../utils/isRadioInput';\nimport getValueAndMessage from './getValueAndMessage';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isString from '../utils/isString';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isObject from '../utils/isObject';\nimport isFunction from '../utils/isFunction';\nimport isRegex from '../utils/isRegex';\nimport isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport getValidateError from './getValidateError';\nimport appendErrors from './appendErrors';\nimport { INPUT_VALIDATION_RULES } from '../constants';\nimport { Field, Message, FieldError, InternalFieldErrors } from '../types';\n\nexport default async (\n  {\n    _f: {\n      ref,\n      refs,\n      required,\n      maxLength,\n      minLength,\n      min,\n      max,\n      pattern,\n      validate,\n      name,\n      value: inputValue,\n    },\n  }: Field,\n  validateAllFieldCriteria: boolean,\n): Promise<InternalFieldErrors> => {\n  const error: InternalFieldErrors = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty =\n    !inputValue || (Array.isArray(inputValue) && !inputValue.length);\n  const appendErrorsCurry = appendErrors.bind(\n    null,\n    name,\n    validateAllFieldCriteria,\n    error,\n  );\n  const getMinMaxMessage = (\n    exceedMax: boolean,\n    maxLengthMessage: Message,\n    minLengthMessage: Message,\n    maxType = INPUT_VALIDATION_RULES.maxLength,\n    minType = INPUT_VALIDATION_RULES.minLength,\n  ) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = {\n      type: exceedMax ? maxType : minType,\n      message,\n      ref,\n      ...(exceedMax\n        ? appendErrorsCurry(maxType, message)\n        : appendErrorsCurry(minType, message)),\n    };\n  };\n\n  if (\n    required &&\n    ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue))) ||\n      (isBoolean(inputValue) && !inputValue) ||\n      (isCheckBox && !getCheckboxValue(refs).isValid) ||\n      (isRadio && !getRadioValue(refs).isValid))\n  ) {\n    const { value, message } = isMessage(required)\n      ? { value: !!required, message: required }\n      : getValueAndMessage(required);\n\n    if (value) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.required,\n        message,\n        ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (\n    (!isNullOrUndefined(min) || !isNullOrUndefined(max)) &&\n    inputValue !== ''\n  ) {\n    let exceedMax;\n    let exceedMin;\n    const maxOutput = getValueAndMessage(max);\n    const minOutput = getValueAndMessage(min);\n\n    if (!isNaN(inputValue)) {\n      const valueNumber =\n        (ref as HTMLInputElement).valueAsNumber || parseFloat(inputValue);\n      if (!isNullOrUndefined(maxOutput.value)) {\n        exceedMax = valueNumber > maxOutput.value;\n      }\n      if (!isNullOrUndefined(minOutput.value)) {\n        exceedMin = valueNumber < minOutput.value;\n      }\n    } else {\n      const valueDate =\n        (ref as HTMLInputElement).valueAsDate || new Date(inputValue);\n      if (isString(maxOutput.value)) {\n        exceedMax = valueDate > new Date(maxOutput.value);\n      }\n      if (isString(minOutput.value)) {\n        exceedMin = valueDate < new Date(minOutput.value);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        !!exceedMax,\n        maxOutput.message,\n        minOutput.message,\n        INPUT_VALIDATION_RULES.max,\n        INPUT_VALIDATION_RULES.min,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\n    const maxLengthOutput = getValueAndMessage(maxLength);\n    const minLengthOutput = getValueAndMessage(minLength);\n    const exceedMax =\n      !isNullOrUndefined(maxLengthOutput.value) &&\n      inputValue.length > maxLengthOutput.value;\n    const exceedMin =\n      !isNullOrUndefined(minLengthOutput.value) &&\n      inputValue.length < minLengthOutput.value;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        exceedMax,\n        maxLengthOutput.message,\n        minLengthOutput.message,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(inputValue) && pattern && !isEmpty) {\n    const { value: patternValue, message } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(inputValue)) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.pattern,\n        message,\n        ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(inputValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = {\n          ...validateError,\n          ...appendErrorsCurry(\n            INPUT_VALIDATION_RULES.validate,\n            validateError.message,\n          ),\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {} as FieldError;\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(inputValue);\n        const validateError = getValidateError(\n          validateResult,\n          validateRef,\n          key,\n        );\n\n        if (validateError) {\n          validationResult = {\n            ...validateError,\n            ...appendErrorsCurry(key, validateError.message),\n          };\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = {\n          ref: validateRef,\n          ...validationResult,\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n","export default ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll,\n}: {\n  isOnAll?: boolean;\n  isOnBlur?: boolean;\n  isOnChange?: boolean;\n  isReValidateOnBlur?: boolean;\n  isReValidateOnChange?: boolean;\n  isBlurEvent?: boolean;\n  isSubmitted?: boolean;\n  isOnTouch?: boolean;\n  isTouched?: boolean;\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n  return true;\n};\n","export default (name: string) => name.substring(0, name.search(/.\\d/)) || name;\n","import getNodeParentName from './getNodeParentName';\nimport { InternalFieldName } from '../types';\n\nexport default (names: Set<InternalFieldName>, name: InternalFieldName) =>\n  [...names].some((current) => getNodeParentName(name) === current);\n","import * as React from 'react';\nimport { FormState, FormStateProxy, ReadFormState } from '../types';\nimport { VALIDATION_MODE } from '../constants';\n\nexport default <TFieldValues>(\n  isProxyEnabled: boolean,\n  formState: FormState<TFieldValues>,\n  readFormStateRef: React.MutableRefObject<ReadFormState>,\n  localReadFormStateRef?: React.MutableRefObject<ReadFormState>,\n  isRoot = true,\n) =>\n  isProxyEnabled\n    ? new Proxy(formState, {\n        get: (obj, prop: keyof FormStateProxy) => {\n          if (prop in obj) {\n            if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\n              readFormStateRef.current[prop] = isRoot\n                ? VALIDATION_MODE.all\n                : true;\n            }\n            localReadFormStateRef &&\n              (localReadFormStateRef.current[prop] = true);\n            return obj[prop];\n          }\n\n          return undefined;\n        },\n      })\n    : formState;\n","export type Observer<T> = {\n  next: (value: T) => void;\n};\n\ntype TearDown = () => void;\n\nexport type SubjectType<T> = {\n  next: (value: T) => void;\n  subscribe: (\n    value: Observer<T>,\n  ) => {\n    unsubscribe: TearDown;\n  };\n};\n\nexport class Subscription {\n  private tearDowns: TearDown[] = [];\n\n  add(tearDown: TearDown) {\n    this.tearDowns.push(tearDown);\n  }\n\n  unsubscribe() {\n    for (const teardown of this.tearDowns) {\n      teardown();\n    }\n    this.tearDowns = [];\n  }\n}\n\nclass Subscriber<T> implements Observer<T> {\n  closed = false;\n\n  constructor(private observer: Observer<T>, subscription: Subscription) {\n    subscription.add(() => (this.closed = true));\n  }\n\n  next(value: T) {\n    if (!this.closed) {\n      this.observer.next(value);\n    }\n  }\n}\n\nexport default class Subject<T> {\n  observers: Observer<T>[];\n\n  constructor() {\n    this.observers = [];\n  }\n\n  next(value: T) {\n    for (const observer of this.observers) {\n      observer.next(value);\n    }\n  }\n\n  subscribe(observer: Observer<T>) {\n    const subscription = new Subscription();\n    const subscriber = new Subscriber(observer, subscription);\n    this.observers.push(subscriber);\n\n    return subscription;\n  }\n\n  unsubscribe() {\n    this.observers = [];\n  }\n}\n","import { UNDEFINED } from '../constants';\n\nexport default typeof window !== UNDEFINED && typeof document !== UNDEFINED;\n","import isWeb from './isWeb';\nimport { UNDEFINED } from '../constants';\n\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nexport default isProxyEnabled;\n","import isPrimitive from './isPrimitive';\nimport { FieldName } from '../types';\n\nexport const getPath = <TFieldValues>(\n  rootPath: FieldName<TFieldValues>,\n  values: any,\n  paths: FieldName<TFieldValues>[] = [],\n): FieldName<TFieldValues>[] => {\n  for (const property in values) {\n    isPrimitive(values[property])\n      ? paths.push(`${rootPath}.${property}` as FieldName<TFieldValues>)\n      : getPath(\n          `${rootPath}.${property}` as FieldName<TFieldValues>,\n          values[property],\n          paths,\n        );\n  }\n\n  return paths;\n};\n","import isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport isEmptyObject from './isEmptyObject';\nimport isObject from './isObject';\nimport isUndefined from './isUndefined';\nimport isBoolean from './isBoolean';\n\nfunction baseGet(object: any, updatePath: (string | number)[]) {\n  const length = updatePath.slice(0, -1).length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nexport default function unset(object: any, path: string) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject =\n    updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (\n        currentPathsLength === index &&\n        ((isObject(objectRef) && isEmptyObject(objectRef)) ||\n          (Array.isArray(objectRef) &&\n            !objectRef.filter(\n              (data) =>\n                (isObject(data) && !isEmptyObject(data)) || isBoolean(data),\n            ).length))\n      ) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n","import { VALIDATION_MODE } from '../constants';\nimport { Mode } from '../types';\n\nexport default (\n  mode?: Mode,\n): {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n  isOnTouch: boolean;\n} => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched,\n});\n","import isRadioInput from './isRadioInput';\nimport isCheckBoxInput from './isCheckBoxInput';\nimport { FieldElement } from '../types';\n\nexport default (ref: FieldElement): ref is HTMLInputElement =>\n  isRadioInput(ref) || isCheckBoxInput(ref);\n","export default (value: any): value is HTMLElement =>\n  value instanceof HTMLElement;\n","import { Field, FieldRefs, InternalFieldName } from '../types';\nimport { get } from '../utils';\nimport isKey from '../utils/isKey';\nimport set from '../utils/set';\n\nexport default function getFields(\n  fieldsNames: Set<InternalFieldName> | InternalFieldName[],\n  fieldsRefs: FieldRefs,\n) {\n  const currentFields: Record<InternalFieldName, Field['_f']> = {};\n\n  for (const name of fieldsNames) {\n    const field = get(fieldsRefs, name) as Field | undefined;\n\n    if (field) {\n      !isKey(name)\n        ? set(currentFields, name, field._f)\n        : (currentFields[name] = field._f);\n    }\n  }\n\n  return currentFields;\n}\n","import * as React from 'react';\nimport focusFieldBy from './logic/focusFieldBy';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport shouldRenderFormState from './logic/shouldRenderFormState';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldValue from './logic/getFieldValue';\nimport isErrorStateChanged from './logic/isErrorStateChanged';\nimport validateField from './logic/validateField';\nimport skipValidation from './logic/skipValidation';\nimport getNodeParentName from './logic/getNodeParentName';\nimport deepEqual from './utils/deepEqual';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport getProxyFormState from './logic/getProxyFormState';\nimport Subject, { Subscription } from './utils/Subject';\nimport isProxyEnabled from './utils/isProxyEnabled';\nimport isCheckBoxInput from './utils/isCheckBoxInput';\nimport isEmptyObject from './utils/isEmptyObject';\nimport isRadioInput from './utils/isRadioInput';\nimport isFileInput from './utils/isFileInput';\nimport { getPath } from './utils/getPath';\nimport isFunction from './utils/isFunction';\nimport isString from './utils/isString';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport unset from './utils/unset';\nimport getValidationModes from './utils/getValidationModes';\nimport isMultipleSelect from './utils/isMultipleSelect';\nimport compact from './utils/compact';\nimport isNullOrUndefined from './utils/isNullOrUndefined';\nimport isRadioOrCheckboxFunction from './utils/isRadioOrCheckbox';\nimport isWeb from './utils/isWeb';\nimport isHTMLElement from './utils/isHTMLElement';\nimport getFields from './logic/getFields';\nimport { EVENTS, UNDEFINED, VALIDATION_MODE } from './constants';\nimport {\n  UseFormMethods,\n  FieldValues,\n  UnpackNestedValue,\n  FieldName,\n  InternalFieldName,\n  Field,\n  FieldRefs,\n  UseFormProps,\n  RegisterOptions,\n  ReadFormState,\n  Ref,\n  SetValueConfig,\n  FormState,\n  FieldNamesMarkedBoolean,\n  DeepPartial,\n  InternalNameSet,\n  DefaultValues,\n  FieldError,\n  SetFieldValue,\n  FieldArrayDefaultValues,\n  RegisterCallback,\n  FieldPath,\n  WatchObserver,\n  FieldPathValue,\n  FieldPathValues,\n  KeepStateOptions,\n  EventType,\n  UseFormTrigger,\n  UseFormSetValue,\n  UseFormUnregister,\n  UseFormClearErrors,\n  UseFormSetError,\n  UseFormRegister,\n  UseFormHandleSubmit,\n  UseFormReset,\n  WatchInternal,\n  GetFormIsDirty,\n  HandleChange,\n} from './types';\n\nconst isWindowUndefined = typeof window === UNDEFINED;\n\nexport function useForm<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext extends object = object\n>({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {} as DefaultValues<TFieldValues>,\n  shouldFocusError = true,\n  criteriaMode,\n}: UseFormProps<TFieldValues, TContext> = {}): UseFormMethods<TFieldValues> {\n  const fieldsRef = React.useRef<FieldRefs>({});\n  const fieldsNamesRef = React.useRef<Set<InternalFieldName>>(new Set());\n  const formStateSubjectRef = React.useRef(\n    new Subject<Partial<FormState<TFieldValues>>>(),\n  );\n  const watchSubjectRef = React.useRef(\n    new Subject<{\n      name?: InternalFieldName;\n      type?: EventType;\n      value?: unknown;\n    }>(),\n  );\n  const controllerSubjectRef = React.useRef(\n    new Subject<DefaultValues<TFieldValues>>(),\n  );\n  const fieldArraySubjectRef = React.useRef(\n    new Subject<{\n      name?: InternalFieldName;\n      fields: any;\n      isReset?: boolean;\n    }>(),\n  );\n  const fieldArrayUpdatedValuesRef = React.useRef<{\n    name?: InternalFieldName;\n    fields?: DeepPartial<TFieldValues>;\n  }>({});\n  const fieldArrayDefaultValuesRef = React.useRef<FieldArrayDefaultValues>({});\n  const watchFieldsRef = React.useRef<InternalNameSet>(new Set());\n  const isMountedRef = React.useRef(false);\n  const fieldsWithValidationRef = React.useRef<\n    FieldNamesMarkedBoolean<TFieldValues>\n  >({});\n  const validFieldsRef = React.useRef<FieldNamesMarkedBoolean<TFieldValues>>(\n    {},\n  );\n  const defaultValuesRef = React.useRef<DefaultValues<TFieldValues>>(\n    defaultValues,\n  );\n  const isWatchAllRef = React.useRef(false);\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef<InternalNameSet>(new Set());\n  const validationMode = getValidationModes(mode);\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = React.useState<FormState<TFieldValues>>({\n    isDirty: false,\n    isValidating: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touchedFields: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !validationMode.isOnSubmit,\n    errors: {},\n  });\n  const readFormStateRef = React.useRef<ReadFormState>({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touchedFields: !isProxyEnabled || validationMode.isOnTouch,\n    isValidating: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n    errors: !isProxyEnabled,\n  });\n  const formStateRef = React.useRef(formState);\n\n  contextRef.current = context;\n  resolverRef.current = resolver;\n\n  const getIsValid = () =>\n    (formStateRef.current.isValid =\n      deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\n      isEmptyObject(formStateRef.current.errors));\n\n  const shouldRenderBaseOnError = React.useCallback(\n    (\n      name: InternalFieldName,\n      error?: FieldError,\n      shouldRender: boolean | null = false,\n      state: {\n        dirty?: FieldNamesMarkedBoolean<TFieldValues>;\n        isDirty?: boolean;\n        touched?: FieldNamesMarkedBoolean<TFieldValues>;\n      } = {},\n      isValid?: boolean,\n    ): boolean | void => {\n      let shouldReRender =\n        shouldRender ||\n        isErrorStateChanged<TFieldValues>({\n          errors: formStateRef.current.errors,\n          error,\n          name,\n          validFields: validFieldsRef.current,\n          fieldsWithValidation: fieldsWithValidationRef.current,\n        });\n      const previousError = get(formStateRef.current.errors, name);\n\n      if (error) {\n        unset(validFieldsRef.current, name);\n        shouldReRender =\n          shouldReRender ||\n          !previousError ||\n          !deepEqual(previousError, error, true);\n        set(formStateRef.current.errors, name, error);\n      } else {\n        if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n          set(validFieldsRef.current, name, true);\n          shouldReRender = shouldReRender || previousError;\n        }\n\n        unset(formStateRef.current.errors, name);\n      }\n\n      if (\n        (shouldReRender && !isNullOrUndefined(shouldRender)) ||\n        !isEmptyObject(state)\n      ) {\n        formStateSubjectRef.current.next({\n          ...state,\n          isValid: resolverRef.current ? isValid : getIsValid(),\n          errors: formStateRef.current.errors,\n        });\n      }\n\n      formStateSubjectRef.current.next({\n        isValidating: false,\n      });\n    },\n    [],\n  );\n\n  const setFieldValue = React.useCallback(\n    (name: InternalFieldName, rawValue: SetFieldValue<TFieldValues>) => {\n      const { _f } = get(fieldsRef.current, name) as Field;\n\n      if (_f) {\n        const { ref, refs } = _f;\n        const value =\n          isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\n            ? ''\n            : rawValue;\n        _f.value = rawValue;\n\n        if (isRadioInput(ref)) {\n          (refs || []).forEach(\n            (radioRef: HTMLInputElement) =>\n              (radioRef.checked = radioRef.value === value),\n          );\n        } else if (isFileInput(ref) && !isString(value)) {\n          ref.files = value as FileList;\n        } else if (isMultipleSelect(ref)) {\n          [...ref.options].forEach(\n            (selectRef) =>\n              (selectRef.selected = (value as string[]).includes(\n                selectRef.value,\n              )),\n          );\n        } else if (isCheckBoxInput(ref) && refs) {\n          refs.length > 1\n            ? refs.forEach(\n                (checkboxRef) =>\n                  (checkboxRef.checked = Array.isArray(value)\n                    ? !!(value as []).find(\n                        (data: string) => data === checkboxRef.value,\n                      )\n                    : value === checkboxRef.value),\n              )\n            : (refs[0].checked = !!value);\n        } else {\n          ref.value = value;\n        }\n      }\n    },\n    [],\n  );\n\n  const getFormIsDirty: GetFormIsDirty = React.useCallback((name, data) => {\n    if (readFormStateRef.current.isDirty) {\n      const formValues = getValues();\n\n      name && data && set(formValues, name, data);\n\n      return !deepEqual(formValues, defaultValuesRef.current);\n    }\n\n    return false;\n  }, []);\n\n  const updateAndGetDirtyState = React.useCallback(\n    (\n      name: InternalFieldName,\n      shouldRender = true,\n    ): Partial<\n      Pick<FormState<TFieldValues>, 'dirtyFields' | 'isDirty' | 'touchedFields'>\n    > => {\n      if (\n        readFormStateRef.current.isDirty ||\n        readFormStateRef.current.dirtyFields\n      ) {\n        const isFieldDirty = !deepEqual(\n          get(defaultValuesRef.current, name),\n          getFieldValue(get(fieldsRef.current, name) as Field, true),\n        );\n        const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n        const previousIsDirty = formStateRef.current.isDirty;\n\n        isFieldDirty\n          ? set(formStateRef.current.dirtyFields, name, true)\n          : unset(formStateRef.current.dirtyFields, name);\n\n        const state = {\n          isDirty: getFormIsDirty(),\n          dirtyFields: formStateRef.current.dirtyFields,\n        };\n\n        const isChanged =\n          (readFormStateRef.current.isDirty &&\n            previousIsDirty !== state.isDirty) ||\n          (readFormStateRef.current.dirtyFields &&\n            isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\n\n        isChanged && shouldRender && formStateSubjectRef.current.next(state);\n\n        return isChanged ? state : {};\n      }\n\n      return {};\n    },\n    [],\n  );\n\n  const executeValidation = React.useCallback(\n    async (\n      name: InternalFieldName,\n      skipReRender?: boolean | null,\n    ): Promise<boolean> => {\n      const error = (\n        await validateField(\n          get(fieldsRef.current, name) as Field,\n          isValidateAllFieldCriteria,\n        )\n      )[name];\n\n      shouldRenderBaseOnError(name, error, skipReRender);\n\n      return isUndefined(error);\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const executeSchemaOrResolverValidation = React.useCallback(\n    async (\n      names: InternalFieldName[],\n      currentNames: FieldName<TFieldValues>[] = [],\n    ) => {\n      const { errors } = await resolverRef.current!(\n        getFieldsValues(fieldsRef, defaultValuesRef, true),\n        contextRef.current,\n        {\n          criteriaMode,\n          names: currentNames,\n          fields: getFields(fieldsNamesRef.current, fieldsRef.current),\n        },\n      );\n\n      for (const name of names) {\n        const error = get(errors, name);\n        error\n          ? set(formStateRef.current.errors, name, error)\n          : unset(formStateRef.current.errors, name);\n      }\n\n      return errors;\n    },\n    [shouldRenderBaseOnError, criteriaMode],\n  );\n\n  const validateForm = async (fieldsRef: FieldRefs) => {\n    for (const name in fieldsRef) {\n      const field = fieldsRef[name];\n\n      if (field) {\n        const { _f, ...current } = field;\n\n        if (_f) {\n          const fieldError = await validateField(\n            field,\n            isValidateAllFieldCriteria,\n          );\n\n          if (fieldError[field._f.name]) {\n            set(\n              formStateRef.current.errors,\n              field._f.name,\n              fieldError[field._f.name],\n            );\n            unset(validFieldsRef.current, field._f.name);\n          } else if (get(fieldsWithValidationRef.current, field._f.name)) {\n            set(validFieldsRef.current, field._f.name, true);\n            unset(formStateRef.current.errors, field._f.name);\n          }\n        }\n\n        current && (await validateForm(current));\n      }\n    }\n  };\n\n  const trigger: UseFormTrigger<TFieldValues> = React.useCallback(\n    async (name) => {\n      const fields = isUndefined(name)\n        ? Object.keys(fieldsRef.current)\n        : Array.isArray(name)\n        ? name\n        : [name];\n      let isValid;\n\n      formStateSubjectRef.current.next({\n        isValidating: true,\n      });\n\n      if (resolver) {\n        isValid = isEmptyObject(\n          await executeSchemaOrResolverValidation(\n            fields,\n            isUndefined(name)\n              ? undefined\n              : (fields as FieldName<TFieldValues>[]),\n          ),\n        );\n      } else {\n        isUndefined(name)\n          ? await validateForm(fieldsRef.current)\n          : await Promise.all(\n              fields.map(async (data) => await executeValidation(data, null)),\n            );\n      }\n\n      formStateSubjectRef.current.next({\n        errors: formStateRef.current.errors,\n        isValidating: false,\n        isValid: resolver ? isValid : getIsValid(),\n      });\n    },\n    [executeSchemaOrResolverValidation, executeValidation],\n  );\n\n  const setInternalValues = React.useCallback(\n    (\n      name: FieldName<TFieldValues>,\n      value: SetFieldValue<TFieldValues>,\n      { shouldDirty, shouldValidate }: SetValueConfig,\n    ) => {\n      const data = {};\n      set(data, name, value);\n\n      for (const fieldName of getPath(name, value)) {\n        if (get(fieldsRef.current, fieldName)) {\n          setFieldValue(fieldName, get(data, fieldName));\n          shouldDirty && updateAndGetDirtyState(fieldName);\n          shouldValidate && trigger(fieldName as FieldName<TFieldValues>);\n        }\n      }\n    },\n    [trigger, setFieldValue, updateAndGetDirtyState],\n  );\n\n  const setInternalValue = React.useCallback(\n    (\n      name: FieldName<TFieldValues>,\n      value: SetFieldValue<TFieldValues>,\n      options: SetValueConfig,\n    ) => {\n      const field = get(fieldsRef.current, name);\n\n      if (field && field._f) {\n        setFieldValue(name, value);\n        options.shouldDirty && updateAndGetDirtyState(name);\n        options.shouldValidate && trigger(name as FieldName<TFieldValues>);\n      } else {\n        setInternalValues(name, value, options);\n\n        if (fieldArrayNamesRef.current.has(name)) {\n          fieldArraySubjectRef.current.next({\n            fields: value,\n            name,\n            isReset: true,\n          });\n\n          if (\n            (readFormStateRef.current.isDirty ||\n              readFormStateRef.current.dirtyFields) &&\n            options.shouldDirty\n          ) {\n            set(\n              formStateRef.current.dirtyFields,\n              name,\n              setFieldArrayDirtyFields(\n                value,\n                get(defaultValuesRef.current, name, []),\n                get(formStateRef.current.dirtyFields, name, []),\n              ),\n            );\n\n            formStateSubjectRef.current.next({\n              dirtyFields: formStateRef.current.dirtyFields,\n              isDirty: getFormIsDirty(name, value),\n            });\n          }\n        }\n      }\n    },\n    [updateAndGetDirtyState, setFieldValue, setInternalValues],\n  );\n\n  const isFieldWatched = <T extends FieldName<TFieldValues>>(name: T) =>\n    isWatchAllRef.current ||\n    watchFieldsRef.current.has(name) ||\n    watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const updateValueAndGetDefault = (name: InternalFieldName) => {\n    let defaultValue;\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const field = get(fieldsRef.current, name) as Field;\n\n    if (\n      field &&\n      (!isEmptyObject(defaultValuesRef.current) || !isUndefined(field._f.value))\n    ) {\n      defaultValue = isUndefined(field._f.value)\n        ? get(defaultValuesRef.current, name)\n        : field._f.value;\n\n      if (!isUndefined(defaultValue) && !isFieldArray) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    return defaultValue;\n  };\n\n  const setValue: UseFormSetValue<TFieldValues> = (name, value, options) => {\n    setInternalValue(name, value, options || {});\n    isFieldWatched(name) && formStateSubjectRef.current.next({});\n    watchSubjectRef.current.next({ name, value });\n  };\n\n  const handleChange: HandleChange = React.useCallback(\n    async ({ type, target, target: { value, type: inputType } }) => {\n      let name = (target as Ref)!.name;\n      let error;\n      let isValid;\n      const field = get(fieldsRef.current, name) as Field;\n\n      if (field) {\n        const inputValue = inputType ? getFieldValue(field) : value;\n        const isBlurEvent = type === EVENTS.BLUR;\n        const {\n          isOnBlur: isReValidateOnBlur,\n          isOnChange: isReValidateOnChange,\n        } = getValidationModes(reValidateMode);\n        const shouldSkipValidation = skipValidation({\n          isBlurEvent,\n          isTouched: !!get(formStateRef.current.touchedFields, name),\n          isSubmitted: formStateRef.current.isSubmitted,\n          isReValidateOnBlur,\n          isReValidateOnChange,\n          ...validationMode,\n        });\n        const isWatched =\n          !isBlurEvent && isFieldWatched(name as FieldName<TFieldValues>);\n\n        if (!isUndefined(inputValue)) {\n          field._f.value = inputValue;\n        }\n\n        const state = updateAndGetDirtyState(name, false);\n\n        if (\n          isBlurEvent &&\n          readFormStateRef.current.touchedFields &&\n          !get(formStateRef.current.touchedFields, name)\n        ) {\n          set(formStateRef.current.touchedFields, name, true);\n          state.touchedFields = formStateRef.current.touchedFields;\n        }\n\n        let shouldRender = !isEmptyObject(state) || isWatched;\n\n        if (shouldSkipValidation) {\n          !isBlurEvent &&\n            watchSubjectRef.current.next({\n              name,\n              type,\n              value: inputValue,\n            });\n          return (\n            shouldRender &&\n            formStateSubjectRef.current.next(isWatched ? {} : state)\n          );\n        }\n\n        formStateSubjectRef.current.next({\n          isValidating: true,\n        });\n\n        if (resolverRef.current) {\n          const { errors } = await resolverRef.current(\n            getFieldsValues(fieldsRef, defaultValuesRef, true),\n            contextRef.current,\n            {\n              criteriaMode,\n              fields: getFields([name], fieldsRef.current),\n              names: [name as FieldName<TFieldValues>],\n            },\n          );\n          const previousFormIsValid = formStateRef.current.isValid;\n          error = get(errors, name);\n\n          if (isCheckBoxInput(target as Ref) && !error) {\n            const parentNodeName = getNodeParentName(name);\n            const currentError = get(errors, parentNodeName, {});\n            currentError.type && currentError.message && (error = currentError);\n\n            if (\n              currentError ||\n              get(formStateRef.current.errors, parentNodeName)\n            ) {\n              name = parentNodeName;\n            }\n          }\n\n          isValid = isEmptyObject(errors);\n\n          previousFormIsValid !== isValid && (shouldRender = true);\n        } else {\n          error = (await validateField(field, isValidateAllFieldCriteria))[\n            name\n          ];\n        }\n\n        !isBlurEvent &&\n          watchSubjectRef.current.next({\n            name,\n            type,\n            value: inputValue,\n          });\n        shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n      }\n    },\n    [],\n  );\n\n  function getValues(): UnpackNestedValue<TFieldValues>;\n  function getValues<TName extends FieldPath<TFieldValues>>(\n    fieldName: TName,\n  ): FieldPathValue<TFieldValues, TName>;\n  function getValues<TName extends FieldPath<TFieldValues>[]>(\n    fieldNames: TName,\n  ): FieldPathValues<TFieldValues, TName>;\n  function getValues(\n    fieldNames?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[],\n  ) {\n    const values = isMountedRef.current\n      ? getFieldsValues(fieldsRef, defaultValuesRef)\n      : defaultValues;\n\n    if (isUndefined(fieldNames)) {\n      return values;\n    }\n\n    if (isString(fieldNames)) {\n      return get(values, fieldNames as InternalFieldName);\n    }\n\n    return fieldNames.map((name) => get(values, name as InternalFieldName));\n  }\n\n  const updateIsValid = React.useCallback(\n    async (values = {}) => {\n      if (resolver) {\n        const { errors } = await resolverRef.current!(\n          {\n            ...getFieldsValues(fieldsRef, defaultValuesRef, true),\n            ...values,\n          },\n          contextRef.current,\n          {\n            criteriaMode,\n            fields: getFields(fieldsNamesRef.current, fieldsRef.current),\n          },\n        );\n        const isValid = isEmptyObject(errors);\n\n        formStateRef.current.isValid !== isValid &&\n          formStateSubjectRef.current.next({\n            isValid,\n          });\n      } else {\n        getIsValid();\n      }\n    },\n    [criteriaMode],\n  );\n\n  const clearErrors: UseFormClearErrors<TFieldValues> = (name) => {\n    name &&\n      (Array.isArray(name) ? name : [name]).forEach((inputName) =>\n        unset(formStateRef.current.errors, inputName),\n      );\n\n    formStateSubjectRef.current.next({\n      errors: name ? formStateRef.current.errors : {},\n    });\n  };\n\n  const setError: UseFormSetError<TFieldValues> = (name, error, options) => {\n    const ref = ((get(fieldsRef.current, name) as Field) || { _f: {} })._f.ref;\n\n    set(formStateRef.current.errors, name, {\n      ...error,\n      ref,\n    });\n\n    formStateSubjectRef.current.next({\n      errors: formStateRef.current.errors,\n      isValid: false,\n    });\n\n    options && options.shouldFocus && ref && ref.focus && ref.focus();\n  };\n\n  const watchInternal: WatchInternal = React.useCallback(\n    (fieldNames, defaultValue, isGlobal) => {\n      const { fields, name } = fieldArrayUpdatedValuesRef.current;\n      const isArrayNames = Array.isArray(fieldNames);\n      let fieldValues = isMountedRef.current\n        ? getValues()\n        : isUndefined(defaultValue)\n        ? defaultValuesRef.current\n        : isArrayNames\n        ? defaultValue || {}\n        : { [fieldNames as string]: defaultValue };\n\n      if (fields) {\n        name ? set(fieldValues, name, fields) : (fieldValues = fields);\n\n        fieldArrayUpdatedValuesRef.current = {\n          fields: undefined,\n          name: undefined,\n        };\n      }\n\n      if (isUndefined(fieldNames)) {\n        isWatchAllRef.current = true;\n        return fieldValues;\n      }\n\n      const result = [];\n\n      for (const fieldName of isArrayNames ? fieldNames : [fieldNames]) {\n        isGlobal && watchFieldsRef.current.add(fieldName as string);\n        result.push(get(fieldValues, fieldName as string));\n      }\n\n      return isArrayNames ? result : result[0];\n    },\n    [],\n  );\n\n  function watch(): UnpackNestedValue<TFieldValues>;\n  function watch<TName extends FieldPath<TFieldValues>>(\n    fieldName: TName,\n    defaultValue?: FieldPathValue<TFieldValues, TName>,\n  ): FieldPathValue<TFieldValues, TName>;\n  function watch<TName extends FieldPath<TFieldValues>[]>(\n    fieldName: TName,\n    defaultValue?: FieldPathValues<TFieldValues, TName>,\n  ): FieldPathValues<TFieldValues, TName>;\n  function watch(\n    callback: WatchObserver,\n    defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ): Subscription;\n  function watch(\n    fieldName?:\n      | FieldPath<TFieldValues>\n      | FieldPath<TFieldValues>[]\n      | WatchObserver,\n    defaultValue?: unknown,\n  ) {\n    if (isFunction(fieldName)) {\n      return watchSubjectRef.current.subscribe({\n        next: (info) => fieldName(watchInternal(undefined, defaultValue), info),\n      });\n    }\n\n    return watchInternal(fieldName as string | string[], defaultValue, true);\n  }\n\n  const unregister: UseFormUnregister<TFieldValues> = (name, options = {}) => {\n    for (const inputName of name\n      ? Array.isArray(name)\n        ? name\n        : [name]\n      : Object.keys(fieldsNamesRef.current)) {\n      fieldsNamesRef.current.delete(inputName);\n\n      if (get(fieldsRef.current, inputName) as Field) {\n        if (!options.keepIsValid) {\n          unset(fieldsWithValidationRef.current, inputName);\n          unset(validFieldsRef.current, inputName);\n        }\n        !options.keepValues && unset(formStateRef.current.errors, inputName);\n        !options.keepErrors && unset(fieldsRef.current, inputName);\n        !options.keepDirty &&\n          unset(formStateRef.current.dirtyFields, inputName);\n        !options.keepTouched &&\n          unset(formStateRef.current.touchedFields, inputName);\n        !options.keepDefaultValues &&\n          unset(defaultValuesRef.current, inputName);\n\n        watchSubjectRef.current.next({\n          name: inputName,\n        });\n      }\n    }\n\n    formStateSubjectRef.current.next({\n      ...formStateRef.current,\n      ...(!options.keepDirty ? {} : { isDirty: getFormIsDirty() }),\n      ...(resolver ? {} : { isValid: getIsValid() }),\n    });\n\n    if (!options.keepIsValid) {\n      updateIsValid();\n    }\n  };\n\n  const registerFieldRef = (\n    name: InternalFieldName,\n    ref: HTMLInputElement,\n    options?: RegisterOptions,\n  ): ((name: InternalFieldName) => void) | void => {\n    let field = get(fieldsRef.current, name) as Field;\n\n    if (field) {\n      const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n\n      if (\n        (isRadioOrCheckbox\n          ? Array.isArray(field._f.refs) &&\n            compact(field._f.refs).find(\n              (option) => ref.value === option.value && option === ref,\n            )\n          : ref === field._f.ref) ||\n        !field\n      ) {\n        return;\n      }\n\n      field = {\n        _f: isRadioOrCheckbox\n          ? {\n              ...field._f,\n              refs: [\n                ...compact(field._f.refs || []).filter(\n                  (ref) => isHTMLElement(ref) && document.contains(ref),\n                ),\n                ref,\n              ],\n              ref: { type: ref.type, name },\n            }\n          : {\n              ...field._f,\n              ref,\n            },\n      };\n\n      set(fieldsRef.current, name, field);\n\n      const defaultValue = updateValueAndGetDefault(name);\n\n      if (\n        isRadioOrCheckbox && Array.isArray(defaultValue)\n          ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue)\n          : true\n      ) {\n        get(fieldsRef.current, name)._f.value = getFieldValue(\n          get(fieldsRef.current, name),\n        );\n      }\n\n      if (options) {\n        if (\n          !validationMode.isOnSubmit &&\n          field &&\n          readFormStateRef.current.isValid\n        ) {\n          validateField(field, isValidateAllFieldCriteria).then((error) => {\n            isEmptyObject(error)\n              ? set(validFieldsRef.current, name, true)\n              : unset(validFieldsRef.current, name);\n\n            formStateRef.current.isValid &&\n              !isEmptyObject(error) &&\n              setFormState({ ...formStateRef.current, isValid: getIsValid() });\n          });\n        }\n      }\n    }\n  };\n\n  const register: UseFormRegister<TFieldValues> = React.useCallback(\n    (name, options) => {\n      set(fieldsRef.current, name, {\n        _f: {\n          ...(get(fieldsRef.current, name)\n            ? {\n                ref: get(fieldsRef.current, name)._f.ref,\n                ...get(fieldsRef.current, name)._f,\n              }\n            : { ref: { name } }),\n          name,\n          ...options,\n        },\n      });\n      options && set(fieldsWithValidationRef.current, name, true);\n      fieldsNamesRef.current.add(name);\n\n      updateValueAndGetDefault(name);\n\n      return isWindowUndefined\n        ? ({} as RegisterCallback)\n        : {\n            name,\n            onChange: handleChange,\n            onBlur: handleChange,\n            ref: (ref: HTMLInputElement | null) =>\n              ref && registerFieldRef(name, ref, options),\n          };\n    },\n    [defaultValuesRef.current],\n  );\n\n  const handleSubmit: UseFormHandleSubmit<TFieldValues> = React.useCallback(\n    (onValid, onInvalid) => async (e) => {\n      if (e && e.preventDefault) {\n        e.preventDefault();\n        e.persist();\n      }\n      let fieldValues = getFieldsValues(fieldsRef, defaultValuesRef, true);\n\n      formStateSubjectRef.current.next({\n        isSubmitting: true,\n      });\n\n      try {\n        if (resolverRef.current) {\n          const { errors, values } = await resolverRef.current(\n            fieldValues,\n            contextRef.current,\n            {\n              criteriaMode,\n              fields: getFields(fieldsNamesRef.current, fieldsRef.current),\n            },\n          );\n          formStateRef.current.errors = errors;\n          fieldValues = values;\n        } else {\n          await validateForm(fieldsRef.current);\n        }\n\n        if (\n          isEmptyObject(formStateRef.current.errors) &&\n          Object.keys(formStateRef.current.errors).every((name) =>\n            get(fieldValues, name),\n          )\n        ) {\n          formStateSubjectRef.current.next({\n            errors: {},\n            isSubmitting: true,\n          });\n          await onValid(fieldValues, e);\n        } else {\n          onInvalid && (await onInvalid(formStateRef.current.errors, e));\n          shouldFocusError &&\n            focusFieldBy(\n              fieldsRef.current,\n              (key: string) => get(formStateRef.current.errors, key),\n              fieldsNamesRef.current,\n            );\n        }\n      } finally {\n        formStateRef.current.isSubmitting = false;\n        formStateSubjectRef.current.next({\n          isSubmitted: true,\n          isSubmitting: false,\n          isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n          submitCount: formStateRef.current.submitCount + 1,\n          errors: formStateRef.current.errors,\n        });\n      }\n    },\n    [shouldFocusError, isValidateAllFieldCriteria, criteriaMode],\n  );\n\n  const resetFromState = ({\n    keepErrors,\n    keepDirty,\n    keepIsSubmitted,\n    keepTouched,\n    keepIsValid,\n    keepSubmitCount,\n  }: KeepStateOptions) => {\n    if (!keepIsValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n\n    formStateSubjectRef.current.next({\n      submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\n      isDirty: keepDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: keepIsValid\n        ? formStateRef.current.isValid\n        : !validationMode.isOnSubmit,\n      dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\n      touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\n      errors: keepErrors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false,\n    });\n  };\n\n  const reset: UseFormReset<TFieldValues> = (values, keepStateOptions = {}) => {\n    const updatedValues = values || defaultValuesRef.current;\n\n    if (isWeb && !keepStateOptions.keepValues) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field && field._f) {\n          const { ref, refs } = field._f;\n          const inputRef = Array.isArray(refs) ? refs[0] : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form')!.reset();\n              break;\n            } catch {}\n          }\n        }\n      }\n    }\n\n    !keepStateOptions.keepDefaultValues &&\n      (defaultValuesRef.current = { ...updatedValues });\n\n    if (!keepStateOptions.keepValues) {\n      fieldsRef.current = {};\n\n      controllerSubjectRef.current.next({ ...updatedValues });\n\n      watchSubjectRef.current.next({\n        value: { ...updatedValues },\n      });\n\n      fieldArraySubjectRef.current.next({\n        fields: { ...updatedValues },\n        isReset: true,\n      });\n    }\n\n    resetFromState(keepStateOptions);\n  };\n\n  React.useEffect(() => {\n    resolver && readFormStateRef.current.isValid && updateIsValid();\n  }, [defaultValuesRef.current]);\n\n  React.useEffect(() => {\n    isMountedRef.current = true;\n    const formStateSubscription = formStateSubjectRef.current.subscribe({\n      next(formState: Partial<FormState<TFieldValues>> = {}) {\n        if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\n          formStateRef.current = {\n            ...formStateRef.current,\n            ...formState,\n          };\n          setFormState(formStateRef.current);\n        }\n      },\n    });\n\n    const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next(state) {\n        if (state.fields && state.name) {\n          fieldArrayUpdatedValuesRef.current = state;\n\n          if (readFormStateRef.current.isValid) {\n            const values = getValues();\n            set(values, state.name, state.fields);\n            updateIsValid(values);\n          }\n        }\n      },\n    });\n\n    return () => {\n      watchSubjectRef.current.unsubscribe();\n      formStateSubscription.unsubscribe();\n      useFieldArraySubscription.unsubscribe();\n    };\n  }, []);\n\n  return {\n    control: React.useMemo(\n      () => ({\n        register,\n        isWatchAllRef,\n        watchFieldsRef,\n        getFormIsDirty,\n        formStateSubjectRef,\n        fieldArraySubjectRef,\n        controllerSubjectRef,\n        watchSubjectRef,\n        watchInternal,\n        fieldsRef,\n        validFieldsRef,\n        fieldsWithValidationRef,\n        fieldArrayNamesRef,\n        readFormStateRef,\n        formStateRef,\n        defaultValuesRef,\n        fieldArrayDefaultValuesRef,\n      }),\n      [],\n    ),\n    formState: getProxyFormState<TFieldValues>(\n      isProxyEnabled,\n      formState,\n      readFormStateRef,\n    ),\n    trigger,\n    register,\n    handleSubmit,\n    watch: React.useCallback(watch, []),\n    setValue: React.useCallback(setValue, [setInternalValue, trigger]),\n    getValues: React.useCallback(getValues, []),\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    unregister: React.useCallback(unregister, []),\n    setError: React.useCallback(setError, []),\n  };\n}\n","import * as React from 'react';\nimport { UseFormMethods, FieldValues, FormProviderProps } from './types';\n\nconst FormContext = React.createContext<UseFormMethods | null>(null);\n\nFormContext.displayName = 'RHFContext';\n\nexport const useFormContext = <\n  TFieldValues extends FieldValues\n>(): UseFormMethods<TFieldValues> =>\n  (React.useContext(FormContext) as unknown) as UseFormMethods<TFieldValues>;\n\nexport const FormProvider = <TFieldValues extends FieldValues>({\n  children,\n  ...props\n}: FormProviderProps<TFieldValues>) => (\n  <FormContext.Provider value={(props as unknown) as UseFormMethods}>\n    {children}\n  </FormContext.Provider>\n);\n","import { UNDEFINED } from '../constants';\n\nexport default () => {\n  const d =\n    typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n","import { FieldValues } from '../types';\nimport generateId from './generateId';\n\nexport default <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id'\n>(\n  values: Partial<TFieldArrayValues>[] = [],\n  keyName: TKeyName,\n): any =>\n  values.map((value: Partial<TFieldArrayValues>) => ({\n    [keyName]: (value && value[keyName]) || generateId(),\n    ...value,\n  }));\n","import isUndefined from './isUndefined';\nimport compact from './compact';\n\nfunction removeAtIndexes<T>(data: T[], indexes: number[]): T[] {\n  let i = 0;\n  const temp = [...data];\n\n  for (const index of indexes) {\n    temp.splice(index - i, 1);\n    i++;\n  }\n\n  return compact(temp).length ? temp : [];\n}\n\nexport default <T>(data: T[], index?: number | number[]): T[] =>\n  isUndefined(index)\n    ? []\n    : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort());\n","import isUndefined from './isUndefined';\n\nexport default <T>(\n  data: (T | undefined)[],\n  from: number,\n  to: number,\n): (T | undefined)[] => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n","export default <T>(data: T[], indexA: number, indexB: number): void => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n","export default function prepend<T>(data: T[]): (T | undefined)[];\nexport default function prepend<T>(data: T[], value: T | T[]): T[];\nexport default function prepend<T>(\n  data: T[],\n  value?: T | T[],\n): (T | undefined)[] {\n  return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\n}\n","export default function insert<T>(data: T[], index: number): (T | undefined)[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value: T | T[],\n): T[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value?: T | T[],\n): (T | undefined)[] {\n  return [\n    ...data.slice(0, index),\n    ...(Array.isArray(value) ? value : [value]),\n    ...data.slice(index),\n  ];\n}\n","export default <T>(value: T | T[]): undefined[] | undefined =>\n  Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport mapIds from './logic/mapId';\nimport getFieldArrayParentName from './logic/getNodeParentName';\nimport get from './utils/get';\nimport set from './utils/set';\nimport removeArrayAt from './utils/remove';\nimport unset from './utils/unset';\nimport moveArrayAt from './utils/move';\nimport swapArrayAt from './utils/swap';\nimport prependAt from './utils/prepend';\nimport insertAt from './utils/insert';\nimport fillEmptyArray from './utils/fillEmptyArray';\nimport compact from './utils/compact';\nimport isUndefined from './utils/isUndefined';\nimport focusFieldBy from './logic/focusFieldBy';\nimport getFieldsValues from './logic/getFieldsValues';\nimport {\n  FieldValues,\n  UseFieldArrayProps,\n  FieldPath,\n  FieldArrayWithId,\n  UseFieldArrayMethods,\n  FieldArray,\n  FieldArrayMethodsOption,\n  FieldErrors,\n  FieldNamesMarkedBoolean,\n} from './types';\n\nexport const useFieldArray = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TKeyName extends string = 'id'\n>({\n  control,\n  name,\n  keyName = 'id' as TKeyName,\n}: UseFieldArrayProps<TFieldValues, TName, TKeyName>): UseFieldArrayMethods<\n  TFieldValues,\n  TName,\n  TKeyName\n> => {\n  const methods = useFormContext();\n  const focusNameRef = React.useRef('');\n  const {\n    isWatchAllRef,\n    watchFieldsRef,\n    getFormIsDirty,\n    watchSubjectRef,\n    fieldArraySubjectRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    formStateRef,\n    formStateSubjectRef,\n    readFormStateRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n  } = control || methods.control;\n\n  const [fields, setFields] = React.useState<\n    Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[]\n  >(\n    mapIds(\n      get(fieldArrayDefaultValuesRef.current, getFieldArrayParentName(name))\n        ? get(fieldArrayDefaultValuesRef.current, name, [])\n        : get(defaultValuesRef.current, name, []),\n      keyName,\n    ),\n  );\n\n  set(fieldArrayDefaultValuesRef.current, name, [...fields]);\n  fieldArrayNamesRef.current.add(name);\n\n  const omitKey = <\n    T extends Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[]\n  >(\n    fields: T,\n  ) => fields.map(({ [keyName]: omitted, ...rest } = {}) => rest);\n\n  const getCurrentFieldsValues = () => {\n    const values = get(getFieldsValues(fieldsRef, defaultValuesRef), name, []);\n\n    return mapIds<TFieldValues, TKeyName>(\n      get(fieldArrayDefaultValuesRef.current, name, []).map(\n        (item: Partial<TFieldValues>, index: number) => ({\n          ...item,\n          ...values[index],\n        }),\n      ),\n      keyName,\n    );\n  };\n\n  const getFocusDetail = (\n    index: number,\n    options?: FieldArrayMethodsOption,\n  ): string => {\n    if (options) {\n      if (!isUndefined(options.focusIndex)) {\n        return `${name}.${options.focusIndex}`;\n      }\n      if (options.focusName) {\n        return options.focusName;\n      }\n      if (!options.shouldFocus) {\n        return '';\n      }\n    }\n    return `${name}.${index}`;\n  };\n\n  const resetFields = <T>(index?: T) =>\n    (Array.isArray(index) ? index : [index]).forEach((currentIndex) =>\n      set(\n        fieldsRef.current,\n        `${name}${currentIndex ? `.${currentIndex}` : ''}`,\n        [],\n      ),\n    );\n\n  const setFieldsAndNotify = (\n    fieldsValues: Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[],\n  ) => {\n    setFields(mapIds(fieldsValues, keyName));\n    fieldArraySubjectRef.current.next({\n      name,\n      fields: omitKey([...fieldsValues]),\n    });\n  };\n\n  const cleanup = <T>(ref: T) =>\n    !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const updateDirtyFieldsWithDefaultValues = <\n    T extends Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[]\n  >(\n    updatedFieldArrayValues?: T,\n  ) =>\n    updatedFieldArrayValues &&\n    set(\n      formStateRef.current.dirtyFields,\n      name,\n      setFieldArrayDirtyFields(\n        omitKey(updatedFieldArrayValues),\n        get(defaultValuesRef.current, name, []),\n        get(formStateRef.current.dirtyFields, name, []),\n      ),\n    );\n\n  const batchStateUpdate = <\n    T extends Function,\n    K extends Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[]\n  >(\n    method: T,\n    args: {\n      argA?: unknown;\n      argB?: unknown;\n    },\n    updatedFieldValues?: K,\n    updatedFormValues: Partial<\n      FieldArrayWithId<TFieldValues, TName, TKeyName>\n    >[] = [],\n    shouldSet = true,\n    shouldUpdateValid = false,\n  ) => {\n    if (get(fieldsRef.current, name)) {\n      const output = method(get(fieldsRef.current, name), args.argA, args.argB);\n      shouldSet && set(fieldsRef.current, name, output);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(\n        get(formStateRef.current.errors, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (\n      readFormStateRef.current.touchedFields &&\n      get(formStateRef.current.touchedFields, name)\n    ) {\n      const output = method(\n        get(formStateRef.current.touchedFields, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.touchedFields, name, output);\n      cleanup(formStateRef.current.touchedFields);\n    }\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      set(\n        formStateRef.current.dirtyFields,\n        name,\n        setFieldArrayDirtyFields(\n          omitKey(updatedFormValues),\n          get(defaultValuesRef.current, name, []),\n          get(formStateRef.current.dirtyFields, name, []),\n        ),\n      );\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (shouldUpdateValid && readFormStateRef.current.isValid) {\n      set(\n        validFieldsRef.current,\n        name,\n        method(get(validFieldsRef.current, name, []), args.argA),\n      );\n      cleanup(validFieldsRef.current);\n\n      set(\n        fieldsWithValidationRef.current,\n        name,\n        method(get(fieldsWithValidationRef.current, name, []), args.argA),\n      );\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    formStateSubjectRef.current.next({\n      isDirty: getFormIsDirty(name, omitKey(updatedFormValues)),\n      errors: formStateRef.current.errors as FieldErrors<TFieldValues>,\n      isValid: formStateRef.current.isValid,\n    });\n  };\n\n  const append = (\n    value:\n      | Partial<FieldArray<TFieldValues, TName>>\n      | Partial<FieldArray<TFieldValues, TName>>[],\n    options?: FieldArrayMethodsOption,\n  ) => {\n    const appendValue = Array.isArray(value) ? value : [value];\n    const updatedFieldValues = [...getCurrentFieldsValues(), ...appendValue];\n    setFieldsAndNotify(updatedFieldValues);\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n\n      formStateSubjectRef.current.next({\n        isDirty: true,\n        dirtyFields: formStateRef.current\n          .dirtyFields as FieldNamesMarkedBoolean<TFieldValues>,\n      });\n    }\n\n    focusNameRef.current = getFocusDetail(\n      updatedFieldValues.length - 1,\n      options,\n    );\n  };\n\n  const prepend = (\n    value:\n      | Partial<FieldArray<TFieldValues, TName>>\n      | Partial<FieldArray<TFieldValues, TName>>[],\n    options?: FieldArrayMethodsOption,\n  ) => {\n    const updatedFieldArrayValues = prependAt(\n      getCurrentFieldsValues(),\n      Array.isArray(value) ? value : [value],\n    );\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(\n      prependAt,\n      {\n        argA: fillEmptyArray(value),\n      },\n      updatedFieldArrayValues,\n    );\n\n    focusNameRef.current = getFocusDetail(0, options);\n  };\n\n  const remove = (index?: number | number[]) => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldValues: Partial<\n      FieldArrayWithId<TFieldValues, TName, TKeyName>\n    >[] = removeArrayAt(fieldValues, index);\n    resetFields(index);\n    batchStateUpdate(\n      removeArrayAt,\n      {\n        argA: index,\n      },\n      updatedFieldValues,\n      removeArrayAt(fieldValues, index),\n      true,\n      true,\n    );\n    setFieldsAndNotify(updatedFieldValues);\n  };\n\n  const insert = (\n    index: number,\n    value:\n      | Partial<FieldArray<TFieldValues, TName>>\n      | Partial<FieldArray<TFieldValues, TName>>[],\n    options?: FieldArrayMethodsOption,\n  ) => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldArrayValues = insertAt(\n      fieldValues,\n      index,\n      Array.isArray(value) ? value : [value],\n    );\n\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(\n      insertAt,\n      {\n        argA: index,\n        argB: fillEmptyArray(value),\n      },\n      updatedFieldArrayValues,\n      fieldValues && insertAt(fieldValues, index),\n    );\n\n    focusNameRef.current = getFocusDetail(index, options);\n  };\n\n  const swap = (indexA: number, indexB: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    batchStateUpdate(\n      swapArrayAt,\n      {\n        argA: indexA,\n        argB: indexB,\n      },\n      undefined,\n      fieldValues,\n      false,\n    );\n    setFieldsAndNotify(fieldValues);\n  };\n\n  const move = (from: number, to: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    setFieldsAndNotify(fieldValues);\n    batchStateUpdate(\n      moveArrayAt,\n      {\n        argA: from,\n        argB: to,\n      },\n      undefined,\n      fieldValues,\n      false,\n    );\n  };\n\n  React.useEffect(() => {\n    if (isWatchAllRef.current) {\n      formStateSubjectRef.current.next({});\n    } else {\n      for (const watchField of watchFieldsRef.current) {\n        if (name.startsWith(watchField)) {\n          formStateSubjectRef.current.next({});\n          break;\n        }\n      }\n    }\n\n    watchSubjectRef.current.next({ name });\n\n    focusNameRef.current &&\n      focusFieldBy(fieldsRef.current, (key: string) =>\n        key.startsWith(focusNameRef.current),\n      );\n\n    focusNameRef.current = '';\n  }, [fields, name]);\n\n  React.useEffect(() => {\n    const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next({ name: inputName, fields, isReset }) {\n        if (isReset) {\n          if (inputName) {\n            const value = getFieldsValues(fieldsRef, defaultValuesRef);\n            set(value, inputName, fields);\n            set(fieldArrayDefaultValuesRef.current, name, fields);\n            setFieldsAndNotify(get(value, name));\n          } else {\n            fieldArrayDefaultValuesRef.current = fields;\n            setFieldsAndNotify(get(fields, name));\n          }\n        }\n      },\n    });\n\n    return () => {\n      fieldArraySubscription.unsubscribe();\n      unset(fieldArrayDefaultValuesRef.current, name);\n      fieldArrayNamesRef.current.delete(name);\n    };\n  }, []);\n\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend, [name]),\n    append: React.useCallback(append, [name]),\n    remove: React.useCallback(remove, [name]),\n    insert: React.useCallback(insert, [name]),\n    fields: fields as FieldArrayWithId<TFieldValues, TName, TKeyName>,\n  };\n};\n","import isPrimitive from './isPrimitive';\nimport isHTMLElement from './isHTMLElement';\nimport isWeb from './isWeb';\n\nexport default function cloneObject<T extends unknown>(data: T): T {\n  let copy: any;\n\n  if (\n    isPrimitive(data) ||\n    (isWeb && (data instanceof File || isHTMLElement(data)))\n  ) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n    for (const item of data) {\n      copy.add(item);\n    }\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n    for (const key of data.keys()) {\n      copy.set(key, cloneObject(data.get(key)));\n    }\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (const key in data) {\n    copy[key] = cloneObject(data[key]);\n  }\n\n  return copy;\n}\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport getProxyFormState from './logic/getProxyFormState';\nimport shouldRenderFormState from './logic/shouldRenderFormState';\nimport isProxyEnabled from './utils/isProxyEnabled';\nimport cloneObject from './utils/cloneObject';\nimport {\n  FieldValues,\n  FormState,\n  UseFormStateMethods,\n  UseFormStateProps,\n} from './types';\n\nfunction useFormState<TFieldValues extends FieldValues = FieldValues>({\n  control,\n}: UseFormStateProps<TFieldValues> = {}): UseFormStateMethods<TFieldValues> {\n  const methods = useFormContext();\n  const { formStateRef, formStateSubjectRef, readFormStateRef } =\n    control || methods.control;\n\n  const [formState, updateFormState] = React.useState(formStateRef.current);\n  const readFormState = React.useRef(cloneObject(readFormStateRef.current));\n\n  React.useEffect(() => {\n    const formStateSubscription = formStateSubjectRef.current.subscribe({\n      next: (formState) => {\n        shouldRenderFormState(formState, readFormState.current) &&\n          updateFormState({\n            ...formStateRef.current,\n            ...formState,\n          });\n      },\n    });\n\n    return () => formStateSubscription.unsubscribe();\n  }, []);\n\n  return getProxyFormState<TFieldValues>(\n    isProxyEnabled,\n    formState as FormState<TFieldValues>,\n    readFormStateRef,\n    readFormState,\n    false,\n  );\n}\n\nexport { useFormState };\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isPrimitive from '../utils/isPrimitive';\n\nexport default (event: any) =>\n  isPrimitive(event) ||\n  !isObject(event.target) ||\n  (isObject(event.target) && !event.type)\n    ? event\n    : isUndefined(event.target.value)\n    ? event.target.checked\n    : event.target.value;\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport { useFormState } from './useFormState';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport getControllerValue from './logic/getControllerValue';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport { EVENTS } from './constants';\nimport {\n  FieldValues,\n  UseControllerProps,\n  UseControllerMethods,\n  InternalFieldName,\n} from './types';\n\nexport function useController<TFieldValues extends FieldValues = FieldValues>({\n  name,\n  rules,\n  defaultValue,\n  control,\n}: UseControllerProps<TFieldValues>): UseControllerMethods<TFieldValues> {\n  const methods = useFormContext<TFieldValues>();\n  const {\n    defaultValuesRef,\n    register,\n    fieldsRef,\n    fieldArrayNamesRef,\n    controllerSubjectRef,\n  } = control || methods.control;\n\n  const { onChange, onBlur, ref } = register(name, rules);\n  const getInitialValue = () =>\n    (get(fieldsRef.current, name) &&\n      isUndefined(get(fieldsRef.current, name)._f.value)) ||\n    isNameInFieldArray(fieldArrayNamesRef.current, name)\n      ? isUndefined(defaultValue)\n        ? get(defaultValuesRef.current, name)\n        : defaultValue\n      : get(fieldsRef.current, name)._f.value;\n\n  const [value, setInputStateValue] = React.useState(getInitialValue());\n  const { errors, dirtyFields, touchedFields, isValidating } = useFormState({\n    control: control || methods.control,\n  });\n\n  React.useEffect(() => {\n    if (get(fieldsRef.current, name)) {\n      get(fieldsRef.current, name)._f.value = getInitialValue();\n    }\n\n    const controllerSubscription = controllerSubjectRef.current.subscribe({\n      next: (values) => setInputStateValue(get(values, name)),\n    });\n\n    return () => controllerSubscription.unsubscribe();\n  }, []);\n\n  return {\n    field: {\n      onChange: (event: any) => {\n        const value = getControllerValue(event);\n        setInputStateValue(value);\n\n        onChange({\n          target: {\n            value,\n            name: name as InternalFieldName,\n          },\n        });\n      },\n      onBlur: () => {\n        onBlur({\n          target: {\n            name: name as InternalFieldName,\n          },\n          type: EVENTS.BLUR,\n        });\n      },\n      name,\n      value,\n      ref,\n    },\n    meta: {\n      invalid: !!get(errors, name),\n      isDirty: !!get(dirtyFields, name),\n      isTouched: !!get(touchedFields, name),\n      error: get(errors, name),\n      isValidating,\n    },\n  };\n}\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport isUndefined from './utils/isUndefined';\nimport isString from './utils/isString';\nimport get from './utils/get';\nimport isObject from './utils/isObject';\nimport {\n  DeepPartial,\n  UseWatchProps,\n  FieldValues,\n  UnpackNestedValue,\n  Control,\n  FieldPath,\n  InternalFieldName,\n  FieldPathValue,\n  FieldPathValues,\n} from './types';\n\nexport function useWatch<\n  TFieldValues extends FieldValues = FieldValues\n>(props: {\n  defaultValue?: UnpackNestedValue<DeepPartial<TFieldValues>>;\n  control?: Control<TFieldValues>;\n}): UnpackNestedValue<DeepPartial<TFieldValues>>;\nexport function useWatch<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>(props: {\n  name: TName;\n  defaultValue?: FieldPathValue<TFieldValues, TName>;\n  control?: Control<TFieldValues>;\n}): FieldPathValue<TFieldValues, TName>;\nexport function useWatch<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues>[] = FieldPath<TFieldValues>[]\n>(props: {\n  name: TName;\n  defaultValue?: UnpackNestedValue<DeepPartial<TFieldValues>>;\n  control?: Control<TFieldValues>;\n}): FieldPathValues<TFieldValues, TName>;\nexport function useWatch<TFieldValues>({\n  control,\n  name,\n  defaultValue,\n}: UseWatchProps<TFieldValues>) {\n  const methods = useFormContext();\n\n  const { watchInternal, defaultValuesRef, watchSubjectRef } =\n    control || methods.control;\n  const [value, updateValue] = React.useState<unknown>(\n    isUndefined(defaultValue)\n      ? Array.isArray(name)\n        ? name.reduce(\n            (previous, inputName) => ({\n              ...previous,\n              [inputName]: get(defaultValuesRef.current, inputName as string),\n            }),\n            {},\n          )\n        : isString(name)\n        ? get(defaultValuesRef.current, name)\n        : defaultValuesRef.current\n      : defaultValue,\n  );\n\n  React.useEffect(() => {\n    const watchSubscription = watchSubjectRef.current.subscribe({\n      next: ({ name: inputName, value }) => {\n        updateValue(\n          isString(inputName) && name === inputName && !isUndefined(value)\n            ? value\n            : name && isObject(value)\n            ? get(value, name as InternalFieldName, defaultValue)\n            : watchInternal(name as string, defaultValue),\n        );\n      },\n    });\n\n    return () => watchSubscription.unsubscribe();\n  }, [name]);\n\n  return value;\n}\n","import { useController } from './useController';\nimport { ControllerProps, FieldValues } from './types';\n\nconst Controller = <TFieldValues extends FieldValues = FieldValues>(\n  props: ControllerProps<TFieldValues>,\n) => props.render(useController(props));\n\nexport { Controller };\n","// Todo: to be removed\nimport set from '../utils/set';\nimport isKey from '../utils/isKey';\nimport { FieldValues } from '../types';\n\nexport default (data: FieldValues, value: Record<string, any> = {}): any => {\n  for (const key in data) {\n    !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\n  }\n  return value;\n};\n"]},"metadata":{},"sourceType":"module"}