{"version":3,"file":"index.cjs.production.min.js","sources":["../src/utils/isUndefined.ts","../src/utils/isNullOrUndefined.ts","../src/utils/isObject.ts","../src/utils/compact.ts","../src/utils/get.ts","../src/utils/isKey.ts","../src/utils/stringToPath.ts","../src/utils/set.ts","../src/logic/focusFieldBy.ts","../src/utils/isPrimitive.ts","../src/utils/deepEqual.ts","../src/logic/setFieldArrayDirtyFields.ts","../src/utils/deepMerge.ts","../src/utils/isEmptyObject.ts","../src/constants.ts","../src/logic/shouldRenderFormState.ts","../src/logic/getFieldValueAs.ts","../src/logic/getFieldsValues.ts","../src/logic/getRadioValue.ts","../src/utils/isRadioInput.ts","../src/utils/isFileInput.ts","../src/utils/isCheckBoxInput.ts","../src/utils/isMultipleSelect.ts","../src/logic/getCheckboxValue.ts","../src/logic/getFieldValue.ts","../src/logic/getMultipleSelectValue.ts","../src/logic/isErrorStateChanged.ts","../src/utils/isRegex.ts","../src/logic/getValueAndMessage.ts","../src/utils/isString.ts","../src/utils/isFunction.ts","../src/utils/isBoolean.ts","../src/utils/isMessage.ts","../src/logic/getValidateError.ts","../src/logic/appendErrors.ts","../src/logic/validateField.ts","../src/logic/getNodeParentName.ts","../src/logic/isNameInFieldArray.ts","../src/logic/getProxyFormState.ts","../src/utils/Subject.ts","../src/utils/isWeb.ts","../src/utils/isProxyEnabled.ts","../src/utils/getPath.ts","../src/utils/unset.ts","../src/utils/getValidationModes.ts","../src/utils/isHTMLElement.ts","../src/logic/getFields.ts","../src/useForm.ts","../src/useFormContext.tsx","../src/logic/generateId.ts","../src/logic/mapId.ts","../src/utils/remove.ts","../src/utils/move.ts","../src/utils/swap.ts","../src/utils/prepend.ts","../src/utils/insert.ts","../src/utils/fillEmptyArray.ts","../src/useFormState.ts","../src/utils/cloneObject.ts","../src/useController.ts","../src/logic/getControllerValue.ts","../src/controller.tsx","../src/logic/transformToNestObject.ts","../src/useFieldArray.ts","../src/logic/skipValidation.ts","../src/utils/isRadioOrCheckbox.ts","../src/useWatch.ts"],"sourcesContent":["export default (val: unknown): val is undefined => val === undefined;\n","export default (value: unknown): value is null | undefined => value == null;\n","import isNullOrUndefined from './isNullOrUndefined';\n\nexport const isObjectType = (value: unknown) => typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) &&\n  !Array.isArray(value) &&\n  isObjectType(value) &&\n  !(value instanceof Date);\n","export default (value: any[]) => value.filter(Boolean);\n","import isUndefined from './isUndefined';\nimport isNullOrUndefined from './isNullOrUndefined';\nimport compact from './compact';\n\nexport default (obj: any = {}, path: string, defaultValue?: unknown) => {\n  const result = compact(path.split(/[,[\\].]+?/)).reduce(\n    (result, key) => (isNullOrUndefined(result) ? result : result[key]),\n    obj,\n  );\n\n  return isUndefined(result) || result === obj\n    ? isUndefined(obj[path])\n      ? defaultValue\n      : obj[path]\n    : result;\n};\n","export default (value: string) => /^\\w*$/.test(value);\n","import compact from './compact';\n\nexport default (input: string): string[] =>\n  compact(\n    input\n      .replace(/[\"|']/g, '')\n      .replace(/\\[/g, '.')\n      .replace(/\\]/g, '')\n      .split('.'),\n  );\n","import isObject from './isObject';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport { FieldValues } from '../types';\n\nexport default function set(\n  object: FieldValues,\n  path: string,\n  value?: unknown,\n) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue =\n        isObject(objValue) || Array.isArray(objValue)\n          ? objValue\n          : !isNaN(+tempPath[index + 1])\n          ? []\n          : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport { get } from '../utils';\nimport { FieldRefs, InternalFieldName } from '../types';\n\nconst focusFieldBy = (\n  fields: FieldRefs,\n  callback: (name: string) => boolean,\n  fieldsNames?: Set<InternalFieldName>,\n) => {\n  for (const key of fieldsNames || Object.keys(fields)) {\n    const field = get(fields, key);\n\n    if (field) {\n      const { _f, ...current } = field;\n\n      if (_f && callback(_f.name)) {\n        if (_f.ref.focus && isUndefined(_f.ref.focus())) {\n          break;\n        } else if (_f.refs) {\n          _f.refs[0].focus();\n          break;\n        }\n      } else if (isObject(current)) {\n        focusFieldBy(current, callback);\n      }\n    }\n  }\n};\n\nexport default focusFieldBy;\n","import isNullOrUndefined from './isNullOrUndefined';\nimport { isObjectType } from './isObject';\nimport { Primitive } from '../types';\n\nexport default (value: unknown): value is Primitive =>\n  isNullOrUndefined(value) || !isObjectType(value);\n","import * as React from 'react';\nimport isObject from '../utils/isObject';\nimport isPrimitive from './isPrimitive';\n\nexport default function deepEqual(\n  object1: any,\n  object2: any,\n  isErrorObject?: boolean,\n) {\n  if (\n    isPrimitive(object1) ||\n    isPrimitive(object2) ||\n    object1 instanceof Date ||\n    object2 instanceof Date\n  ) {\n    return object1 === object2;\n  }\n\n  if (!React.isValidElement(object1)) {\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const val1 = object1[key];\n\n      if (!(isErrorObject && key === 'ref')) {\n        const val2 = object2[key];\n\n        if (\n          (isObject(val1) || Array.isArray(val1)) &&\n          (isObject(val2) || Array.isArray(val2))\n            ? !deepEqual(val1, val2, isErrorObject)\n            : val1 !== val2\n        ) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n","import { get } from '../utils';\nimport set from '../utils/set';\nimport { deepMerge } from '../utils/deepMerge';\nimport deepEqual from '../utils/deepEqual';\n\nfunction setDirtyFields<\n  T extends Record<string, unknown>[],\n  U extends Record<string, unknown>[],\n  K extends Record<string, boolean | []>\n>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n  parentNode?: K,\n  parentName?: keyof K,\n) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(\n          values[index][key] as T,\n          get(defaultValues[index] || {}, key, []),\n          dirtyFields[index][key] as [],\n          dirtyFields[index],\n          key,\n        );\n      } else {\n        deepEqual(get(defaultValues[index] || {}, key), values[index][key])\n          ? set(dirtyFields[index] || {}, key)\n          : (dirtyFields[index] = {\n              ...dirtyFields[index],\n              [key]: true,\n            });\n      }\n    }\n\n    parentNode &&\n      !dirtyFields.length &&\n      delete parentNode[parentName as keyof K];\n  }\n\n  return dirtyFields;\n}\n\nexport default <T extends U, U extends Record<string, unknown>[]>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n) =>\n  deepMerge(\n    setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)),\n    setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)),\n  );\n","import isObject from './isObject';\nimport isPrimitive from './isPrimitive';\n\nexport function deepMerge<\n  T extends Record<keyof T, any>,\n  U extends Record<keyof U, any>\n>(target: T, source: U): T & U {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] =\n        (isObject(targetValue) && isObject(sourceValue)) ||\n        (Array.isArray(targetValue) && Array.isArray(sourceValue))\n          ? deepMerge(targetValue, sourceValue)\n          : sourceValue;\n    } catch {}\n  }\n\n  return target;\n}\n","import isObject from './isObject';\nimport { EmptyObject } from '../types';\n\nexport default (value: unknown): value is EmptyObject =>\n  isObject(value) && !Object.keys(value).length;\n","import { ValidationMode } from './types';\n\nexport const EVENTS = {\n  BLUR: 'blur',\n};\n\nexport const VALIDATION_MODE: ValidationMode = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all',\n};\n\nexport const SELECT = 'select';\n\nexport const UNDEFINED = 'undefined';\n\nexport const INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate',\n};\n","import isEmptyObject from '../utils/isEmptyObject';\nimport { ReadFormState } from '../types';\nimport { VALIDATION_MODE } from '../constants';\n\nexport default <T, K extends ReadFormState>(\n  formState: T,\n  readFormStateRef: K,\n  isRoot?: boolean,\n) =>\n  isEmptyObject(formState) ||\n  Object.keys(formState).length >= Object.keys(readFormStateRef).length ||\n  Object.keys(formState).find(\n    (key) =>\n      readFormStateRef[key as keyof ReadFormState] ===\n      (isRoot ? VALIDATION_MODE.all : true),\n  );\n","import { Field } from '../types';\n\nexport default (\n  value: any,\n  { valueAsNumber, valueAsDate, setValueAs }: Field['_f'],\n  shouldReturnAsValue?: boolean,\n) =>\n  shouldReturnAsValue\n    ? valueAsNumber\n      ? value === ''\n        ? NaN\n        : +value\n      : valueAsDate\n      ? new Date(value)\n      : setValueAs\n      ? setValueAs(value)\n      : value\n    : value;\n","import * as React from 'react';\nimport set from '../utils/set';\nimport getFieldValueAs from './getFieldValueAs';\nimport { FieldRefs, FieldValues } from '../types';\n\nconst getFieldsValues = (\n  fieldsRef: React.MutableRefObject<FieldRefs>,\n  defaultValuesRef: React.MutableRefObject<FieldValues>,\n  shouldReturnAsValue?: boolean,\n  output: Record<string, any> = {},\n): any => {\n  for (const name in fieldsRef.current) {\n    const field = fieldsRef.current[name];\n\n    if (field) {\n      const { _f, ...current } = field;\n      set(\n        output,\n        name,\n        _f && !_f.ref.disabled\n          ? getFieldValueAs(_f.value, _f, shouldReturnAsValue)\n          : Array.isArray(field)\n          ? []\n          : {},\n      );\n\n      if (current) {\n        getFieldsValues(\n          {\n            current,\n          },\n          defaultValuesRef,\n          shouldReturnAsValue,\n          output[name],\n        );\n      }\n    }\n  }\n\n  return {\n    ...defaultValuesRef.current,\n    ...output,\n  };\n};\n\nexport default getFieldsValues;\n","type RadioFieldResult = {\n  isValid: boolean;\n  value: number | string | null;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: null,\n};\n\nexport default (options?: HTMLInputElement[]): RadioFieldResult =>\n  Array.isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.checked\n            ? {\n                isValid: true,\n                value: option.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'radio';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-multiple`;\n","import isUndefined from '../utils/isUndefined';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: HTMLInputElement[]): CheckboxFieldResult => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.checked)\n        .map(({ value }) => value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    const { checked, value, attributes } = options[0];\n\n    return checked\n      ? // @ts-expect-error\n        attributes && !isUndefined(attributes.value)\n        ? isUndefined(value)\n          ? validResult\n          : { value: value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n","import getRadioValue from './getRadioValue';\nimport getMultipleSelectValue from './getMultipleSelectValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport isFileInput from '../utils/isFileInput';\nimport isCheckBox from '../utils/isCheckBoxInput';\nimport isMultipleSelect from '../utils/isMultipleSelect';\nimport getCheckboxValue from './getCheckboxValue';\nimport getFieldValueAs from './getFieldValueAs';\nimport { Field } from '../types';\n\nexport default function getFieldValue(\n  field?: Field,\n  shouldReturnAsValue?: boolean,\n) {\n  if (field && field._f) {\n    const { ref } = field._f;\n\n    if (ref.disabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field._f.refs).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBox(ref)) {\n      return getCheckboxValue(field._f.refs).value;\n    }\n\n    return getFieldValueAs(ref.value, field._f, shouldReturnAsValue);\n  }\n}\n","export default (\n  options: HTMLOptionElement[] | HTMLOptionsCollection,\n): string[] =>\n  [...options]\n    .filter(({ selected }): boolean => selected)\n    .map(({ value }): string => value);\n","import get from '../utils/get';\nimport isUndefined from '../utils/isUndefined';\nimport deepEqual from '../utils/deepEqual';\nimport {\n  FieldValues,\n  InternalFieldName,\n  FieldErrors,\n  FieldNamesMarkedBoolean,\n  FieldError,\n} from '../types';\n\nexport default <TFieldValues extends FieldValues>({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation,\n}: {\n  errors: FieldErrors<TFieldValues>;\n  error: FieldError | undefined;\n  name: InternalFieldName;\n  validFields: FieldNamesMarkedBoolean<TFieldValues>;\n  fieldsWithValidation: FieldNamesMarkedBoolean<TFieldValues>;\n}): boolean => {\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n\n  return (\n    (isValid && !!previousError) ||\n    (!isValid && !deepEqual(previousError, error, true)) ||\n    (isValid && get(fieldsWithValidation, name) && !get(validFields, name))\n  );\n};\n","export default (value: unknown): value is RegExp => value instanceof RegExp;\n","import isObject from '../utils/isObject';\nimport isRegex from '../utils/isRegex';\nimport { ValidationRule } from '../types';\n\nexport default (validationData?: ValidationRule) =>\n  isObject(validationData) && !isRegex(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n      };\n","export default (value: unknown): value is string => typeof value === 'string';\n","export default (value: unknown): value is Function =>\n  typeof value === 'function';\n","export default (value: unknown): value is boolean => typeof value === 'boolean';\n","import * as React from 'react';\nimport isString from '../utils/isString';\nimport { Message } from '../types';\n\nexport default (value: unknown): value is Message =>\n  isString(value) || React.isValidElement(value as JSX.Element);\n","import isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport { FieldError, ValidateResult, Ref } from '../types';\n\nexport default function getValidateError(\n  result: ValidateResult,\n  ref: Ref,\n  type = 'validate',\n): FieldError | void {\n  if (isMessage(result) || (isBoolean(result) && !result)) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref,\n    };\n  }\n}\n","import {\n  InternalFieldName,\n  ValidateResult,\n  InternalFieldErrors,\n} from '../types';\n\nexport default (\n  name: InternalFieldName,\n  validateAllFieldCriteria: boolean,\n  errors: InternalFieldErrors,\n  type: string,\n  message: ValidateResult,\n) =>\n  validateAllFieldCriteria\n    ? {\n        ...errors[name],\n        types: {\n          ...(errors[name] && errors[name]!.types ? errors[name]!.types : {}),\n          [type]: message || true,\n        },\n      }\n    : {};\n","import getRadioValue from './getRadioValue';\nimport getCheckboxValue from './getCheckboxValue';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isRadioInput from '../utils/isRadioInput';\nimport getValueAndMessage from './getValueAndMessage';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isString from '../utils/isString';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isObject from '../utils/isObject';\nimport isFunction from '../utils/isFunction';\nimport isRegex from '../utils/isRegex';\nimport isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport getValidateError from './getValidateError';\nimport appendErrors from './appendErrors';\nimport { INPUT_VALIDATION_RULES } from '../constants';\nimport { Field, Message, FieldError, InternalFieldErrors } from '../types';\n\nexport default async (\n  {\n    _f: {\n      ref,\n      refs,\n      required,\n      maxLength,\n      minLength,\n      min,\n      max,\n      pattern,\n      validate,\n      name,\n      value: inputValue,\n    },\n  }: Field,\n  validateAllFieldCriteria: boolean,\n): Promise<InternalFieldErrors> => {\n  const error: InternalFieldErrors = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty =\n    !inputValue || (Array.isArray(inputValue) && !inputValue.length);\n  const appendErrorsCurry = appendErrors.bind(\n    null,\n    name,\n    validateAllFieldCriteria,\n    error,\n  );\n  const getMinMaxMessage = (\n    exceedMax: boolean,\n    maxLengthMessage: Message,\n    minLengthMessage: Message,\n    maxType = INPUT_VALIDATION_RULES.maxLength,\n    minType = INPUT_VALIDATION_RULES.minLength,\n  ) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = {\n      type: exceedMax ? maxType : minType,\n      message,\n      ref,\n      ...(exceedMax\n        ? appendErrorsCurry(maxType, message)\n        : appendErrorsCurry(minType, message)),\n    };\n  };\n\n  if (\n    required &&\n    ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue))) ||\n      (isBoolean(inputValue) && !inputValue) ||\n      (isCheckBox && !getCheckboxValue(refs).isValid) ||\n      (isRadio && !getRadioValue(refs).isValid))\n  ) {\n    const { value, message } = isMessage(required)\n      ? { value: !!required, message: required }\n      : getValueAndMessage(required);\n\n    if (value) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.required,\n        message,\n        ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (\n    (!isNullOrUndefined(min) || !isNullOrUndefined(max)) &&\n    inputValue !== ''\n  ) {\n    let exceedMax;\n    let exceedMin;\n    const maxOutput = getValueAndMessage(max);\n    const minOutput = getValueAndMessage(min);\n\n    if (!isNaN(inputValue)) {\n      const valueNumber =\n        (ref as HTMLInputElement).valueAsNumber || parseFloat(inputValue);\n      if (!isNullOrUndefined(maxOutput.value)) {\n        exceedMax = valueNumber > maxOutput.value;\n      }\n      if (!isNullOrUndefined(minOutput.value)) {\n        exceedMin = valueNumber < minOutput.value;\n      }\n    } else {\n      const valueDate =\n        (ref as HTMLInputElement).valueAsDate || new Date(inputValue);\n      if (isString(maxOutput.value)) {\n        exceedMax = valueDate > new Date(maxOutput.value);\n      }\n      if (isString(minOutput.value)) {\n        exceedMin = valueDate < new Date(minOutput.value);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        !!exceedMax,\n        maxOutput.message,\n        minOutput.message,\n        INPUT_VALIDATION_RULES.max,\n        INPUT_VALIDATION_RULES.min,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\n    const maxLengthOutput = getValueAndMessage(maxLength);\n    const minLengthOutput = getValueAndMessage(minLength);\n    const exceedMax =\n      !isNullOrUndefined(maxLengthOutput.value) &&\n      inputValue.length > maxLengthOutput.value;\n    const exceedMin =\n      !isNullOrUndefined(minLengthOutput.value) &&\n      inputValue.length < minLengthOutput.value;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        exceedMax,\n        maxLengthOutput.message,\n        minLengthOutput.message,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(inputValue) && pattern && !isEmpty) {\n    const { value: patternValue, message } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(inputValue)) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.pattern,\n        message,\n        ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(inputValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = {\n          ...validateError,\n          ...appendErrorsCurry(\n            INPUT_VALIDATION_RULES.validate,\n            validateError.message,\n          ),\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {} as FieldError;\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(inputValue);\n        const validateError = getValidateError(\n          validateResult,\n          validateRef,\n          key,\n        );\n\n        if (validateError) {\n          validationResult = {\n            ...validateError,\n            ...appendErrorsCurry(key, validateError.message),\n          };\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = {\n          ref: validateRef,\n          ...validationResult,\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n","export default (name: string) => name.substring(0, name.search(/.\\d/)) || name;\n","import getNodeParentName from './getNodeParentName';\nimport { InternalFieldName } from '../types';\n\nexport default (names: Set<InternalFieldName>, name: InternalFieldName) =>\n  [...names].some((current) => getNodeParentName(name) === current);\n","import * as React from 'react';\nimport { FormState, FormStateProxy, ReadFormState } from '../types';\nimport { VALIDATION_MODE } from '../constants';\n\nexport default <TFieldValues>(\n  isProxyEnabled: boolean,\n  formState: FormState<TFieldValues>,\n  readFormStateRef: React.MutableRefObject<ReadFormState>,\n  localReadFormStateRef?: React.MutableRefObject<ReadFormState>,\n  isRoot = true,\n) =>\n  isProxyEnabled\n    ? new Proxy(formState, {\n        get: (obj, prop: keyof FormStateProxy) => {\n          if (prop in obj) {\n            if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\n              readFormStateRef.current[prop] = isRoot\n                ? VALIDATION_MODE.all\n                : true;\n            }\n            localReadFormStateRef &&\n              (localReadFormStateRef.current[prop] = true);\n            return obj[prop];\n          }\n\n          return undefined;\n        },\n      })\n    : formState;\n","export type Observer<T> = {\n  next: (value: T) => void;\n};\n\ntype TearDown = () => void;\n\nexport type SubjectType<T> = {\n  next: (value: T) => void;\n  subscribe: (\n    value: Observer<T>,\n  ) => {\n    unsubscribe: TearDown;\n  };\n};\n\nexport class Subscription {\n  private tearDowns: TearDown[] = [];\n\n  add(tearDown: TearDown) {\n    this.tearDowns.push(tearDown);\n  }\n\n  unsubscribe() {\n    for (const teardown of this.tearDowns) {\n      teardown();\n    }\n    this.tearDowns = [];\n  }\n}\n\nclass Subscriber<T> implements Observer<T> {\n  closed = false;\n\n  constructor(private observer: Observer<T>, subscription: Subscription) {\n    subscription.add(() => (this.closed = true));\n  }\n\n  next(value: T) {\n    if (!this.closed) {\n      this.observer.next(value);\n    }\n  }\n}\n\nexport default class Subject<T> {\n  observers: Observer<T>[];\n\n  constructor() {\n    this.observers = [];\n  }\n\n  next(value: T) {\n    for (const observer of this.observers) {\n      observer.next(value);\n    }\n  }\n\n  subscribe(observer: Observer<T>) {\n    const subscription = new Subscription();\n    const subscriber = new Subscriber(observer, subscription);\n    this.observers.push(subscriber);\n\n    return subscription;\n  }\n\n  unsubscribe() {\n    this.observers = [];\n  }\n}\n","import { UNDEFINED } from '../constants';\n\nexport default typeof window !== UNDEFINED && typeof document !== UNDEFINED;\n","import isWeb from './isWeb';\nimport { UNDEFINED } from '../constants';\n\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nexport default isProxyEnabled;\n","import isPrimitive from './isPrimitive';\nimport { FieldName } from '../types';\n\nexport const getPath = <TFieldValues>(\n  rootPath: FieldName<TFieldValues>,\n  values: any,\n  paths: FieldName<TFieldValues>[] = [],\n): FieldName<TFieldValues>[] => {\n  for (const property in values) {\n    isPrimitive(values[property])\n      ? paths.push(`${rootPath}.${property}` as FieldName<TFieldValues>)\n      : getPath(\n          `${rootPath}.${property}` as FieldName<TFieldValues>,\n          values[property],\n          paths,\n        );\n  }\n\n  return paths;\n};\n","import isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport isEmptyObject from './isEmptyObject';\nimport isObject from './isObject';\nimport isUndefined from './isUndefined';\nimport isBoolean from './isBoolean';\n\nfunction baseGet(object: any, updatePath: (string | number)[]) {\n  const length = updatePath.slice(0, -1).length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nexport default function unset(object: any, path: string) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject =\n    updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (\n        currentPathsLength === index &&\n        ((isObject(objectRef) && isEmptyObject(objectRef)) ||\n          (Array.isArray(objectRef) &&\n            !objectRef.filter(\n              (data) =>\n                (isObject(data) && !isEmptyObject(data)) || isBoolean(data),\n            ).length))\n      ) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n","import { VALIDATION_MODE } from '../constants';\nimport { Mode } from '../types';\n\nexport default (\n  mode?: Mode,\n): {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n  isOnTouch: boolean;\n} => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched,\n});\n","export default (value: any): value is HTMLElement =>\n  value instanceof HTMLElement;\n","import { Field, FieldRefs, InternalFieldName } from '../types';\nimport { get } from '../utils';\nimport isKey from '../utils/isKey';\nimport set from '../utils/set';\n\nexport default function getFields(\n  fieldsNames: Set<InternalFieldName> | InternalFieldName[],\n  fieldsRefs: FieldRefs,\n) {\n  const currentFields: Record<InternalFieldName, Field['_f']> = {};\n\n  for (const name of fieldsNames) {\n    const field = get(fieldsRefs, name) as Field | undefined;\n\n    if (field) {\n      !isKey(name)\n        ? set(currentFields, name, field._f)\n        : (currentFields[name] = field._f);\n    }\n  }\n\n  return currentFields;\n}\n","import * as React from 'react';\nimport focusFieldBy from './logic/focusFieldBy';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport shouldRenderFormState from './logic/shouldRenderFormState';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldValue from './logic/getFieldValue';\nimport isErrorStateChanged from './logic/isErrorStateChanged';\nimport validateField from './logic/validateField';\nimport skipValidation from './logic/skipValidation';\nimport getNodeParentName from './logic/getNodeParentName';\nimport deepEqual from './utils/deepEqual';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport getProxyFormState from './logic/getProxyFormState';\nimport Subject, { Subscription } from './utils/Subject';\nimport isProxyEnabled from './utils/isProxyEnabled';\nimport isCheckBoxInput from './utils/isCheckBoxInput';\nimport isEmptyObject from './utils/isEmptyObject';\nimport isRadioInput from './utils/isRadioInput';\nimport isFileInput from './utils/isFileInput';\nimport { getPath } from './utils/getPath';\nimport isFunction from './utils/isFunction';\nimport isString from './utils/isString';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport unset from './utils/unset';\nimport getValidationModes from './utils/getValidationModes';\nimport isMultipleSelect from './utils/isMultipleSelect';\nimport compact from './utils/compact';\nimport isNullOrUndefined from './utils/isNullOrUndefined';\nimport isRadioOrCheckboxFunction from './utils/isRadioOrCheckbox';\nimport isWeb from './utils/isWeb';\nimport isHTMLElement from './utils/isHTMLElement';\nimport getFields from './logic/getFields';\nimport { EVENTS, UNDEFINED, VALIDATION_MODE } from './constants';\nimport {\n  UseFormMethods,\n  FieldValues,\n  UnpackNestedValue,\n  FieldName,\n  InternalFieldName,\n  Field,\n  FieldRefs,\n  UseFormProps,\n  RegisterOptions,\n  ReadFormState,\n  Ref,\n  SetValueConfig,\n  FormState,\n  FieldNamesMarkedBoolean,\n  DeepPartial,\n  InternalNameSet,\n  DefaultValues,\n  FieldError,\n  SetFieldValue,\n  FieldArrayDefaultValues,\n  RegisterCallback,\n  FieldPath,\n  WatchObserver,\n  FieldPathValue,\n  FieldPathValues,\n  KeepStateOptions,\n  EventType,\n  UseFormTrigger,\n  UseFormSetValue,\n  UseFormUnregister,\n  UseFormClearErrors,\n  UseFormSetError,\n  UseFormRegister,\n  UseFormHandleSubmit,\n  UseFormReset,\n  WatchInternal,\n  GetFormIsDirty,\n  HandleChange,\n} from './types';\n\nconst isWindowUndefined = typeof window === UNDEFINED;\n\nexport function useForm<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext extends object = object\n>({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {} as DefaultValues<TFieldValues>,\n  shouldFocusError = true,\n  criteriaMode,\n}: UseFormProps<TFieldValues, TContext> = {}): UseFormMethods<TFieldValues> {\n  const fieldsRef = React.useRef<FieldRefs>({});\n  const fieldsNamesRef = React.useRef<Set<InternalFieldName>>(new Set());\n  const formStateSubjectRef = React.useRef(\n    new Subject<Partial<FormState<TFieldValues>>>(),\n  );\n  const watchSubjectRef = React.useRef(\n    new Subject<{\n      name?: InternalFieldName;\n      type?: EventType;\n      value?: unknown;\n    }>(),\n  );\n  const controllerSubjectRef = React.useRef(\n    new Subject<DefaultValues<TFieldValues>>(),\n  );\n  const fieldArraySubjectRef = React.useRef(\n    new Subject<{\n      name?: InternalFieldName;\n      fields: any;\n      isReset?: boolean;\n    }>(),\n  );\n  const fieldArrayUpdatedValuesRef = React.useRef<{\n    name?: InternalFieldName;\n    fields?: DeepPartial<TFieldValues>;\n  }>({});\n  const fieldArrayDefaultValuesRef = React.useRef<FieldArrayDefaultValues>({});\n  const watchFieldsRef = React.useRef<InternalNameSet>(new Set());\n  const isMountedRef = React.useRef(false);\n  const fieldsWithValidationRef = React.useRef<\n    FieldNamesMarkedBoolean<TFieldValues>\n  >({});\n  const validFieldsRef = React.useRef<FieldNamesMarkedBoolean<TFieldValues>>(\n    {},\n  );\n  const defaultValuesRef = React.useRef<DefaultValues<TFieldValues>>(\n    defaultValues,\n  );\n  const isWatchAllRef = React.useRef(false);\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef<InternalNameSet>(new Set());\n  const validationMode = getValidationModes(mode);\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = React.useState<FormState<TFieldValues>>({\n    isDirty: false,\n    isValidating: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touchedFields: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !validationMode.isOnSubmit,\n    errors: {},\n  });\n  const readFormStateRef = React.useRef<ReadFormState>({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touchedFields: !isProxyEnabled || validationMode.isOnTouch,\n    isValidating: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n    errors: !isProxyEnabled,\n  });\n  const formStateRef = React.useRef(formState);\n\n  contextRef.current = context;\n  resolverRef.current = resolver;\n\n  const getIsValid = () =>\n    (formStateRef.current.isValid =\n      deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\n      isEmptyObject(formStateRef.current.errors));\n\n  const shouldRenderBaseOnError = React.useCallback(\n    (\n      name: InternalFieldName,\n      error?: FieldError,\n      shouldRender: boolean | null = false,\n      state: {\n        dirty?: FieldNamesMarkedBoolean<TFieldValues>;\n        isDirty?: boolean;\n        touched?: FieldNamesMarkedBoolean<TFieldValues>;\n      } = {},\n      isValid?: boolean,\n    ): boolean | void => {\n      let shouldReRender =\n        shouldRender ||\n        isErrorStateChanged<TFieldValues>({\n          errors: formStateRef.current.errors,\n          error,\n          name,\n          validFields: validFieldsRef.current,\n          fieldsWithValidation: fieldsWithValidationRef.current,\n        });\n      const previousError = get(formStateRef.current.errors, name);\n\n      if (error) {\n        unset(validFieldsRef.current, name);\n        shouldReRender =\n          shouldReRender ||\n          !previousError ||\n          !deepEqual(previousError, error, true);\n        set(formStateRef.current.errors, name, error);\n      } else {\n        if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n          set(validFieldsRef.current, name, true);\n          shouldReRender = shouldReRender || previousError;\n        }\n\n        unset(formStateRef.current.errors, name);\n      }\n\n      if (\n        (shouldReRender && !isNullOrUndefined(shouldRender)) ||\n        !isEmptyObject(state)\n      ) {\n        formStateSubjectRef.current.next({\n          ...state,\n          isValid: resolverRef.current ? isValid : getIsValid(),\n          errors: formStateRef.current.errors,\n        });\n      }\n\n      formStateSubjectRef.current.next({\n        isValidating: false,\n      });\n    },\n    [],\n  );\n\n  const setFieldValue = React.useCallback(\n    (name: InternalFieldName, rawValue: SetFieldValue<TFieldValues>) => {\n      const { _f } = get(fieldsRef.current, name) as Field;\n\n      if (_f) {\n        const { ref, refs } = _f;\n        const value =\n          isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\n            ? ''\n            : rawValue;\n        _f.value = rawValue;\n\n        if (isRadioInput(ref)) {\n          (refs || []).forEach(\n            (radioRef: HTMLInputElement) =>\n              (radioRef.checked = radioRef.value === value),\n          );\n        } else if (isFileInput(ref) && !isString(value)) {\n          ref.files = value as FileList;\n        } else if (isMultipleSelect(ref)) {\n          [...ref.options].forEach(\n            (selectRef) =>\n              (selectRef.selected = (value as string[]).includes(\n                selectRef.value,\n              )),\n          );\n        } else if (isCheckBoxInput(ref) && refs) {\n          refs.length > 1\n            ? refs.forEach(\n                (checkboxRef) =>\n                  (checkboxRef.checked = Array.isArray(value)\n                    ? !!(value as []).find(\n                        (data: string) => data === checkboxRef.value,\n                      )\n                    : value === checkboxRef.value),\n              )\n            : (refs[0].checked = !!value);\n        } else {\n          ref.value = value;\n        }\n      }\n    },\n    [],\n  );\n\n  const getFormIsDirty: GetFormIsDirty = React.useCallback((name, data) => {\n    if (readFormStateRef.current.isDirty) {\n      const formValues = getValues();\n\n      name && data && set(formValues, name, data);\n\n      return !deepEqual(formValues, defaultValuesRef.current);\n    }\n\n    return false;\n  }, []);\n\n  const updateAndGetDirtyState = React.useCallback(\n    (\n      name: InternalFieldName,\n      shouldRender = true,\n    ): Partial<\n      Pick<FormState<TFieldValues>, 'dirtyFields' | 'isDirty' | 'touchedFields'>\n    > => {\n      if (\n        readFormStateRef.current.isDirty ||\n        readFormStateRef.current.dirtyFields\n      ) {\n        const isFieldDirty = !deepEqual(\n          get(defaultValuesRef.current, name),\n          getFieldValue(get(fieldsRef.current, name) as Field, true),\n        );\n        const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n        const previousIsDirty = formStateRef.current.isDirty;\n\n        isFieldDirty\n          ? set(formStateRef.current.dirtyFields, name, true)\n          : unset(formStateRef.current.dirtyFields, name);\n\n        const state = {\n          isDirty: getFormIsDirty(),\n          dirtyFields: formStateRef.current.dirtyFields,\n        };\n\n        const isChanged =\n          (readFormStateRef.current.isDirty &&\n            previousIsDirty !== state.isDirty) ||\n          (readFormStateRef.current.dirtyFields &&\n            isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\n\n        isChanged && shouldRender && formStateSubjectRef.current.next(state);\n\n        return isChanged ? state : {};\n      }\n\n      return {};\n    },\n    [],\n  );\n\n  const executeValidation = React.useCallback(\n    async (\n      name: InternalFieldName,\n      skipReRender?: boolean | null,\n    ): Promise<boolean> => {\n      const error = (\n        await validateField(\n          get(fieldsRef.current, name) as Field,\n          isValidateAllFieldCriteria,\n        )\n      )[name];\n\n      shouldRenderBaseOnError(name, error, skipReRender);\n\n      return isUndefined(error);\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const executeSchemaOrResolverValidation = React.useCallback(\n    async (\n      names: InternalFieldName[],\n      currentNames: FieldName<TFieldValues>[] = [],\n    ) => {\n      const { errors } = await resolverRef.current!(\n        getFieldsValues(fieldsRef, defaultValuesRef, true),\n        contextRef.current,\n        {\n          criteriaMode,\n          names: currentNames,\n          fields: getFields(fieldsNamesRef.current, fieldsRef.current),\n        },\n      );\n\n      for (const name of names) {\n        const error = get(errors, name);\n        error\n          ? set(formStateRef.current.errors, name, error)\n          : unset(formStateRef.current.errors, name);\n      }\n\n      return errors;\n    },\n    [shouldRenderBaseOnError, criteriaMode],\n  );\n\n  const validateForm = async (fieldsRef: FieldRefs) => {\n    for (const name in fieldsRef) {\n      const field = fieldsRef[name];\n\n      if (field) {\n        const { _f, ...current } = field;\n\n        if (_f) {\n          const fieldError = await validateField(\n            field,\n            isValidateAllFieldCriteria,\n          );\n\n          if (fieldError[field._f.name]) {\n            set(\n              formStateRef.current.errors,\n              field._f.name,\n              fieldError[field._f.name],\n            );\n            unset(validFieldsRef.current, field._f.name);\n          } else if (get(fieldsWithValidationRef.current, field._f.name)) {\n            set(validFieldsRef.current, field._f.name, true);\n            unset(formStateRef.current.errors, field._f.name);\n          }\n        }\n\n        current && (await validateForm(current));\n      }\n    }\n  };\n\n  const trigger: UseFormTrigger<TFieldValues> = React.useCallback(\n    async (name) => {\n      const fields = isUndefined(name)\n        ? Object.keys(fieldsRef.current)\n        : Array.isArray(name)\n        ? name\n        : [name];\n      let isValid;\n\n      formStateSubjectRef.current.next({\n        isValidating: true,\n      });\n\n      if (resolver) {\n        isValid = isEmptyObject(\n          await executeSchemaOrResolverValidation(\n            fields,\n            isUndefined(name)\n              ? undefined\n              : (fields as FieldName<TFieldValues>[]),\n          ),\n        );\n      } else {\n        isUndefined(name)\n          ? await validateForm(fieldsRef.current)\n          : await Promise.all(\n              fields.map(async (data) => await executeValidation(data, null)),\n            );\n      }\n\n      formStateSubjectRef.current.next({\n        errors: formStateRef.current.errors,\n        isValidating: false,\n        isValid: resolver ? isValid : getIsValid(),\n      });\n    },\n    [executeSchemaOrResolverValidation, executeValidation],\n  );\n\n  const setInternalValues = React.useCallback(\n    (\n      name: FieldName<TFieldValues>,\n      value: SetFieldValue<TFieldValues>,\n      { shouldDirty, shouldValidate }: SetValueConfig,\n    ) => {\n      const data = {};\n      set(data, name, value);\n\n      for (const fieldName of getPath(name, value)) {\n        if (get(fieldsRef.current, fieldName)) {\n          setFieldValue(fieldName, get(data, fieldName));\n          shouldDirty && updateAndGetDirtyState(fieldName);\n          shouldValidate && trigger(fieldName as FieldName<TFieldValues>);\n        }\n      }\n    },\n    [trigger, setFieldValue, updateAndGetDirtyState],\n  );\n\n  const setInternalValue = React.useCallback(\n    (\n      name: FieldName<TFieldValues>,\n      value: SetFieldValue<TFieldValues>,\n      options: SetValueConfig,\n    ) => {\n      const field = get(fieldsRef.current, name);\n\n      if (field && field._f) {\n        setFieldValue(name, value);\n        options.shouldDirty && updateAndGetDirtyState(name);\n        options.shouldValidate && trigger(name as FieldName<TFieldValues>);\n      } else {\n        setInternalValues(name, value, options);\n\n        if (fieldArrayNamesRef.current.has(name)) {\n          fieldArraySubjectRef.current.next({\n            fields: value,\n            name,\n            isReset: true,\n          });\n\n          if (\n            (readFormStateRef.current.isDirty ||\n              readFormStateRef.current.dirtyFields) &&\n            options.shouldDirty\n          ) {\n            set(\n              formStateRef.current.dirtyFields,\n              name,\n              setFieldArrayDirtyFields(\n                value,\n                get(defaultValuesRef.current, name, []),\n                get(formStateRef.current.dirtyFields, name, []),\n              ),\n            );\n\n            formStateSubjectRef.current.next({\n              dirtyFields: formStateRef.current.dirtyFields,\n              isDirty: getFormIsDirty(name, value),\n            });\n          }\n        }\n      }\n    },\n    [updateAndGetDirtyState, setFieldValue, setInternalValues],\n  );\n\n  const isFieldWatched = <T extends FieldName<TFieldValues>>(name: T) =>\n    isWatchAllRef.current ||\n    watchFieldsRef.current.has(name) ||\n    watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const updateValueAndGetDefault = (name: InternalFieldName) => {\n    let defaultValue;\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const field = get(fieldsRef.current, name) as Field;\n\n    if (\n      field &&\n      (!isEmptyObject(defaultValuesRef.current) || !isUndefined(field._f.value))\n    ) {\n      defaultValue = isUndefined(field._f.value)\n        ? get(defaultValuesRef.current, name)\n        : field._f.value;\n\n      if (!isUndefined(defaultValue) && !isFieldArray) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    return defaultValue;\n  };\n\n  const setValue: UseFormSetValue<TFieldValues> = (name, value, options) => {\n    setInternalValue(name, value, options || {});\n    isFieldWatched(name) && formStateSubjectRef.current.next({});\n    watchSubjectRef.current.next({ name, value });\n  };\n\n  const handleChange: HandleChange = React.useCallback(\n    async ({ type, target, target: { value, type: inputType } }) => {\n      let name = (target as Ref)!.name;\n      let error;\n      let isValid;\n      const field = get(fieldsRef.current, name) as Field;\n\n      if (field) {\n        const inputValue = inputType ? getFieldValue(field) : value;\n        const isBlurEvent = type === EVENTS.BLUR;\n        const {\n          isOnBlur: isReValidateOnBlur,\n          isOnChange: isReValidateOnChange,\n        } = getValidationModes(reValidateMode);\n        const shouldSkipValidation = skipValidation({\n          isBlurEvent,\n          isTouched: !!get(formStateRef.current.touchedFields, name),\n          isSubmitted: formStateRef.current.isSubmitted,\n          isReValidateOnBlur,\n          isReValidateOnChange,\n          ...validationMode,\n        });\n        const isWatched =\n          !isBlurEvent && isFieldWatched(name as FieldName<TFieldValues>);\n\n        if (!isUndefined(inputValue)) {\n          field._f.value = inputValue;\n        }\n\n        const state = updateAndGetDirtyState(name, false);\n\n        if (\n          isBlurEvent &&\n          readFormStateRef.current.touchedFields &&\n          !get(formStateRef.current.touchedFields, name)\n        ) {\n          set(formStateRef.current.touchedFields, name, true);\n          state.touchedFields = formStateRef.current.touchedFields;\n        }\n\n        let shouldRender = !isEmptyObject(state) || isWatched;\n\n        if (shouldSkipValidation) {\n          !isBlurEvent &&\n            watchSubjectRef.current.next({\n              name,\n              type,\n              value: inputValue,\n            });\n          return (\n            shouldRender &&\n            formStateSubjectRef.current.next(isWatched ? {} : state)\n          );\n        }\n\n        formStateSubjectRef.current.next({\n          isValidating: true,\n        });\n\n        if (resolverRef.current) {\n          const { errors } = await resolverRef.current(\n            getFieldsValues(fieldsRef, defaultValuesRef, true),\n            contextRef.current,\n            {\n              criteriaMode,\n              fields: getFields([name], fieldsRef.current),\n              names: [name as FieldName<TFieldValues>],\n            },\n          );\n          const previousFormIsValid = formStateRef.current.isValid;\n          error = get(errors, name);\n\n          if (isCheckBoxInput(target as Ref) && !error) {\n            const parentNodeName = getNodeParentName(name);\n            const currentError = get(errors, parentNodeName, {});\n            currentError.type && currentError.message && (error = currentError);\n\n            if (\n              currentError ||\n              get(formStateRef.current.errors, parentNodeName)\n            ) {\n              name = parentNodeName;\n            }\n          }\n\n          isValid = isEmptyObject(errors);\n\n          previousFormIsValid !== isValid && (shouldRender = true);\n        } else {\n          error = (await validateField(field, isValidateAllFieldCriteria))[\n            name\n          ];\n        }\n\n        !isBlurEvent &&\n          watchSubjectRef.current.next({\n            name,\n            type,\n            value: inputValue,\n          });\n        shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n      }\n    },\n    [],\n  );\n\n  function getValues(): UnpackNestedValue<TFieldValues>;\n  function getValues<TName extends FieldPath<TFieldValues>>(\n    fieldName: TName,\n  ): FieldPathValue<TFieldValues, TName>;\n  function getValues<TName extends FieldPath<TFieldValues>[]>(\n    fieldNames: TName,\n  ): FieldPathValues<TFieldValues, TName>;\n  function getValues(\n    fieldNames?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[],\n  ) {\n    const values = isMountedRef.current\n      ? getFieldsValues(fieldsRef, defaultValuesRef)\n      : defaultValues;\n\n    if (isUndefined(fieldNames)) {\n      return values;\n    }\n\n    if (isString(fieldNames)) {\n      return get(values, fieldNames as InternalFieldName);\n    }\n\n    return fieldNames.map((name) => get(values, name as InternalFieldName));\n  }\n\n  const updateIsValid = React.useCallback(\n    async (values = {}) => {\n      if (resolver) {\n        const { errors } = await resolverRef.current!(\n          {\n            ...getFieldsValues(fieldsRef, defaultValuesRef, true),\n            ...values,\n          },\n          contextRef.current,\n          {\n            criteriaMode,\n            fields: getFields(fieldsNamesRef.current, fieldsRef.current),\n          },\n        );\n        const isValid = isEmptyObject(errors);\n\n        formStateRef.current.isValid !== isValid &&\n          formStateSubjectRef.current.next({\n            isValid,\n          });\n      } else {\n        getIsValid();\n      }\n    },\n    [criteriaMode],\n  );\n\n  const clearErrors: UseFormClearErrors<TFieldValues> = (name) => {\n    name &&\n      (Array.isArray(name) ? name : [name]).forEach((inputName) =>\n        unset(formStateRef.current.errors, inputName),\n      );\n\n    formStateSubjectRef.current.next({\n      errors: name ? formStateRef.current.errors : {},\n    });\n  };\n\n  const setError: UseFormSetError<TFieldValues> = (name, error, options) => {\n    const ref = ((get(fieldsRef.current, name) as Field) || { _f: {} })._f.ref;\n\n    set(formStateRef.current.errors, name, {\n      ...error,\n      ref,\n    });\n\n    formStateSubjectRef.current.next({\n      errors: formStateRef.current.errors,\n      isValid: false,\n    });\n\n    options && options.shouldFocus && ref && ref.focus && ref.focus();\n  };\n\n  const watchInternal: WatchInternal = React.useCallback(\n    (fieldNames, defaultValue, isGlobal) => {\n      const { fields, name } = fieldArrayUpdatedValuesRef.current;\n      const isArrayNames = Array.isArray(fieldNames);\n      let fieldValues = isMountedRef.current\n        ? getValues()\n        : isUndefined(defaultValue)\n        ? defaultValuesRef.current\n        : isArrayNames\n        ? defaultValue || {}\n        : { [fieldNames as string]: defaultValue };\n\n      if (fields) {\n        name ? set(fieldValues, name, fields) : (fieldValues = fields);\n\n        fieldArrayUpdatedValuesRef.current = {\n          fields: undefined,\n          name: undefined,\n        };\n      }\n\n      if (isUndefined(fieldNames)) {\n        isWatchAllRef.current = true;\n        return fieldValues;\n      }\n\n      const result = [];\n\n      for (const fieldName of isArrayNames ? fieldNames : [fieldNames]) {\n        isGlobal && watchFieldsRef.current.add(fieldName as string);\n        result.push(get(fieldValues, fieldName as string));\n      }\n\n      return isArrayNames ? result : result[0];\n    },\n    [],\n  );\n\n  function watch(): UnpackNestedValue<TFieldValues>;\n  function watch<TName extends FieldPath<TFieldValues>>(\n    fieldName: TName,\n    defaultValue?: FieldPathValue<TFieldValues, TName>,\n  ): FieldPathValue<TFieldValues, TName>;\n  function watch<TName extends FieldPath<TFieldValues>[]>(\n    fieldName: TName,\n    defaultValue?: FieldPathValues<TFieldValues, TName>,\n  ): FieldPathValues<TFieldValues, TName>;\n  function watch(\n    callback: WatchObserver,\n    defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ): Subscription;\n  function watch(\n    fieldName?:\n      | FieldPath<TFieldValues>\n      | FieldPath<TFieldValues>[]\n      | WatchObserver,\n    defaultValue?: unknown,\n  ) {\n    if (isFunction(fieldName)) {\n      return watchSubjectRef.current.subscribe({\n        next: (info) => fieldName(watchInternal(undefined, defaultValue), info),\n      });\n    }\n\n    return watchInternal(fieldName as string | string[], defaultValue, true);\n  }\n\n  const unregister: UseFormUnregister<TFieldValues> = (name, options = {}) => {\n    for (const inputName of name\n      ? Array.isArray(name)\n        ? name\n        : [name]\n      : Object.keys(fieldsNamesRef.current)) {\n      fieldsNamesRef.current.delete(inputName);\n\n      if (get(fieldsRef.current, inputName) as Field) {\n        if (!options.keepIsValid) {\n          unset(fieldsWithValidationRef.current, inputName);\n          unset(validFieldsRef.current, inputName);\n        }\n        !options.keepValues && unset(formStateRef.current.errors, inputName);\n        !options.keepErrors && unset(fieldsRef.current, inputName);\n        !options.keepDirty &&\n          unset(formStateRef.current.dirtyFields, inputName);\n        !options.keepTouched &&\n          unset(formStateRef.current.touchedFields, inputName);\n        !options.keepDefaultValues &&\n          unset(defaultValuesRef.current, inputName);\n\n        watchSubjectRef.current.next({\n          name: inputName,\n        });\n      }\n    }\n\n    formStateSubjectRef.current.next({\n      ...formStateRef.current,\n      ...(!options.keepDirty ? {} : { isDirty: getFormIsDirty() }),\n      ...(resolver ? {} : { isValid: getIsValid() }),\n    });\n\n    if (!options.keepIsValid) {\n      updateIsValid();\n    }\n  };\n\n  const registerFieldRef = (\n    name: InternalFieldName,\n    ref: HTMLInputElement,\n    options?: RegisterOptions,\n  ): ((name: InternalFieldName) => void) | void => {\n    let field = get(fieldsRef.current, name) as Field;\n\n    if (field) {\n      const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n\n      if (\n        (isRadioOrCheckbox\n          ? Array.isArray(field._f.refs) &&\n            compact(field._f.refs).find(\n              (option) => ref.value === option.value && option === ref,\n            )\n          : ref === field._f.ref) ||\n        !field\n      ) {\n        return;\n      }\n\n      field = {\n        _f: isRadioOrCheckbox\n          ? {\n              ...field._f,\n              refs: [\n                ...compact(field._f.refs || []).filter(\n                  (ref) => isHTMLElement(ref) && document.contains(ref),\n                ),\n                ref,\n              ],\n              ref: { type: ref.type, name },\n            }\n          : {\n              ...field._f,\n              ref,\n            },\n      };\n\n      set(fieldsRef.current, name, field);\n\n      const defaultValue = updateValueAndGetDefault(name);\n\n      if (\n        isRadioOrCheckbox && Array.isArray(defaultValue)\n          ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue)\n          : true\n      ) {\n        get(fieldsRef.current, name)._f.value = getFieldValue(\n          get(fieldsRef.current, name),\n        );\n      }\n\n      if (options) {\n        if (\n          !validationMode.isOnSubmit &&\n          field &&\n          readFormStateRef.current.isValid\n        ) {\n          validateField(field, isValidateAllFieldCriteria).then((error) => {\n            isEmptyObject(error)\n              ? set(validFieldsRef.current, name, true)\n              : unset(validFieldsRef.current, name);\n\n            formStateRef.current.isValid &&\n              !isEmptyObject(error) &&\n              setFormState({ ...formStateRef.current, isValid: getIsValid() });\n          });\n        }\n      }\n    }\n  };\n\n  const register: UseFormRegister<TFieldValues> = React.useCallback(\n    (name, options) => {\n      set(fieldsRef.current, name, {\n        _f: {\n          ...(get(fieldsRef.current, name)\n            ? {\n                ref: get(fieldsRef.current, name)._f.ref,\n                ...get(fieldsRef.current, name)._f,\n              }\n            : { ref: { name } }),\n          name,\n          ...options,\n        },\n      });\n      options && set(fieldsWithValidationRef.current, name, true);\n      fieldsNamesRef.current.add(name);\n\n      updateValueAndGetDefault(name);\n\n      return isWindowUndefined\n        ? ({} as RegisterCallback)\n        : {\n            name,\n            onChange: handleChange,\n            onBlur: handleChange,\n            ref: (ref: HTMLInputElement | null) =>\n              ref && registerFieldRef(name, ref, options),\n          };\n    },\n    [defaultValuesRef.current],\n  );\n\n  const handleSubmit: UseFormHandleSubmit<TFieldValues> = React.useCallback(\n    (onValid, onInvalid) => async (e) => {\n      if (e && e.preventDefault) {\n        e.preventDefault();\n        e.persist();\n      }\n      let fieldValues = getFieldsValues(fieldsRef, defaultValuesRef, true);\n\n      formStateSubjectRef.current.next({\n        isSubmitting: true,\n      });\n\n      try {\n        if (resolverRef.current) {\n          const { errors, values } = await resolverRef.current(\n            fieldValues,\n            contextRef.current,\n            {\n              criteriaMode,\n              fields: getFields(fieldsNamesRef.current, fieldsRef.current),\n            },\n          );\n          formStateRef.current.errors = errors;\n          fieldValues = values;\n        } else {\n          await validateForm(fieldsRef.current);\n        }\n\n        if (\n          isEmptyObject(formStateRef.current.errors) &&\n          Object.keys(formStateRef.current.errors).every((name) =>\n            get(fieldValues, name),\n          )\n        ) {\n          formStateSubjectRef.current.next({\n            errors: {},\n            isSubmitting: true,\n          });\n          await onValid(fieldValues, e);\n        } else {\n          onInvalid && (await onInvalid(formStateRef.current.errors, e));\n          shouldFocusError &&\n            focusFieldBy(\n              fieldsRef.current,\n              (key: string) => get(formStateRef.current.errors, key),\n              fieldsNamesRef.current,\n            );\n        }\n      } finally {\n        formStateRef.current.isSubmitting = false;\n        formStateSubjectRef.current.next({\n          isSubmitted: true,\n          isSubmitting: false,\n          isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n          submitCount: formStateRef.current.submitCount + 1,\n          errors: formStateRef.current.errors,\n        });\n      }\n    },\n    [shouldFocusError, isValidateAllFieldCriteria, criteriaMode],\n  );\n\n  const resetFromState = ({\n    keepErrors,\n    keepDirty,\n    keepIsSubmitted,\n    keepTouched,\n    keepIsValid,\n    keepSubmitCount,\n  }: KeepStateOptions) => {\n    if (!keepIsValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n\n    formStateSubjectRef.current.next({\n      submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\n      isDirty: keepDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: keepIsValid\n        ? formStateRef.current.isValid\n        : !validationMode.isOnSubmit,\n      dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\n      touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\n      errors: keepErrors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false,\n    });\n  };\n\n  const reset: UseFormReset<TFieldValues> = (values, keepStateOptions = {}) => {\n    const updatedValues = values || defaultValuesRef.current;\n\n    if (isWeb && !keepStateOptions.keepValues) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field && field._f) {\n          const { ref, refs } = field._f;\n          const inputRef = Array.isArray(refs) ? refs[0] : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form')!.reset();\n              break;\n            } catch {}\n          }\n        }\n      }\n    }\n\n    !keepStateOptions.keepDefaultValues &&\n      (defaultValuesRef.current = { ...updatedValues });\n\n    if (!keepStateOptions.keepValues) {\n      fieldsRef.current = {};\n\n      controllerSubjectRef.current.next({ ...updatedValues });\n\n      watchSubjectRef.current.next({\n        value: { ...updatedValues },\n      });\n\n      fieldArraySubjectRef.current.next({\n        fields: { ...updatedValues },\n        isReset: true,\n      });\n    }\n\n    resetFromState(keepStateOptions);\n  };\n\n  React.useEffect(() => {\n    resolver && readFormStateRef.current.isValid && updateIsValid();\n  }, [defaultValuesRef.current]);\n\n  React.useEffect(() => {\n    isMountedRef.current = true;\n    const formStateSubscription = formStateSubjectRef.current.subscribe({\n      next(formState: Partial<FormState<TFieldValues>> = {}) {\n        if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\n          formStateRef.current = {\n            ...formStateRef.current,\n            ...formState,\n          };\n          setFormState(formStateRef.current);\n        }\n      },\n    });\n\n    const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next(state) {\n        if (state.fields && state.name) {\n          fieldArrayUpdatedValuesRef.current = state;\n\n          if (readFormStateRef.current.isValid) {\n            const values = getValues();\n            set(values, state.name, state.fields);\n            updateIsValid(values);\n          }\n        }\n      },\n    });\n\n    return () => {\n      watchSubjectRef.current.unsubscribe();\n      formStateSubscription.unsubscribe();\n      useFieldArraySubscription.unsubscribe();\n    };\n  }, []);\n\n  return {\n    control: React.useMemo(\n      () => ({\n        register,\n        isWatchAllRef,\n        watchFieldsRef,\n        getFormIsDirty,\n        formStateSubjectRef,\n        fieldArraySubjectRef,\n        controllerSubjectRef,\n        watchSubjectRef,\n        watchInternal,\n        fieldsRef,\n        validFieldsRef,\n        fieldsWithValidationRef,\n        fieldArrayNamesRef,\n        readFormStateRef,\n        formStateRef,\n        defaultValuesRef,\n        fieldArrayDefaultValuesRef,\n      }),\n      [],\n    ),\n    formState: getProxyFormState<TFieldValues>(\n      isProxyEnabled,\n      formState,\n      readFormStateRef,\n    ),\n    trigger,\n    register,\n    handleSubmit,\n    watch: React.useCallback(watch, []),\n    setValue: React.useCallback(setValue, [setInternalValue, trigger]),\n    getValues: React.useCallback(getValues, []),\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    unregister: React.useCallback(unregister, []),\n    setError: React.useCallback(setError, []),\n  };\n}\n","import * as React from 'react';\nimport { UseFormMethods, FieldValues, FormProviderProps } from './types';\n\nconst FormContext = React.createContext<UseFormMethods | null>(null);\n\nFormContext.displayName = 'RHFContext';\n\nexport const useFormContext = <\n  TFieldValues extends FieldValues\n>(): UseFormMethods<TFieldValues> =>\n  (React.useContext(FormContext) as unknown) as UseFormMethods<TFieldValues>;\n\nexport const FormProvider = <TFieldValues extends FieldValues>({\n  children,\n  ...props\n}: FormProviderProps<TFieldValues>) => (\n  <FormContext.Provider value={(props as unknown) as UseFormMethods}>\n    {children}\n  </FormContext.Provider>\n);\n","import { UNDEFINED } from '../constants';\n\nexport default () => {\n  const d =\n    typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n","import { FieldValues } from '../types';\nimport generateId from './generateId';\n\nexport default <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id'\n>(\n  values: Partial<TFieldArrayValues>[] = [],\n  keyName: TKeyName,\n): any =>\n  values.map((value: Partial<TFieldArrayValues>) => ({\n    [keyName]: (value && value[keyName]) || generateId(),\n    ...value,\n  }));\n","import isUndefined from './isUndefined';\nimport compact from './compact';\n\nfunction removeAtIndexes<T>(data: T[], indexes: number[]): T[] {\n  let i = 0;\n  const temp = [...data];\n\n  for (const index of indexes) {\n    temp.splice(index - i, 1);\n    i++;\n  }\n\n  return compact(temp).length ? temp : [];\n}\n\nexport default <T>(data: T[], index?: number | number[]): T[] =>\n  isUndefined(index)\n    ? []\n    : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort());\n","import isUndefined from './isUndefined';\n\nexport default <T>(\n  data: (T | undefined)[],\n  from: number,\n  to: number,\n): (T | undefined)[] => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n","export default <T>(data: T[], indexA: number, indexB: number): void => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n","export default function prepend<T>(data: T[]): (T | undefined)[];\nexport default function prepend<T>(data: T[], value: T | T[]): T[];\nexport default function prepend<T>(\n  data: T[],\n  value?: T | T[],\n): (T | undefined)[] {\n  return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\n}\n","export default function insert<T>(data: T[], index: number): (T | undefined)[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value: T | T[],\n): T[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value?: T | T[],\n): (T | undefined)[] {\n  return [\n    ...data.slice(0, index),\n    ...(Array.isArray(value) ? value : [value]),\n    ...data.slice(index),\n  ];\n}\n","export default <T>(value: T | T[]): undefined[] | undefined =>\n  Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport getProxyFormState from './logic/getProxyFormState';\nimport shouldRenderFormState from './logic/shouldRenderFormState';\nimport isProxyEnabled from './utils/isProxyEnabled';\nimport cloneObject from './utils/cloneObject';\nimport {\n  FieldValues,\n  FormState,\n  UseFormStateMethods,\n  UseFormStateProps,\n} from './types';\n\nfunction useFormState<TFieldValues extends FieldValues = FieldValues>({\n  control,\n}: UseFormStateProps<TFieldValues> = {}): UseFormStateMethods<TFieldValues> {\n  const methods = useFormContext();\n  const { formStateRef, formStateSubjectRef, readFormStateRef } =\n    control || methods.control;\n\n  const [formState, updateFormState] = React.useState(formStateRef.current);\n  const readFormState = React.useRef(cloneObject(readFormStateRef.current));\n\n  React.useEffect(() => {\n    const formStateSubscription = formStateSubjectRef.current.subscribe({\n      next: (formState) => {\n        shouldRenderFormState(formState, readFormState.current) &&\n          updateFormState({\n            ...formStateRef.current,\n            ...formState,\n          });\n      },\n    });\n\n    return () => formStateSubscription.unsubscribe();\n  }, []);\n\n  return getProxyFormState<TFieldValues>(\n    isProxyEnabled,\n    formState as FormState<TFieldValues>,\n    readFormStateRef,\n    readFormState,\n    false,\n  );\n}\n\nexport { useFormState };\n","import isPrimitive from './isPrimitive';\nimport isHTMLElement from './isHTMLElement';\nimport isWeb from './isWeb';\n\nexport default function cloneObject<T extends unknown>(data: T): T {\n  let copy: any;\n\n  if (\n    isPrimitive(data) ||\n    (isWeb && (data instanceof File || isHTMLElement(data)))\n  ) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n    for (const item of data) {\n      copy.add(item);\n    }\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n    for (const key of data.keys()) {\n      copy.set(key, cloneObject(data.get(key)));\n    }\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (const key in data) {\n    copy[key] = cloneObject(data[key]);\n  }\n\n  return copy;\n}\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport { useFormState } from './useFormState';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport getControllerValue from './logic/getControllerValue';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport { EVENTS } from './constants';\nimport {\n  FieldValues,\n  UseControllerProps,\n  UseControllerMethods,\n  InternalFieldName,\n} from './types';\n\nexport function useController<TFieldValues extends FieldValues = FieldValues>({\n  name,\n  rules,\n  defaultValue,\n  control,\n}: UseControllerProps<TFieldValues>): UseControllerMethods<TFieldValues> {\n  const methods = useFormContext<TFieldValues>();\n  const {\n    defaultValuesRef,\n    register,\n    fieldsRef,\n    fieldArrayNamesRef,\n    controllerSubjectRef,\n  } = control || methods.control;\n\n  const { onChange, onBlur, ref } = register(name, rules);\n  const getInitialValue = () =>\n    (get(fieldsRef.current, name) &&\n      isUndefined(get(fieldsRef.current, name)._f.value)) ||\n    isNameInFieldArray(fieldArrayNamesRef.current, name)\n      ? isUndefined(defaultValue)\n        ? get(defaultValuesRef.current, name)\n        : defaultValue\n      : get(fieldsRef.current, name)._f.value;\n\n  const [value, setInputStateValue] = React.useState(getInitialValue());\n  const { errors, dirtyFields, touchedFields, isValidating } = useFormState({\n    control: control || methods.control,\n  });\n\n  React.useEffect(() => {\n    if (get(fieldsRef.current, name)) {\n      get(fieldsRef.current, name)._f.value = getInitialValue();\n    }\n\n    const controllerSubscription = controllerSubjectRef.current.subscribe({\n      next: (values) => setInputStateValue(get(values, name)),\n    });\n\n    return () => controllerSubscription.unsubscribe();\n  }, []);\n\n  return {\n    field: {\n      onChange: (event: any) => {\n        const value = getControllerValue(event);\n        setInputStateValue(value);\n\n        onChange({\n          target: {\n            value,\n            name: name as InternalFieldName,\n          },\n        });\n      },\n      onBlur: () => {\n        onBlur({\n          target: {\n            name: name as InternalFieldName,\n          },\n          type: EVENTS.BLUR,\n        });\n      },\n      name,\n      value,\n      ref,\n    },\n    meta: {\n      invalid: !!get(errors, name),\n      isDirty: !!get(dirtyFields, name),\n      isTouched: !!get(touchedFields, name),\n      error: get(errors, name),\n      isValidating,\n    },\n  };\n}\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isPrimitive from '../utils/isPrimitive';\n\nexport default (event: any) =>\n  isPrimitive(event) ||\n  !isObject(event.target) ||\n  (isObject(event.target) && !event.type)\n    ? event\n    : isUndefined(event.target.value)\n    ? event.target.checked\n    : event.target.value;\n","import { useController } from './useController';\nimport { ControllerProps, FieldValues } from './types';\n\nconst Controller = <TFieldValues extends FieldValues = FieldValues>(\n  props: ControllerProps<TFieldValues>,\n) => props.render(useController(props));\n\nexport { Controller };\n","// Todo: to be removed\nimport set from '../utils/set';\nimport isKey from '../utils/isKey';\nimport { FieldValues } from '../types';\n\nexport default (data: FieldValues, value: Record<string, any> = {}): any => {\n  for (const key in data) {\n    !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\n  }\n  return value;\n};\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport mapIds from './logic/mapId';\nimport getFieldArrayParentName from './logic/getNodeParentName';\nimport get from './utils/get';\nimport set from './utils/set';\nimport removeArrayAt from './utils/remove';\nimport unset from './utils/unset';\nimport moveArrayAt from './utils/move';\nimport swapArrayAt from './utils/swap';\nimport prependAt from './utils/prepend';\nimport insertAt from './utils/insert';\nimport fillEmptyArray from './utils/fillEmptyArray';\nimport compact from './utils/compact';\nimport isUndefined from './utils/isUndefined';\nimport focusFieldBy from './logic/focusFieldBy';\nimport getFieldsValues from './logic/getFieldsValues';\nimport {\n  FieldValues,\n  UseFieldArrayProps,\n  FieldPath,\n  FieldArrayWithId,\n  UseFieldArrayMethods,\n  FieldArray,\n  FieldArrayMethodsOption,\n  FieldErrors,\n  FieldNamesMarkedBoolean,\n} from './types';\n\nexport const useFieldArray = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TKeyName extends string = 'id'\n>({\n  control,\n  name,\n  keyName = 'id' as TKeyName,\n}: UseFieldArrayProps<TFieldValues, TName, TKeyName>): UseFieldArrayMethods<\n  TFieldValues,\n  TName,\n  TKeyName\n> => {\n  const methods = useFormContext();\n  const focusNameRef = React.useRef('');\n  const {\n    isWatchAllRef,\n    watchFieldsRef,\n    getFormIsDirty,\n    watchSubjectRef,\n    fieldArraySubjectRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    formStateRef,\n    formStateSubjectRef,\n    readFormStateRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n  } = control || methods.control;\n\n  const [fields, setFields] = React.useState<\n    Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[]\n  >(\n    mapIds(\n      get(fieldArrayDefaultValuesRef.current, getFieldArrayParentName(name))\n        ? get(fieldArrayDefaultValuesRef.current, name, [])\n        : get(defaultValuesRef.current, name, []),\n      keyName,\n    ),\n  );\n\n  set(fieldArrayDefaultValuesRef.current, name, [...fields]);\n  fieldArrayNamesRef.current.add(name);\n\n  const omitKey = <\n    T extends Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[]\n  >(\n    fields: T,\n  ) => fields.map(({ [keyName]: omitted, ...rest } = {}) => rest);\n\n  const getCurrentFieldsValues = () => {\n    const values = get(getFieldsValues(fieldsRef, defaultValuesRef), name, []);\n\n    return mapIds<TFieldValues, TKeyName>(\n      get(fieldArrayDefaultValuesRef.current, name, []).map(\n        (item: Partial<TFieldValues>, index: number) => ({\n          ...item,\n          ...values[index],\n        }),\n      ),\n      keyName,\n    );\n  };\n\n  const getFocusDetail = (\n    index: number,\n    options?: FieldArrayMethodsOption,\n  ): string => {\n    if (options) {\n      if (!isUndefined(options.focusIndex)) {\n        return `${name}.${options.focusIndex}`;\n      }\n      if (options.focusName) {\n        return options.focusName;\n      }\n      if (!options.shouldFocus) {\n        return '';\n      }\n    }\n    return `${name}.${index}`;\n  };\n\n  const resetFields = <T>(index?: T) =>\n    (Array.isArray(index) ? index : [index]).forEach((currentIndex) =>\n      set(\n        fieldsRef.current,\n        `${name}${currentIndex ? `.${currentIndex}` : ''}`,\n        [],\n      ),\n    );\n\n  const setFieldsAndNotify = (\n    fieldsValues: Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[],\n  ) => {\n    setFields(mapIds(fieldsValues, keyName));\n    fieldArraySubjectRef.current.next({\n      name,\n      fields: omitKey([...fieldsValues]),\n    });\n  };\n\n  const cleanup = <T>(ref: T) =>\n    !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const updateDirtyFieldsWithDefaultValues = <\n    T extends Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[]\n  >(\n    updatedFieldArrayValues?: T,\n  ) =>\n    updatedFieldArrayValues &&\n    set(\n      formStateRef.current.dirtyFields,\n      name,\n      setFieldArrayDirtyFields(\n        omitKey(updatedFieldArrayValues),\n        get(defaultValuesRef.current, name, []),\n        get(formStateRef.current.dirtyFields, name, []),\n      ),\n    );\n\n  const batchStateUpdate = <\n    T extends Function,\n    K extends Partial<FieldArrayWithId<TFieldValues, TName, TKeyName>>[]\n  >(\n    method: T,\n    args: {\n      argA?: unknown;\n      argB?: unknown;\n    },\n    updatedFieldValues?: K,\n    updatedFormValues: Partial<\n      FieldArrayWithId<TFieldValues, TName, TKeyName>\n    >[] = [],\n    shouldSet = true,\n    shouldUpdateValid = false,\n  ) => {\n    if (get(fieldsRef.current, name)) {\n      const output = method(get(fieldsRef.current, name), args.argA, args.argB);\n      shouldSet && set(fieldsRef.current, name, output);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(\n        get(formStateRef.current.errors, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (\n      readFormStateRef.current.touchedFields &&\n      get(formStateRef.current.touchedFields, name)\n    ) {\n      const output = method(\n        get(formStateRef.current.touchedFields, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.touchedFields, name, output);\n      cleanup(formStateRef.current.touchedFields);\n    }\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      set(\n        formStateRef.current.dirtyFields,\n        name,\n        setFieldArrayDirtyFields(\n          omitKey(updatedFormValues),\n          get(defaultValuesRef.current, name, []),\n          get(formStateRef.current.dirtyFields, name, []),\n        ),\n      );\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (shouldUpdateValid && readFormStateRef.current.isValid) {\n      set(\n        validFieldsRef.current,\n        name,\n        method(get(validFieldsRef.current, name, []), args.argA),\n      );\n      cleanup(validFieldsRef.current);\n\n      set(\n        fieldsWithValidationRef.current,\n        name,\n        method(get(fieldsWithValidationRef.current, name, []), args.argA),\n      );\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    formStateSubjectRef.current.next({\n      isDirty: getFormIsDirty(name, omitKey(updatedFormValues)),\n      errors: formStateRef.current.errors as FieldErrors<TFieldValues>,\n      isValid: formStateRef.current.isValid,\n    });\n  };\n\n  const append = (\n    value:\n      | Partial<FieldArray<TFieldValues, TName>>\n      | Partial<FieldArray<TFieldValues, TName>>[],\n    options?: FieldArrayMethodsOption,\n  ) => {\n    const appendValue = Array.isArray(value) ? value : [value];\n    const updatedFieldValues = [...getCurrentFieldsValues(), ...appendValue];\n    setFieldsAndNotify(updatedFieldValues);\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n\n      formStateSubjectRef.current.next({\n        isDirty: true,\n        dirtyFields: formStateRef.current\n          .dirtyFields as FieldNamesMarkedBoolean<TFieldValues>,\n      });\n    }\n\n    focusNameRef.current = getFocusDetail(\n      updatedFieldValues.length - 1,\n      options,\n    );\n  };\n\n  const prepend = (\n    value:\n      | Partial<FieldArray<TFieldValues, TName>>\n      | Partial<FieldArray<TFieldValues, TName>>[],\n    options?: FieldArrayMethodsOption,\n  ) => {\n    const updatedFieldArrayValues = prependAt(\n      getCurrentFieldsValues(),\n      Array.isArray(value) ? value : [value],\n    );\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(\n      prependAt,\n      {\n        argA: fillEmptyArray(value),\n      },\n      updatedFieldArrayValues,\n    );\n\n    focusNameRef.current = getFocusDetail(0, options);\n  };\n\n  const remove = (index?: number | number[]) => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldValues: Partial<\n      FieldArrayWithId<TFieldValues, TName, TKeyName>\n    >[] = removeArrayAt(fieldValues, index);\n    resetFields(index);\n    batchStateUpdate(\n      removeArrayAt,\n      {\n        argA: index,\n      },\n      updatedFieldValues,\n      removeArrayAt(fieldValues, index),\n      true,\n      true,\n    );\n    setFieldsAndNotify(updatedFieldValues);\n  };\n\n  const insert = (\n    index: number,\n    value:\n      | Partial<FieldArray<TFieldValues, TName>>\n      | Partial<FieldArray<TFieldValues, TName>>[],\n    options?: FieldArrayMethodsOption,\n  ) => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldArrayValues = insertAt(\n      fieldValues,\n      index,\n      Array.isArray(value) ? value : [value],\n    );\n\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(\n      insertAt,\n      {\n        argA: index,\n        argB: fillEmptyArray(value),\n      },\n      updatedFieldArrayValues,\n      fieldValues && insertAt(fieldValues, index),\n    );\n\n    focusNameRef.current = getFocusDetail(index, options);\n  };\n\n  const swap = (indexA: number, indexB: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    batchStateUpdate(\n      swapArrayAt,\n      {\n        argA: indexA,\n        argB: indexB,\n      },\n      undefined,\n      fieldValues,\n      false,\n    );\n    setFieldsAndNotify(fieldValues);\n  };\n\n  const move = (from: number, to: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    setFieldsAndNotify(fieldValues);\n    batchStateUpdate(\n      moveArrayAt,\n      {\n        argA: from,\n        argB: to,\n      },\n      undefined,\n      fieldValues,\n      false,\n    );\n  };\n\n  React.useEffect(() => {\n    if (isWatchAllRef.current) {\n      formStateSubjectRef.current.next({});\n    } else {\n      for (const watchField of watchFieldsRef.current) {\n        if (name.startsWith(watchField)) {\n          formStateSubjectRef.current.next({});\n          break;\n        }\n      }\n    }\n\n    watchSubjectRef.current.next({ name });\n\n    focusNameRef.current &&\n      focusFieldBy(fieldsRef.current, (key: string) =>\n        key.startsWith(focusNameRef.current),\n      );\n\n    focusNameRef.current = '';\n  }, [fields, name]);\n\n  React.useEffect(() => {\n    const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next({ name: inputName, fields, isReset }) {\n        if (isReset) {\n          if (inputName) {\n            const value = getFieldsValues(fieldsRef, defaultValuesRef);\n            set(value, inputName, fields);\n            set(fieldArrayDefaultValuesRef.current, name, fields);\n            setFieldsAndNotify(get(value, name));\n          } else {\n            fieldArrayDefaultValuesRef.current = fields;\n            setFieldsAndNotify(get(fields, name));\n          }\n        }\n      },\n    });\n\n    return () => {\n      fieldArraySubscription.unsubscribe();\n      unset(fieldArrayDefaultValuesRef.current, name);\n      fieldArrayNamesRef.current.delete(name);\n    };\n  }, []);\n\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend, [name]),\n    append: React.useCallback(append, [name]),\n    remove: React.useCallback(remove, [name]),\n    insert: React.useCallback(insert, [name]),\n    fields: fields as FieldArrayWithId<TFieldValues, TName, TKeyName>,\n  };\n};\n","export default ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll,\n}: {\n  isOnAll?: boolean;\n  isOnBlur?: boolean;\n  isOnChange?: boolean;\n  isReValidateOnBlur?: boolean;\n  isReValidateOnChange?: boolean;\n  isBlurEvent?: boolean;\n  isSubmitted?: boolean;\n  isOnTouch?: boolean;\n  isTouched?: boolean;\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n  return true;\n};\n","import isRadioInput from './isRadioInput';\nimport isCheckBoxInput from './isCheckBoxInput';\nimport { FieldElement } from '../types';\n\nexport default (ref: FieldElement): ref is HTMLInputElement =>\n  isRadioInput(ref) || isCheckBoxInput(ref);\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport isUndefined from './utils/isUndefined';\nimport isString from './utils/isString';\nimport get from './utils/get';\nimport isObject from './utils/isObject';\nimport {\n  DeepPartial,\n  UseWatchProps,\n  FieldValues,\n  UnpackNestedValue,\n  Control,\n  FieldPath,\n  InternalFieldName,\n  FieldPathValue,\n  FieldPathValues,\n} from './types';\n\nexport function useWatch<\n  TFieldValues extends FieldValues = FieldValues\n>(props: {\n  defaultValue?: UnpackNestedValue<DeepPartial<TFieldValues>>;\n  control?: Control<TFieldValues>;\n}): UnpackNestedValue<DeepPartial<TFieldValues>>;\nexport function useWatch<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>(props: {\n  name: TName;\n  defaultValue?: FieldPathValue<TFieldValues, TName>;\n  control?: Control<TFieldValues>;\n}): FieldPathValue<TFieldValues, TName>;\nexport function useWatch<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues>[] = FieldPath<TFieldValues>[]\n>(props: {\n  name: TName;\n  defaultValue?: UnpackNestedValue<DeepPartial<TFieldValues>>;\n  control?: Control<TFieldValues>;\n}): FieldPathValues<TFieldValues, TName>;\nexport function useWatch<TFieldValues>({\n  control,\n  name,\n  defaultValue,\n}: UseWatchProps<TFieldValues>) {\n  const methods = useFormContext();\n\n  const { watchInternal, defaultValuesRef, watchSubjectRef } =\n    control || methods.control;\n  const [value, updateValue] = React.useState<unknown>(\n    isUndefined(defaultValue)\n      ? Array.isArray(name)\n        ? name.reduce(\n            (previous, inputName) => ({\n              ...previous,\n              [inputName]: get(defaultValuesRef.current, inputName as string),\n            }),\n            {},\n          )\n        : isString(name)\n        ? get(defaultValuesRef.current, name)\n        : defaultValuesRef.current\n      : defaultValue,\n  );\n\n  React.useEffect(() => {\n    const watchSubscription = watchSubjectRef.current.subscribe({\n      next: ({ name: inputName, value }) => {\n        updateValue(\n          isString(inputName) && name === inputName && !isUndefined(value)\n            ? value\n            : name && isObject(value)\n            ? get(value, name as InternalFieldName, defaultValue)\n            : watchInternal(name as string, defaultValue),\n        );\n      },\n    });\n\n    return () => watchSubscription.unsubscribe();\n  }, [name]);\n\n  return value;\n}\n"],"names":["val","undefined","value","isObjectType","isNullOrUndefined","Array","isArray","Date","filter","Boolean","obj","path","defaultValue","result","compact","split","reduce","key","isUndefined","test","input","replace","set","object","index","tempPath","isKey","stringToPath","length","lastIndex","newValue","objValue","isObject","isNaN","focusFieldBy","fields","callback","fieldsNames","Object","keys","field","get","_f","current","name","ref","focus","refs","deepEqual","object1","object2","isErrorObject","isPrimitive","React.isValidElement","keys1","keys2","val1","val2","setDirtyFields","values","defaultValues","dirtyFields","parentNode","parentName","[object Object]","deepMerge","target","source","targetValue","sourceValue","slice","EVENTS","VALIDATION_MODE","INPUT_VALIDATION_RULES","formState","readFormStateRef","isRoot","isEmptyObject","find","valueAsNumber","valueAsDate","setValueAs","shouldReturnAsValue","NaN","getFieldsValues","fieldsRef","defaultValuesRef","output","disabled","getFieldValueAs","defaultReturn","isValid","options","previous","option","checked","element","type","defaultResult","validResult","map","attributes","getFieldValue","isFileInput","files","isRadioInput","getRadioValue","isMultipleSelect","selected","isCheckBox","getCheckboxValue","RegExp","validationData","isRegex","message","isString","getValidateError","isMessage","isBoolean","validateAllFieldCriteria","errors","types","async","required","maxLength","minLength","min","max","pattern","validate","inputValue","error","isRadio","isCheckBoxInput","isRadioOrCheckbox","isEmpty","appendErrorsCurry","appendErrors","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","getValueAndMessage","exceedMin","maxOutput","minOutput","valueDate","valueNumber","parseFloat","maxLengthOutput","minLengthOutput","patternValue","validateRef","isFunction","validateError","validationResult","validateFunction","entries","substring","search","names","some","getNodeParentName","isProxyEnabled","localReadFormStateRef","Proxy","prop","Subscription","this","tearDown","tearDowns","push","teardown","Subscriber","observer","subscription","add","closed","next","Subject","observers","subscriber","window","document","isWeb","getPath","rootPath","paths","property","unset","updatePath","childObject","baseGet","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","data","mode","isOnSubmit","isOnBlur","isOnChange","isOnAll","isOnTouch","HTMLElement","getFields","fieldsRefs","currentFields","isWindowUndefined","FormContext","React.createContext","displayName","useFormContext","React.useContext","d","performance","now","c","r","Math","random","toString","keyName","generateId","indexes","i","temp","splice","removeAtIndexes","sort","from","to","indexA","indexB","prepend","insert","fill","useFormState","control","methods","formStateRef","formStateSubjectRef","updateFormState","React.useState","readFormState","React.useRef","cloneObject","copy","File","isHTMLElement","getTime","Set","Map","React.useEffect","formStateSubscription","subscribe","shouldRenderFormState","unsubscribe","getProxyFormState","useController","rules","register","fieldArrayNamesRef","controllerSubjectRef","onChange","onBlur","getInitialValue","isNameInFieldArray","setInputStateValue","touchedFields","isValidating","controllerSubscription","event","getControllerValue","meta","invalid","isDirty","isTouched","props","render","_a","children","React.createElement","Provider","focusNameRef","isWatchAllRef","watchFieldsRef","getFormIsDirty","watchSubjectRef","fieldArraySubjectRef","validFieldsRef","fieldsWithValidationRef","fieldArrayDefaultValuesRef","setFields","mapIds","getFieldArrayParentName","omitKey","_b","getCurrentFieldsValues","getFocusDetail","focusIndex","focusName","shouldFocus","setFieldsAndNotify","fieldsValues","cleanup","updateDirtyFieldsWithDefaultValues","updatedFieldArrayValues","setFieldArrayDirtyFields","batchStateUpdate","method","args","updatedFieldValues","updatedFormValues","shouldSet","shouldUpdateValid","argA","argB","watchField","startsWith","fieldArraySubscription","inputName","isReset","delete","swap","React.useCallback","fieldValues","swapArrayAt","move","moveArrayAt","prependAt","fillEmptyArray","append","appendValue","remove","removeArrayAt","forEach","currentIndex","resetFields","insertAt","reValidateMode","resolver","context","shouldFocusError","criteriaMode","fieldsNamesRef","fieldArrayUpdatedValuesRef","isMountedRef","contextRef","resolverRef","validationMode","getValidationModes","isValidateAllFieldCriteria","setFormState","isSubmitted","submitCount","isSubmitting","isSubmitSuccessful","getIsValid","shouldRenderBaseOnError","shouldRender","state","shouldReRender","validFields","fieldsWithValidation","previousError","isErrorStateChanged","setFieldValue","rawValue","radioRef","selectRef","includes","checkboxRef","formValues","getValues","updateAndGetDirtyState","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","validateField","executeSchemaOrResolverValidation","currentNames","validateForm","fieldError","trigger","Promise","all","setInternalValues","shouldDirty","shouldValidate","fieldName","setInternalValue","has","isFieldWatched","match","updateValueAndGetDefault","isFieldArray","handleChange","inputType","isBlurEvent","isReValidateOnBlur","isReValidateOnChange","shouldSkipValidation","skipValidation","isWatched","previousFormIsValid","parentNodeName","currentError","fieldNames","updateIsValid","watchInternal","isGlobal","isArrayNames","registerFieldRef","isRadioOrCheckboxFunction","contains","then","handleSubmit","onValid","onInvalid","e","preventDefault","persist","every","useFieldArraySubscription","React.useMemo","watch","info","setValue","reset","keepStateOptions","updatedValues","keepValues","inputRef","closest","keepDefaultValues","keepErrors","keepDirty","keepIsSubmitted","keepTouched","keepIsValid","keepSubmitCount","resetFromState","clearErrors","unregister","setError","updateValue","watchSubscription"],"mappings":"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"}